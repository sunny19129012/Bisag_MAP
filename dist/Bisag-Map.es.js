var up = Object.defineProperty;
var dp = (n, e, t) => e in n ? up(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Jt = (n, e, t) => dp(n, typeof e != "symbol" ? e + "" : e, t);
import he, { useState as st, useRef as ei, useLayoutEffect as Gf, useEffect as xt, useSyncExternalStore as fp, isValidElement as Na, cloneElement as _h, useCallback as Oo } from "react";
var Tc = { exports: {} }, fs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qu;
function gp() {
  if (qu) return fs;
  qu = 1;
  var n = he, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), i = Object.prototype.hasOwnProperty, r = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, c) {
    var h, u = {}, d = null, f = null;
    c !== void 0 && (d = "" + c), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (h in l) i.call(l, h) && !s.hasOwnProperty(h) && (u[h] = l[h]);
    if (a && a.defaultProps) for (h in l = a.defaultProps, l) u[h] === void 0 && (u[h] = l[h]);
    return { $$typeof: e, type: a, key: d, ref: f, props: u, _owner: r.current };
  }
  return fs.Fragment = t, fs.jsx = o, fs.jsxs = o, fs;
}
var gs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ju;
function mp() {
  return Ju || (Ju = 1, process.env.NODE_ENV !== "production" && function() {
    var n = he, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), g = Symbol.iterator, _ = "@@iterator";
    function m(T) {
      if (T === null || typeof T != "object")
        return null;
      var L = g && T[g] || T[_];
      return typeof L == "function" ? L : null;
    }
    var y = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function p(T) {
      {
        for (var L = arguments.length, z = new Array(L > 1 ? L - 1 : 0), te = 1; te < L; te++)
          z[te - 1] = arguments[te];
        E("error", T, z);
      }
    }
    function E(T, L, z) {
      {
        var te = y.ReactDebugCurrentFrame, Te = te.getStackAddendum();
        Te !== "" && (L += "%s", z = z.concat([Te]));
        var be = z.map(function(fe) {
          return String(fe);
        });
        be.unshift("Warning: " + L), Function.prototype.apply.call(console[T], console, be);
      }
    }
    var x = !1, v = !1, S = !1, w = !1, b = !1, P;
    P = Symbol.for("react.module.reference");
    function O(T) {
      return !!(typeof T == "string" || typeof T == "function" || T === i || T === s || b || T === r || T === c || T === h || w || T === f || x || v || S || typeof T == "object" && T !== null && (T.$$typeof === d || T.$$typeof === u || T.$$typeof === o || T.$$typeof === a || T.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      T.$$typeof === P || T.getModuleId !== void 0));
    }
    function N(T, L, z) {
      var te = T.displayName;
      if (te)
        return te;
      var Te = L.displayName || L.name || "";
      return Te !== "" ? z + "(" + Te + ")" : z;
    }
    function k(T) {
      return T.displayName || "Context";
    }
    function D(T) {
      if (T == null)
        return null;
      if (typeof T.tag == "number" && p("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof T == "function")
        return T.displayName || T.name || null;
      if (typeof T == "string")
        return T;
      switch (T) {
        case i:
          return "Fragment";
        case t:
          return "Portal";
        case s:
          return "Profiler";
        case r:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case a:
            var L = T;
            return k(L) + ".Consumer";
          case o:
            var z = T;
            return k(z._context) + ".Provider";
          case l:
            return N(T, T.render, "ForwardRef");
          case u:
            var te = T.displayName || null;
            return te !== null ? te : D(T.type) || "Memo";
          case d: {
            var Te = T, be = Te._payload, fe = Te._init;
            try {
              return D(fe(be));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var U = Object.assign, X = 0, I, F, B, $, H, re, A;
    function Fe() {
    }
    Fe.__reactDisabledLog = !0;
    function ze() {
      {
        if (X === 0) {
          I = console.log, F = console.info, B = console.warn, $ = console.error, H = console.group, re = console.groupCollapsed, A = console.groupEnd;
          var T = {
            configurable: !0,
            enumerable: !0,
            value: Fe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: T,
            log: T,
            warn: T,
            error: T,
            group: T,
            groupCollapsed: T,
            groupEnd: T
          });
        }
        X++;
      }
    }
    function Ce() {
      {
        if (X--, X === 0) {
          var T = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: U({}, T, {
              value: I
            }),
            info: U({}, T, {
              value: F
            }),
            warn: U({}, T, {
              value: B
            }),
            error: U({}, T, {
              value: $
            }),
            group: U({}, T, {
              value: H
            }),
            groupCollapsed: U({}, T, {
              value: re
            }),
            groupEnd: U({}, T, {
              value: A
            })
          });
        }
        X < 0 && p("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var nt = y.ReactCurrentDispatcher, We;
    function ft(T, L, z) {
      {
        if (We === void 0)
          try {
            throw Error();
          } catch (Te) {
            var te = Te.stack.trim().match(/\n( *(at )?)/);
            We = te && te[1] || "";
          }
        return `
` + We + T;
      }
    }
    var gt = !1, qe;
    {
      var dr = typeof WeakMap == "function" ? WeakMap : Map;
      qe = new dr();
    }
    function fr(T, L) {
      if (!T || gt)
        return "";
      {
        var z = qe.get(T);
        if (z !== void 0)
          return z;
      }
      var te;
      gt = !0;
      var Te = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var be;
      be = nt.current, nt.current = null, ze();
      try {
        if (L) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Rt) {
              te = Rt;
            }
            Reflect.construct(T, [], fe);
          } else {
            try {
              fe.call();
            } catch (Rt) {
              te = Rt;
            }
            T.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Rt) {
            te = Rt;
          }
          T();
        }
      } catch (Rt) {
        if (Rt && te && typeof Rt.stack == "string") {
          for (var ue = Rt.stack.split(`
`), pt = te.stack.split(`
`), Ne = ue.length - 1, $e = pt.length - 1; Ne >= 1 && $e >= 0 && ue[Ne] !== pt[$e]; )
            $e--;
          for (; Ne >= 1 && $e >= 0; Ne--, $e--)
            if (ue[Ne] !== pt[$e]) {
              if (Ne !== 1 || $e !== 1)
                do
                  if (Ne--, $e--, $e < 0 || ue[Ne] !== pt[$e]) {
                    var Wt = `
` + ue[Ne].replace(" at new ", " at ");
                    return T.displayName && Wt.includes("<anonymous>") && (Wt = Wt.replace("<anonymous>", T.displayName)), typeof T == "function" && qe.set(T, Wt), Wt;
                  }
                while (Ne >= 1 && $e >= 0);
              break;
            }
        }
      } finally {
        gt = !1, nt.current = be, Ce(), Error.prepareStackTrace = Te;
      }
      var _r = T ? T.displayName || T.name : "", Mi = _r ? ft(_r) : "";
      return typeof T == "function" && qe.set(T, Mi), Mi;
    }
    function Ai(T, L, z) {
      return fr(T, !1);
    }
    function In(T) {
      var L = T.prototype;
      return !!(L && L.isReactComponent);
    }
    function it(T, L, z) {
      if (T == null)
        return "";
      if (typeof T == "function")
        return fr(T, In(T));
      if (typeof T == "string")
        return ft(T);
      switch (T) {
        case c:
          return ft("Suspense");
        case h:
          return ft("SuspenseList");
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case l:
            return Ai(T.render);
          case u:
            return it(T.type, L, z);
          case d: {
            var te = T, Te = te._payload, be = te._init;
            try {
              return it(be(Te), L, z);
            } catch {
            }
          }
        }
      return "";
    }
    var ot = Object.prototype.hasOwnProperty, An = {}, Ln = y.ReactDebugCurrentFrame;
    function fn(T) {
      if (T) {
        var L = T._owner, z = it(T.type, T._source, L ? L.type : null);
        Ln.setExtraStackFrame(z);
      } else
        Ln.setExtraStackFrame(null);
    }
    function On(T, L, z, te, Te) {
      {
        var be = Function.call.bind(ot);
        for (var fe in T)
          if (be(T, fe)) {
            var ue = void 0;
            try {
              if (typeof T[fe] != "function") {
                var pt = Error((te || "React class") + ": " + z + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof T[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              ue = T[fe](L, fe, te, z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ne) {
              ue = Ne;
            }
            ue && !(ue instanceof Error) && (fn(Te), p("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", z, fe, typeof ue), fn(null)), ue instanceof Error && !(ue.message in An) && (An[ue.message] = !0, fn(Te), p("Failed %s type: %s", z, ue.message), fn(null));
          }
      }
    }
    var hi = Array.isArray;
    function gn(T) {
      return hi(T);
    }
    function Ye(T) {
      {
        var L = typeof Symbol == "function" && Symbol.toStringTag, z = L && T[Symbol.toStringTag] || T.constructor.name || "Object";
        return z;
      }
    }
    function os(T) {
      try {
        return gr(T), !1;
      } catch {
        return !0;
      }
    }
    function gr(T) {
      return "" + T;
    }
    function Li(T) {
      if (os(T))
        return p("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(T)), gr(T);
    }
    var Oi = y.ReactCurrentOwner, Pl = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, as, ls;
    function cs(T) {
      if (ot.call(T, "ref")) {
        var L = Object.getOwnPropertyDescriptor(T, "ref").get;
        if (L && L.isReactWarning)
          return !1;
      }
      return T.ref !== void 0;
    }
    function Il(T) {
      if (ot.call(T, "key")) {
        var L = Object.getOwnPropertyDescriptor(T, "key").get;
        if (L && L.isReactWarning)
          return !1;
      }
      return T.key !== void 0;
    }
    function Al(T, L) {
      typeof T.ref == "string" && Oi.current;
    }
    function Po(T, L) {
      {
        var z = function() {
          as || (as = !0, p("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", L));
        };
        z.isReactWarning = !0, Object.defineProperty(T, "key", {
          get: z,
          configurable: !0
        });
      }
    }
    function Io(T, L) {
      {
        var z = function() {
          ls || (ls = !0, p("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", L));
        };
        z.isReactWarning = !0, Object.defineProperty(T, "ref", {
          get: z,
          configurable: !0
        });
      }
    }
    var hs = function(T, L, z, te, Te, be, fe) {
      var ue = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: T,
        key: L,
        ref: z,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: be
      };
      return ue._store = {}, Object.defineProperty(ue._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ue, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ue, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.freeze && (Object.freeze(ue.props), Object.freeze(ue)), ue;
    };
    function Ao(T, L, z, te, Te) {
      {
        var be, fe = {}, ue = null, pt = null;
        z !== void 0 && (Li(z), ue = "" + z), Il(L) && (Li(L.key), ue = "" + L.key), cs(L) && (pt = L.ref, Al(L, Te));
        for (be in L)
          ot.call(L, be) && !Pl.hasOwnProperty(be) && (fe[be] = L[be]);
        if (T && T.defaultProps) {
          var Ne = T.defaultProps;
          for (be in Ne)
            fe[be] === void 0 && (fe[be] = Ne[be]);
        }
        if (ue || pt) {
          var $e = typeof T == "function" ? T.displayName || T.name || "Unknown" : T;
          ue && Po(fe, $e), pt && Io(fe, $e);
        }
        return hs(T, ue, pt, Te, te, Oi.current, fe);
      }
    }
    var us = y.ReactCurrentOwner, mr = y.ReactDebugCurrentFrame;
    function Bt(T) {
      if (T) {
        var L = T._owner, z = it(T.type, T._source, L ? L.type : null);
        mr.setExtraStackFrame(z);
      } else
        mr.setExtraStackFrame(null);
    }
    var Mn;
    Mn = !1;
    function Dn(T) {
      return typeof T == "object" && T !== null && T.$$typeof === e;
    }
    function ds() {
      {
        if (us.current) {
          var T = D(us.current.type);
          if (T)
            return `

Check the render method of \`` + T + "`.";
        }
        return "";
      }
    }
    function Lo(T) {
      return "";
    }
    var mt = {};
    function Fn(T) {
      {
        var L = ds();
        if (!L) {
          var z = typeof T == "string" ? T : T.displayName || T.name;
          z && (L = `

Check the top-level render call using <` + z + ">.");
        }
        return L;
      }
    }
    function _t(T, L) {
      {
        if (!T._store || T._store.validated || T.key != null)
          return;
        T._store.validated = !0;
        var z = Fn(L);
        if (mt[z])
          return;
        mt[z] = !0;
        var te = "";
        T && T._owner && T._owner !== us.current && (te = " It was passed a child from " + D(T._owner.type) + "."), Bt(T), p('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', z, te), Bt(null);
      }
    }
    function kt(T, L) {
      {
        if (typeof T != "object")
          return;
        if (gn(T))
          for (var z = 0; z < T.length; z++) {
            var te = T[z];
            Dn(te) && _t(te, L);
          }
        else if (Dn(T))
          T._store && (T._store.validated = !0);
        else if (T) {
          var Te = m(T);
          if (typeof Te == "function" && Te !== T.entries)
            for (var be = Te.call(T), fe; !(fe = be.next()).done; )
              Dn(fe.value) && _t(fe.value, L);
        }
      }
    }
    function bt(T) {
      {
        var L = T.type;
        if (L == null || typeof L == "string")
          return;
        var z;
        if (typeof L == "function")
          z = L.propTypes;
        else if (typeof L == "object" && (L.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        L.$$typeof === u))
          z = L.propTypes;
        else
          return;
        if (z) {
          var te = D(L);
          On(z, T.props, "prop", te, T);
        } else if (L.PropTypes !== void 0 && !Mn) {
          Mn = !0;
          var Te = D(L);
          p("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
        }
        typeof L.getDefaultProps == "function" && !L.getDefaultProps.isReactClassApproved && p("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Zt(T) {
      {
        for (var L = Object.keys(T.props), z = 0; z < L.length; z++) {
          var te = L[z];
          if (te !== "children" && te !== "key") {
            Bt(T), p("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), Bt(null);
            break;
          }
        }
        T.ref !== null && (Bt(T), p("Invalid attribute `ref` supplied to `React.Fragment`."), Bt(null));
      }
    }
    var zt = {};
    function Pe(T, L, z, te, Te, be) {
      {
        var fe = O(T);
        if (!fe) {
          var ue = "";
          (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = Lo();
          pt ? ue += pt : ue += ds();
          var Ne;
          T === null ? Ne = "null" : gn(T) ? Ne = "array" : T !== void 0 && T.$$typeof === e ? (Ne = "<" + (D(T.type) || "Unknown") + " />", ue = " Did you accidentally export a JSX literal instead of a component?") : Ne = typeof T, p("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ne, ue);
        }
        var $e = Ao(T, L, z, Te, be);
        if ($e == null)
          return $e;
        if (fe) {
          var Wt = L.children;
          if (Wt !== void 0)
            if (te)
              if (gn(Wt)) {
                for (var _r = 0; _r < Wt.length; _r++)
                  kt(Wt[_r], T);
                Object.freeze && Object.freeze(Wt);
              } else
                p("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(Wt, T);
        }
        if (ot.call(L, "key")) {
          var Mi = D(T), Rt = Object.keys(L).filter(function(hp) {
            return hp !== "key";
          }), Ol = Rt.length > 0 ? "{key: someKey, " + Rt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!zt[Mi + Ol]) {
            var cp = Rt.length > 0 ? "{" + Rt.join(": ..., ") + ": ...}" : "{}";
            p(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ol, Mi, cp, Mi), zt[Mi + Ol] = !0;
          }
        }
        return T === i ? Zt($e) : bt($e), $e;
      }
    }
    function rt(T, L, z) {
      return Pe(T, L, z, !0);
    }
    function qt(T, L, z) {
      return Pe(T, L, z, !1);
    }
    var Ll = qt, lp = rt;
    gs.Fragment = i, gs.jsx = Ll, gs.jsxs = lp;
  }()), gs;
}
process.env.NODE_ENV === "production" ? Tc.exports = gp() : Tc.exports = mp();
var j = Tc.exports;
function Uf(n) {
  var e, t, i = "";
  if (typeof n == "string" || typeof n == "number") i += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var r = n.length;
    for (e = 0; e < r; e++) n[e] && (t = Uf(n[e])) && (i && (i += " "), i += t);
  } else for (t in n) n[t] && (i && (i += " "), i += t);
  return i;
}
function ji() {
  for (var n, e, t = 0, i = "", r = arguments.length; t < r; t++) (n = arguments[t]) && (e = Uf(n)) && (i && (i += " "), i += e);
  return i;
}
function _p(n) {
  if (typeof document > "u") return;
  let e = document.head || document.getElementsByTagName("head")[0], t = document.createElement("style");
  t.type = "text/css", e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t), t.styleSheet ? t.styleSheet.cssText = n : t.appendChild(document.createTextNode(n));
}
_p(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}
`);
var io = (n) => typeof n == "number" && !isNaN(n), Qi = (n) => typeof n == "string", ti = (n) => typeof n == "function", pp = (n) => Qi(n) || io(n), wc = (n) => Qi(n) || ti(n) ? n : null, yp = (n, e) => n === !1 || io(n) && n > 0 ? n : e, Sc = (n) => Na(n) || Qi(n) || ti(n) || io(n);
function xp(n, e, t = 300) {
  let { scrollHeight: i, style: r } = n;
  requestAnimationFrame(() => {
    r.minHeight = "initial", r.height = i + "px", r.transition = `all ${t}ms`, requestAnimationFrame(() => {
      r.height = "0", r.padding = "0", r.margin = "0", setTimeout(e, t);
    });
  });
}
function vp({ enter: n, exit: e, appendPosition: t = !1, collapse: i = !0, collapseDuration: r = 300 }) {
  return function({ children: s, position: o, preventExitTransition: a, done: l, nodeRef: c, isIn: h, playToast: u }) {
    let d = t ? `${n}--${o}` : n, f = t ? `${e}--${o}` : e, g = ei(0);
    return Gf(() => {
      let _ = c.current, m = d.split(" "), y = (p) => {
        p.target === c.current && (u(), _.removeEventListener("animationend", y), _.removeEventListener("animationcancel", y), g.current === 0 && p.type !== "animationcancel" && _.classList.remove(...m));
      };
      _.classList.add(...m), _.addEventListener("animationend", y), _.addEventListener("animationcancel", y);
    }, []), xt(() => {
      let _ = c.current, m = () => {
        _.removeEventListener("animationend", m), i ? xp(_, l, r) : l();
      };
      h || (a ? m() : (g.current = 1, _.className += ` ${f}`, _.addEventListener("animationend", m)));
    }, [h]), he.createElement(he.Fragment, null, s);
  };
}
function Qu(n, e) {
  return { content: Bf(n.content, n.props), containerId: n.props.containerId, id: n.props.toastId, theme: n.props.theme, type: n.props.type, data: n.props.data || {}, isLoading: n.props.isLoading, icon: n.props.icon, reason: n.removalReason, status: e };
}
function Bf(n, e, t = !1) {
  return Na(n) && !Qi(n.type) ? _h(n, { closeToast: e.closeToast, toastProps: e, data: e.data, isPaused: t }) : ti(n) ? n({ closeToast: e.closeToast, toastProps: e, data: e.data, isPaused: t }) : n;
}
function Ep({ closeToast: n, theme: e, ariaLabel: t = "close" }) {
  return he.createElement("button", { className: `Toastify__close-button Toastify__close-button--${e}`, type: "button", onClick: (i) => {
    i.stopPropagation(), n(!0);
  }, "aria-label": t }, he.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, he.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function Tp({ delay: n, isRunning: e, closeToast: t, type: i = "default", hide: r, className: s, controlledProgress: o, progress: a, rtl: l, isIn: c, theme: h }) {
  let u = r || o && a === 0, d = { animationDuration: `${n}ms`, animationPlayState: e ? "running" : "paused" };
  o && (d.transform = `scaleX(${a})`);
  let f = ji("Toastify__progress-bar", o ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${h}`, `Toastify__progress-bar--${i}`, { "Toastify__progress-bar--rtl": l }), g = ti(s) ? s({ rtl: l, type: i, defaultClassName: f }) : ji(f, s), _ = { [o && a >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: o && a < 1 ? null : () => {
    c && t();
  } };
  return he.createElement("div", { className: "Toastify__progress-bar--wrp", "data-hidden": u }, he.createElement("div", { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${h} Toastify__progress-bar--${i}` }), he.createElement("div", { role: "progressbar", "aria-hidden": u ? "true" : "false", "aria-label": "notification timer", className: g, style: d, ..._ }));
}
var wp = 1, zf = () => `${wp++}`;
function Sp(n, e, t) {
  let i = 1, r = 0, s = [], o = [], a = e, l = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), h = (p) => (c.add(p), () => c.delete(p)), u = () => {
    o = Array.from(l.values()), c.forEach((p) => p());
  }, d = ({ containerId: p, toastId: E, updateId: x }) => {
    let v = p ? p !== n : n !== 1, S = l.has(E) && x == null;
    return v || S;
  }, f = (p, E) => {
    l.forEach((x) => {
      var v;
      (E == null || E === x.props.toastId) && ((v = x.toggle) == null || v.call(x, p));
    });
  }, g = (p) => {
    var E, x;
    (x = (E = p.props) == null ? void 0 : E.onClose) == null || x.call(E, p.removalReason), p.isActive = !1;
  }, _ = (p) => {
    if (p == null) l.forEach(g);
    else {
      let E = l.get(p);
      E && g(E);
    }
    u();
  }, m = () => {
    r -= s.length, s = [];
  }, y = (p) => {
    var E, x;
    let { toastId: v, updateId: S } = p.props, w = S == null;
    p.staleId && l.delete(p.staleId), p.isActive = !0, l.set(v, p), u(), t(Qu(p, w ? "added" : "updated")), w && ((x = (E = p.props).onOpen) == null || x.call(E));
  };
  return { id: n, props: a, observe: h, toggle: f, removeToast: _, toasts: l, clearQueue: m, buildToast: (p, E) => {
    if (d(E)) return;
    let { toastId: x, updateId: v, data: S, staleId: w, delay: b } = E, P = v == null;
    P && r++;
    let O = { ...a, style: a.toastStyle, key: i++, ...Object.fromEntries(Object.entries(E).filter(([k, D]) => D != null)), toastId: x, updateId: v, data: S, isIn: !1, className: wc(E.className || a.toastClassName), progressClassName: wc(E.progressClassName || a.progressClassName), autoClose: E.isLoading ? !1 : yp(E.autoClose, a.autoClose), closeToast(k) {
      l.get(x).removalReason = k, _(x);
    }, deleteToast() {
      let k = l.get(x);
      if (k != null) {
        if (t(Qu(k, "removed")), l.delete(x), r--, r < 0 && (r = 0), s.length > 0) {
          y(s.shift());
          return;
        }
        u();
      }
    } };
    O.closeButton = a.closeButton, E.closeButton === !1 || Sc(E.closeButton) ? O.closeButton = E.closeButton : E.closeButton === !0 && (O.closeButton = Sc(a.closeButton) ? a.closeButton : !0);
    let N = { content: p, props: O, staleId: w };
    a.limit && a.limit > 0 && r > a.limit && P ? s.push(N) : io(b) ? setTimeout(() => {
      y(N);
    }, b) : y(N);
  }, setProps(p) {
    a = p;
  }, setToggle: (p, E) => {
    let x = l.get(p);
    x && (x.toggle = E);
  }, isToastActive: (p) => {
    var E;
    return (E = l.get(p)) == null ? void 0 : E.isActive;
  }, getSnapshot: () => o };
}
var Et = /* @__PURE__ */ new Map(), ks = [], bc = /* @__PURE__ */ new Set(), bp = (n) => bc.forEach((e) => e(n)), Wf = () => Et.size > 0;
function Rp() {
  ks.forEach((n) => $f(n.content, n.options)), ks = [];
}
var Cp = (n, { containerId: e }) => {
  var t;
  return (t = Et.get(e || 1)) == null ? void 0 : t.toasts.get(n);
};
function Yf(n, e) {
  var t;
  if (e) return !!((t = Et.get(e)) != null && t.isToastActive(n));
  let i = !1;
  return Et.forEach((r) => {
    r.isToastActive(n) && (i = !0);
  }), i;
}
function Pp(n) {
  if (!Wf()) {
    ks = ks.filter((e) => n != null && e.options.toastId !== n);
    return;
  }
  if (n == null || pp(n)) Et.forEach((e) => {
    e.removeToast(n);
  });
  else if (n && ("containerId" in n || "id" in n)) {
    let e = Et.get(n.containerId);
    e ? e.removeToast(n.id) : Et.forEach((t) => {
      t.removeToast(n.id);
    });
  }
}
var Ip = (n = {}) => {
  Et.forEach((e) => {
    e.props.limit && (!n.containerId || e.id === n.containerId) && e.clearQueue();
  });
};
function $f(n, e) {
  Sc(n) && (Wf() || ks.push({ content: n, options: e }), Et.forEach((t) => {
    t.buildToast(n, e);
  }));
}
function Ap(n) {
  var e;
  (e = Et.get(n.containerId || 1)) == null || e.setToggle(n.id, n.fn);
}
function jf(n, e) {
  Et.forEach((t) => {
    (e == null || !(e != null && e.containerId) || (e == null ? void 0 : e.containerId) === t.id) && t.toggle(n, e == null ? void 0 : e.id);
  });
}
function Lp(n) {
  let e = n.containerId || 1;
  return { subscribe(t) {
    let i = Sp(e, n, bp);
    Et.set(e, i);
    let r = i.observe(t);
    return Rp(), () => {
      r(), Et.delete(e);
    };
  }, setProps(t) {
    var i;
    (i = Et.get(e)) == null || i.setProps(t);
  }, getSnapshot() {
    var t;
    return (t = Et.get(e)) == null ? void 0 : t.getSnapshot();
  } };
}
function Op(n) {
  return bc.add(n), () => {
    bc.delete(n);
  };
}
function Mp(n) {
  return n && (Qi(n.toastId) || io(n.toastId)) ? n.toastId : zf();
}
function ro(n, e) {
  return $f(n, e), e.toastId;
}
function Ga(n, e) {
  return { ...e, type: e && e.type || n, toastId: Mp(e) };
}
function Ua(n) {
  return (e, t) => ro(e, Ga(n, t));
}
function we(n, e) {
  return ro(n, Ga("default", e));
}
we.loading = (n, e) => ro(n, Ga("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...e }));
function Dp(n, { pending: e, error: t, success: i }, r) {
  let s;
  e && (s = Qi(e) ? we.loading(e, r) : we.loading(e.render, { ...r, ...e }));
  let o = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, a = (c, h, u) => {
    if (h == null) {
      we.dismiss(s);
      return;
    }
    let d = { type: c, ...o, ...r, data: u }, f = Qi(h) ? { render: h } : h;
    return s ? we.update(s, { ...d, ...f }) : we(f.render, { ...d, ...f }), u;
  }, l = ti(n) ? n() : n;
  return l.then((c) => a("success", i, c)).catch((c) => a("error", t, c)), l;
}
we.promise = Dp;
we.success = Ua("success");
we.info = Ua("info");
we.error = Ua("error");
we.warning = Ua("warning");
we.warn = we.warning;
we.dark = (n, e) => ro(n, Ga("default", { theme: "dark", ...e }));
function Fp(n) {
  Pp(n);
}
we.dismiss = Fp;
we.clearWaitingQueue = Ip;
we.isActive = Yf;
we.update = (n, e = {}) => {
  let t = Cp(n, e);
  if (t) {
    let { props: i, content: r } = t, s = { delay: 100, ...i, ...e, toastId: e.toastId || n, updateId: zf() };
    s.toastId !== n && (s.staleId = n);
    let o = s.render || r;
    delete s.render, ro(o, s);
  }
};
we.done = (n) => {
  we.update(n, { progress: 1 });
};
we.onChange = Op;
we.play = (n) => jf(!0, n);
we.pause = (n) => jf(!1, n);
function kp(n) {
  var e;
  let { subscribe: t, getSnapshot: i, setProps: r } = ei(Lp(n)).current;
  r(n);
  let s = (e = fp(t, i, i)) == null ? void 0 : e.slice();
  function o(a) {
    if (!s) return [];
    let l = /* @__PURE__ */ new Map();
    return n.newestOnTop && s.reverse(), s.forEach((c) => {
      let { position: h } = c.props;
      l.has(h) || l.set(h, []), l.get(h).push(c);
    }), Array.from(l, (c) => a(c[0], c[1]));
  }
  return { getToastToRender: o, isToastActive: Yf, count: s == null ? void 0 : s.length };
}
function Np(n) {
  let [e, t] = st(!1), [i, r] = st(!1), s = ei(null), o = ei({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current, { autoClose: a, pauseOnHover: l, closeToast: c, onClick: h, closeOnClick: u } = n;
  Ap({ id: n.toastId, containerId: n.containerId, fn: t }), xt(() => {
    if (n.pauseOnFocusLoss) return d(), () => {
      f();
    };
  }, [n.pauseOnFocusLoss]);
  function d() {
    document.hasFocus() || y(), window.addEventListener("focus", m), window.addEventListener("blur", y);
  }
  function f() {
    window.removeEventListener("focus", m), window.removeEventListener("blur", y);
  }
  function g(w) {
    if (n.draggable === !0 || n.draggable === w.pointerType) {
      p();
      let b = s.current;
      o.canCloseOnClick = !0, o.canDrag = !0, b.style.transition = "none", n.draggableDirection === "x" ? (o.start = w.clientX, o.removalDistance = b.offsetWidth * (n.draggablePercent / 100)) : (o.start = w.clientY, o.removalDistance = b.offsetHeight * (n.draggablePercent === 80 ? n.draggablePercent * 1.5 : n.draggablePercent) / 100);
    }
  }
  function _(w) {
    let { top: b, bottom: P, left: O, right: N } = s.current.getBoundingClientRect();
    w.nativeEvent.type !== "touchend" && n.pauseOnHover && w.clientX >= O && w.clientX <= N && w.clientY >= b && w.clientY <= P ? y() : m();
  }
  function m() {
    t(!0);
  }
  function y() {
    t(!1);
  }
  function p() {
    o.didMove = !1, document.addEventListener("pointermove", x), document.addEventListener("pointerup", v);
  }
  function E() {
    document.removeEventListener("pointermove", x), document.removeEventListener("pointerup", v);
  }
  function x(w) {
    let b = s.current;
    if (o.canDrag && b) {
      o.didMove = !0, e && y(), n.draggableDirection === "x" ? o.delta = w.clientX - o.start : o.delta = w.clientY - o.start, o.start !== w.clientX && (o.canCloseOnClick = !1);
      let P = n.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`;
      b.style.transform = `translate3d(${P},0)`, b.style.opacity = `${1 - Math.abs(o.delta / o.removalDistance)}`;
    }
  }
  function v() {
    E();
    let w = s.current;
    if (o.canDrag && o.didMove && w) {
      if (o.canDrag = !1, Math.abs(o.delta) > o.removalDistance) {
        r(!0), n.closeToast(!0), n.collapseAll();
        return;
      }
      w.style.transition = "transform 0.2s, opacity 0.2s", w.style.removeProperty("transform"), w.style.removeProperty("opacity");
    }
  }
  let S = { onPointerDown: g, onPointerUp: _ };
  return a && l && (S.onMouseEnter = y, n.stacked || (S.onMouseLeave = m)), u && (S.onClick = (w) => {
    h && h(w), o.canCloseOnClick && c(!0);
  }), { playToast: m, pauseToast: y, isRunning: e, preventExitTransition: i, toastRef: s, eventHandlers: S };
}
var Gp = typeof window < "u" ? Gf : xt, Ba = ({ theme: n, type: e, isLoading: t, ...i }) => he.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: n === "colored" ? "currentColor" : `var(--toastify-icon-color-${e})`, ...i });
function Up(n) {
  return he.createElement(Ba, { ...n }, he.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}
function Bp(n) {
  return he.createElement(Ba, { ...n }, he.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}
function zp(n) {
  return he.createElement(Ba, { ...n }, he.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}
function Wp(n) {
  return he.createElement(Ba, { ...n }, he.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}
function Yp() {
  return he.createElement("div", { className: "Toastify__spinner" });
}
var Rc = { info: Bp, warning: Up, success: zp, error: Wp, spinner: Yp }, $p = (n) => n in Rc;
function jp({ theme: n, type: e, isLoading: t, icon: i }) {
  let r = null, s = { theme: n, type: e };
  return i === !1 || (ti(i) ? r = i({ ...s, isLoading: t }) : Na(i) ? r = _h(i, s) : t ? r = Rc.spinner() : $p(e) && (r = Rc[e](s))), r;
}
var Vp = (n) => {
  let { isRunning: e, preventExitTransition: t, toastRef: i, eventHandlers: r, playToast: s } = Np(n), { closeButton: o, children: a, autoClose: l, onClick: c, type: h, hideProgressBar: u, closeToast: d, transition: f, position: g, className: _, style: m, progressClassName: y, updateId: p, role: E, progress: x, rtl: v, toastId: S, deleteToast: w, isIn: b, isLoading: P, closeOnClick: O, theme: N, ariaLabel: k } = n, D = ji("Toastify__toast", `Toastify__toast-theme--${N}`, `Toastify__toast--${h}`, { "Toastify__toast--rtl": v }, { "Toastify__toast--close-on-click": O }), U = ti(_) ? _({ rtl: v, position: g, type: h, defaultClassName: D }) : ji(D, _), X = jp(n), I = !!x || !l, F = { closeToast: d, type: h, theme: N }, B = null;
  return o === !1 || (ti(o) ? B = o(F) : Na(o) ? B = _h(o, F) : B = Ep(F)), he.createElement(f, { isIn: b, done: w, position: g, preventExitTransition: t, nodeRef: i, playToast: s }, he.createElement("div", { id: S, tabIndex: 0, onClick: c, "data-in": b, className: U, ...r, style: m, ref: i, ...b && { role: E, "aria-label": k } }, X != null && he.createElement("div", { className: ji("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !P }) }, X), Bf(a, n, !e), B, !n.customProgressBar && he.createElement(Tp, { ...p && !I ? { key: `p-${p}` } : {}, rtl: v, theme: N, delay: l, isRunning: e, isIn: b, closeToast: d, hide: u, type: h, className: y, controlledProgress: I, progress: x || 0 })));
}, Xp = (n, e = !1) => ({ enter: `Toastify--animate Toastify__${n}-enter`, exit: `Toastify--animate Toastify__${n}-exit`, appendPosition: e }), Hp = vp(Xp("bounce", !0)), Kp = { position: "top-right", transition: Hp, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: "touch", draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light", "aria-label": "Notifications Alt+T", hotKeys: (n) => n.altKey && n.code === "KeyT" };
function Zp(n) {
  let e = { ...Kp, ...n }, t = n.stacked, [i, r] = st(!0), s = ei(null), { getToastToRender: o, isToastActive: a, count: l } = kp(e), { className: c, style: h, rtl: u, containerId: d, hotKeys: f } = e;
  function g(m) {
    let y = ji("Toastify__toast-container", `Toastify__toast-container--${m}`, { "Toastify__toast-container--rtl": u });
    return ti(c) ? c({ position: m, rtl: u, defaultClassName: y }) : ji(y, wc(c));
  }
  function _() {
    t && (r(!0), we.play());
  }
  return Gp(() => {
    var m;
    if (t) {
      let y = s.current.querySelectorAll('[data-in="true"]'), p = 12, E = (m = e.position) == null ? void 0 : m.includes("top"), x = 0, v = 0;
      Array.from(y).reverse().forEach((S, w) => {
        let b = S;
        b.classList.add("Toastify__toast--stacked"), w > 0 && (b.dataset.collapsed = `${i}`), b.dataset.pos || (b.dataset.pos = E ? "top" : "bot");
        let P = x * (i ? 0.2 : 1) + (i ? 0 : p * w);
        b.style.setProperty("--y", `${E ? P : P * -1}px`), b.style.setProperty("--g", `${p}`), b.style.setProperty("--s", `${1 - (i ? v : 0)}`), x += b.offsetHeight, v += 0.025;
      });
    }
  }, [i, l, t]), xt(() => {
    function m(y) {
      var p;
      let E = s.current;
      f(y) && ((p = E.querySelector('[tabIndex="0"]')) == null || p.focus(), r(!1), we.pause()), y.key === "Escape" && (document.activeElement === E || E != null && E.contains(document.activeElement)) && (r(!0), we.play());
    }
    return document.addEventListener("keydown", m), () => {
      document.removeEventListener("keydown", m);
    };
  }, [f]), he.createElement("section", { ref: s, className: "Toastify", id: d, onMouseEnter: () => {
    t && (r(!1), we.pause());
  }, onMouseLeave: _, "aria-live": "polite", "aria-atomic": "false", "aria-relevant": "additions text", "aria-label": e["aria-label"] }, o((m, y) => {
    let p = y.length ? { ...h } : { ...h, pointerEvents: "none" };
    return he.createElement("div", { tabIndex: -1, className: g(m), "data-stacked": t, style: p, key: `c-${m}` }, y.map(({ content: E, props: x }) => he.createElement(Vp, { ...x, stacked: t, collapseAll: _, isIn: a(x.toastId, x.containerId), key: `t-${x.key}` }, E)));
  }));
}
const Pt = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, $r = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
}, ie = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
class so {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function qp(n, e, t) {
  let i, r;
  t = t || Kn;
  let s = 0, o = n.length, a = !1;
  for (; s < o; )
    i = s + (o - s >> 1), r = +t(n[i], e), r < 0 ? s = i + 1 : (o = i, a = !r);
  return a ? s : ~s;
}
function Kn(n, e) {
  return n > e ? 1 : n < e ? -1 : 0;
}
function Jp(n, e) {
  return n < e ? 1 : n > e ? -1 : 0;
}
function ph(n, e, t) {
  if (n[0] <= e)
    return 0;
  const i = n.length;
  if (e <= n[i - 1])
    return i - 1;
  if (typeof t == "function") {
    for (let r = 1; r < i; ++r) {
      const s = n[r];
      if (s === e)
        return r;
      if (s < e)
        return t(e, n[r - 1], s) > 0 ? r - 1 : r;
    }
    return i - 1;
  }
  if (t > 0) {
    for (let r = 1; r < i; ++r)
      if (n[r] < e)
        return r - 1;
    return i - 1;
  }
  if (t < 0) {
    for (let r = 1; r < i; ++r)
      if (n[r] <= e)
        return r;
    return i - 1;
  }
  for (let r = 1; r < i; ++r) {
    if (n[r] == e)
      return r;
    if (n[r] < e)
      return n[r - 1] - e < e - n[r] ? r - 1 : r;
  }
  return i - 1;
}
function Qp(n, e, t) {
  for (; e < t; ) {
    const i = n[e];
    n[e] = n[t], n[t] = i, ++e, --t;
  }
}
function wn(n, e) {
  const t = Array.isArray(e) ? e : [e], i = t.length;
  for (let r = 0; r < i; r++)
    n[n.length] = t[r];
}
function oi(n, e) {
  const t = n.length;
  if (t !== e.length)
    return !1;
  for (let i = 0; i < t; i++)
    if (n[i] !== e[i])
      return !1;
  return !0;
}
function ey(n, e, t) {
  const i = e || Kn;
  return n.every(function(r, s) {
    if (s === 0)
      return !0;
    const o = i(n[s - 1], r);
    return !(o > 0 || o === 0);
  });
}
function Ns() {
  return !0;
}
function za() {
  return !1;
}
function Gs() {
}
function Vf(n) {
  let e, t, i;
  return function() {
    const r = Array.prototype.slice.call(arguments);
    return (!t || this !== i || !oi(r, t)) && (i = this, t = r, e = n.apply(this, arguments)), e;
  };
}
function ty(n) {
  function e() {
    let t;
    try {
      t = n();
    } catch (i) {
      return Promise.reject(i);
    }
    return t instanceof Promise ? t : Promise.resolve(t);
  }
  return e();
}
function Qr(n) {
  for (const e in n)
    delete n[e];
}
function er(n) {
  let e;
  for (e in n)
    return !1;
  return !e;
}
class ai {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
class Wa extends so {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const i = this.listeners_ || (this.listeners_ = {}), r = i[e] || (i[e] = []);
    r.includes(t) || r.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", i = t ? e : e.type, r = this.listeners_ && this.listeners_[i];
    if (!r)
      return;
    const s = t ? new ai(e) : (
      /** @type {Event} */
      e
    );
    s.target || (s.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    i in o || (o[i] = 0, a[i] = 0), ++o[i];
    let l;
    for (let c = 0, h = r.length; c < h; ++c)
      if ("handleEvent" in r[c] ? l = /** @type {import("../events.js").ListenerObject} */
      r[c].handleEvent(s) : l = /** @type {import("../events.js").ListenerFunction} */
      r[c].call(this, s), l === !1 || s.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[i] === 0) {
      let c = a[i];
      for (delete a[i]; c--; )
        this.removeEventListener(i, Gs);
      delete o[i];
    }
    return l;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && Qr(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    if (!this.listeners_)
      return;
    const i = this.listeners_[e];
    if (!i)
      return;
    const r = i.indexOf(t);
    r !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (i[r] = Gs, ++this.pendingRemovals_[e]) : (i.splice(r, 1), i.length === 0 && delete this.listeners_[e]));
  }
}
function ce(n, e, t, i, r) {
  if (r) {
    const o = t;
    t = function(a) {
      return n.removeEventListener(e, t), o.call(i ?? this, a);
    };
  } else i && i !== n && (t = t.bind(i));
  const s = {
    target: n,
    type: e,
    listener: t
  };
  return n.addEventListener(e, t), s;
}
function aa(n, e, t, i) {
  return ce(n, e, t, i, !0);
}
function Re(n) {
  n && n.target && (n.target.removeEventListener(n.type, n.listener), Qr(n));
}
class oo extends Wa {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(ie.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const i = e.length, r = new Array(i);
      for (let s = 0; s < i; ++s)
        r[s] = ce(this, e[s], t);
      return r;
    }
    return ce(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let i;
    if (Array.isArray(e)) {
      const r = e.length;
      i = new Array(r);
      for (let s = 0; s < r; ++s)
        i[s] = aa(this, e[s], t);
    } else
      i = aa(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = i, i;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const i = (
      /** @type {Object} */
      t.ol_key
    );
    if (i)
      Pi(i);
    else if (Array.isArray(e))
      for (let r = 0, s = e.length; r < s; ++r)
        this.removeEventListener(e[r], t);
    else
      this.removeEventListener(e, t);
  }
}
oo.prototype.on;
oo.prototype.once;
oo.prototype.un;
function Pi(n) {
  if (Array.isArray(n))
    for (let e = 0, t = n.length; e < t; ++e)
      Re(n[e]);
  else
    Re(
      /** @type {import("./events.js").EventsKey} */
      n
    );
}
function Q() {
  throw new Error("Unimplemented abstract method.");
}
let ny = 0;
function q(n) {
  return n.ol_uid || (n.ol_uid = String(++ny));
}
const iy = "10.6.1";
class ed extends ai {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, i) {
    super(e), this.key = t, this.oldValue = i;
  }
}
class Ft extends oo {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, q(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let i;
    i = `change:${e}`, this.hasListener(i) && this.dispatchEvent(new ed(i, e, t)), i = $r.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new ed(i, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, i) {
    const r = this.values_ || (this.values_ = {});
    if (i)
      r[e] = t;
    else {
      const s = r[e];
      r[e] = t, s !== t && this.notify(e, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const i in e)
      this.set(i, e[i], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const i = this.values_[e];
      delete this.values_[e], er(this.values_) && (this.values_ = null), t || this.notify(e, i);
    }
  }
}
const td = {
  LENGTH: "length"
};
class Mo extends ai {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, i) {
    super(e), this.element = t, this.index = i;
  }
}
class En extends Ft {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let i = 0, r = this.array_.length; i < r; ++i)
        this.assertUnique_(this.array_[i], i);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, i = e.length; t < i; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let i = 0, r = t.length; i < r; ++i)
      e(t[i], i, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(td.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new Mo(Pt.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let i = 0, r = t.length; i < r; ++i)
      if (t[i] === e)
        return this.removeAt(i);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Mo(Pt.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const i = this.getLength();
    if (e >= i) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const r = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Mo(Pt.REMOVE, r, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Mo(Pt.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(td.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let i = 0, r = this.array_.length; i < r; ++i)
      if (this.array_[i] === e && i !== t)
        throw new Error("Duplicate item added to a unique collection");
  }
}
function ge(n, e) {
  if (!n)
    throw new Error(e);
}
class Ri extends Ft {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new Ri(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const i = this.getStyle();
    return i && e.setStyle(i), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (Re(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = ce(
      e,
      ie.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? ry(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function ry(n) {
  if (typeof n == "function")
    return n;
  let e;
  return Array.isArray(n) ? e = n : (ge(
    typeof /** @type {?} */
    n.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    n
  ]), function() {
    return e;
  };
}
const Je = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function nd(n) {
  const e = St();
  for (let t = 0, i = n.length; t < i; ++t)
    As(e, n[t]);
  return e;
}
function sy(n, e, t) {
  const i = Math.min.apply(null, n), r = Math.min.apply(null, e), s = Math.max.apply(null, n), o = Math.max.apply(null, e);
  return ii(i, r, s, o, t);
}
function ni(n, e, t) {
  return t ? (t[0] = n[0] - e, t[1] = n[1] - e, t[2] = n[2] + e, t[3] = n[3] + e, t) : [
    n[0] - e,
    n[1] - e,
    n[2] + e,
    n[3] + e
  ];
}
function Xf(n, e) {
  return e ? (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e) : n.slice();
}
function sr(n, e, t) {
  let i, r;
  return e < n[0] ? i = n[0] - e : n[2] < e ? i = e - n[2] : i = 0, t < n[1] ? r = n[1] - t : n[3] < t ? r = t - n[3] : r = 0, i * i + r * r;
}
function jr(n, e) {
  return yh(n, e[0], e[1]);
}
function Mr(n, e) {
  return n[0] <= e[0] && e[2] <= n[2] && n[1] <= e[1] && e[3] <= n[3];
}
function yh(n, e, t) {
  return n[0] <= e && e <= n[2] && n[1] <= t && t <= n[3];
}
function Cc(n, e) {
  const t = n[0], i = n[1], r = n[2], s = n[3], o = e[0], a = e[1];
  let l = Je.UNKNOWN;
  return o < t ? l = l | Je.LEFT : o > r && (l = l | Je.RIGHT), a < i ? l = l | Je.BELOW : a > s && (l = l | Je.ABOVE), l === Je.UNKNOWN && (l = Je.INTERSECTING), l;
}
function St() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ii(n, e, t, i, r) {
  return r ? (r[0] = n, r[1] = e, r[2] = t, r[3] = i, r) : [n, e, t, i];
}
function es(n) {
  return ii(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
}
function xh(n, e) {
  const t = n[0], i = n[1];
  return ii(t, i, t, i, e);
}
function vh(n, e, t, i, r) {
  const s = es(r);
  return Kf(s, n, e, t, i);
}
function Vr(n, e) {
  return n[0] == e[0] && n[2] == e[2] && n[1] == e[1] && n[3] == e[3];
}
function Hf(n, e) {
  return e[0] < n[0] && (n[0] = e[0]), e[2] > n[2] && (n[2] = e[2]), e[1] < n[1] && (n[1] = e[1]), e[3] > n[3] && (n[3] = e[3]), n;
}
function As(n, e) {
  e[0] < n[0] && (n[0] = e[0]), e[0] > n[2] && (n[2] = e[0]), e[1] < n[1] && (n[1] = e[1]), e[1] > n[3] && (n[3] = e[1]);
}
function Kf(n, e, t, i, r) {
  for (; t < i; t += r)
    oy(n, e[t], e[t + 1]);
  return n;
}
function oy(n, e, t) {
  n[0] = Math.min(n[0], e), n[1] = Math.min(n[1], t), n[2] = Math.max(n[2], e), n[3] = Math.max(n[3], t);
}
function Zf(n, e) {
  let t;
  return t = e(Ya(n)), t || (t = e($a(n)), t) || (t = e(ja(n)), t) || (t = e(or(n)), t) ? t : !1;
}
function Pc(n) {
  let e = 0;
  return ao(n) || (e = Ee(n) * ut(n)), e;
}
function Ya(n) {
  return [n[0], n[1]];
}
function $a(n) {
  return [n[2], n[1]];
}
function nn(n) {
  return [(n[0] + n[2]) / 2, (n[1] + n[3]) / 2];
}
function ay(n, e) {
  let t;
  if (e === "bottom-left")
    t = Ya(n);
  else if (e === "bottom-right")
    t = $a(n);
  else if (e === "top-left")
    t = or(n);
  else if (e === "top-right")
    t = ja(n);
  else
    throw new Error("Invalid corner");
  return t;
}
function Ic(n, e, t, i, r) {
  const [s, o, a, l, c, h, u, d] = qf(
    n,
    e,
    t,
    i
  );
  return ii(
    Math.min(s, a, c, u),
    Math.min(o, l, h, d),
    Math.max(s, a, c, u),
    Math.max(o, l, h, d),
    r
  );
}
function qf(n, e, t, i) {
  const r = e * i[0] / 2, s = e * i[1] / 2, o = Math.cos(t), a = Math.sin(t), l = r * o, c = r * a, h = s * o, u = s * a, d = n[0], f = n[1];
  return [
    d - l + u,
    f - c - h,
    d - l - u,
    f - c + h,
    d + l - u,
    f + c + h,
    d + l + u,
    f + c - h,
    d - l + u,
    f - c - h
  ];
}
function ut(n) {
  return n[3] - n[1];
}
function Vi(n, e, t) {
  const i = t || St();
  return vt(n, e) ? (n[0] > e[0] ? i[0] = n[0] : i[0] = e[0], n[1] > e[1] ? i[1] = n[1] : i[1] = e[1], n[2] < e[2] ? i[2] = n[2] : i[2] = e[2], n[3] < e[3] ? i[3] = n[3] : i[3] = e[3]) : es(i), i;
}
function or(n) {
  return [n[0], n[3]];
}
function ja(n) {
  return [n[2], n[3]];
}
function Ee(n) {
  return n[2] - n[0];
}
function vt(n, e) {
  return n[0] <= e[2] && n[2] >= e[0] && n[1] <= e[3] && n[3] >= e[1];
}
function ao(n) {
  return n[2] < n[0] || n[3] < n[1];
}
function ly(n, e) {
  return e ? (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e) : n;
}
function cy(n, e, t) {
  let i = !1;
  const r = Cc(n, e), s = Cc(n, t);
  if (r === Je.INTERSECTING || s === Je.INTERSECTING)
    i = !0;
  else {
    const o = n[0], a = n[1], l = n[2], c = n[3], h = e[0], u = e[1], d = t[0], f = t[1], g = (f - u) / (d - h);
    let _, m;
    s & Je.ABOVE && !(r & Je.ABOVE) && (_ = d - (f - c) / g, i = _ >= o && _ <= l), !i && s & Je.RIGHT && !(r & Je.RIGHT) && (m = f - (d - l) * g, i = m >= a && m <= c), !i && s & Je.BELOW && !(r & Je.BELOW) && (_ = d - (f - a) / g, i = _ >= o && _ <= l), !i && s & Je.LEFT && !(r & Je.LEFT) && (m = f - (d - o) * g, i = m >= a && m <= c);
  }
  return i;
}
function Jf(n, e, t, i) {
  if (ao(n))
    return es(t);
  let r = [];
  r = [
    n[0],
    n[1],
    n[2],
    n[1],
    n[2],
    n[3],
    n[0],
    n[3]
  ], e(r, r, 2);
  const s = [], o = [];
  for (let a = 0, l = r.length; a < l; a += 2)
    s.push(r[a]), o.push(r[a + 1]);
  return sy(s, o, t);
}
function Qf(n, e) {
  const t = e.getExtent(), i = nn(n);
  if (e.canWrapX() && (i[0] < t[0] || i[0] >= t[2])) {
    const r = Ee(t), o = Math.floor(
      (i[0] - t[0]) / r
    ) * r;
    n[0] -= o, n[2] -= o;
  }
  return n;
}
function eg(n, e, t) {
  if (e.canWrapX()) {
    const i = e.getExtent();
    if (!isFinite(n[0]) || !isFinite(n[2]))
      return [[i[0], n[1], i[2], n[3]]];
    Qf(n, e);
    const r = Ee(i);
    if (Ee(n) > r && !t)
      return [[i[0], n[1], i[2], n[3]]];
    if (n[0] < i[0])
      return [
        [n[0] + r, n[1], i[2], n[3]],
        [i[0], n[1], n[2], n[3]]
      ];
    if (n[2] > i[2])
      return [
        [n[0], n[1], i[2], n[3]],
        [i[0], n[1], n[2] - r, n[3]]
      ];
  }
  return [n];
}
function De(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function hy(n, e, t, i, r, s) {
  const o = r - t, a = s - i;
  if (o !== 0 || a !== 0) {
    const l = ((n - t) * o + (e - i) * a) / (o * o + a * a);
    l > 1 ? (t = r, i = s) : l > 0 && (t += o * l, i += a * l);
  }
  return Xi(n, e, t, i);
}
function Xi(n, e, t, i) {
  const r = t - n, s = i - e;
  return r * r + s * s;
}
function uy(n) {
  const e = n.length;
  for (let i = 0; i < e; i++) {
    let r = i, s = Math.abs(n[i][i]);
    for (let a = i + 1; a < e; a++) {
      const l = Math.abs(n[a][i]);
      l > s && (s = l, r = a);
    }
    if (s === 0)
      return null;
    const o = n[r];
    n[r] = n[i], n[i] = o;
    for (let a = i + 1; a < e; a++) {
      const l = -n[a][i] / n[i][i];
      for (let c = i; c < e + 1; c++)
        i == c ? n[a][c] = 0 : n[a][c] += l * n[i][c];
    }
  }
  const t = new Array(e);
  for (let i = e - 1; i >= 0; i--) {
    t[i] = n[i][e] / n[i][i];
    for (let r = i - 1; r >= 0; r--)
      n[r][e] -= n[r][i] * t[i];
  }
  return t;
}
function id(n) {
  return n * 180 / Math.PI;
}
function wi(n) {
  return n * Math.PI / 180;
}
function Hi(n, e) {
  const t = n % e;
  return t * e < 0 ? t + e : t;
}
function Nt(n, e, t) {
  return n + t * (e - n);
}
function lo(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
function rd(n, e) {
  return Math.round(lo(n, e));
}
function Do(n, e) {
  return Math.floor(lo(n, e));
}
function Fo(n, e) {
  return Math.ceil(lo(n, e));
}
function Ac(n, e, t) {
  if (n >= e && n < t)
    return n;
  const i = t - e;
  return ((n - e) % i + i) % i + e;
}
const dy = 63710088e-1;
function la(n, e, t) {
  t = t || dy;
  const i = wi(n[1]), r = wi(e[1]), s = (r - i) / 2, o = wi(e[0] - n[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(r);
  return 2 * t * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function tg(...n) {
  console.warn(...n);
}
function ng(n, e) {
  const t = ("" + n).split("."), i = ("" + e).split(".");
  for (let r = 0; r < Math.max(t.length, i.length); r++) {
    const s = parseInt(t[r] || "0", 10), o = parseInt(i[r] || "0", 10);
    if (s > o)
      return 1;
    if (o > s)
      return -1;
  }
  return 0;
}
function ig(n, e) {
  return n[0] += +e[0], n[1] += +e[1], n;
}
function ca(n, e) {
  let t = !0;
  for (let i = n.length - 1; i >= 0; --i)
    if (n[i] != e[i]) {
      t = !1;
      break;
    }
  return t;
}
function Eh(n, e) {
  const t = Math.cos(e), i = Math.sin(e), r = n[0] * t - n[1] * i, s = n[1] * t + n[0] * i;
  return n[0] = r, n[1] = s, n;
}
function rg(n, e) {
  return n[0] *= e, n[1] *= e, n;
}
function sg(n, e) {
  if (e.canWrapX()) {
    const t = Ee(e.getExtent()), i = fy(n, e, t);
    i && (n[0] -= i * t);
  }
  return n;
}
function fy(n, e, t) {
  const i = e.getExtent();
  let r = 0;
  return e.canWrapX() && (n[0] < i[0] || n[0] > i[2]) && (t = t || Ee(i), r = Math.floor(
    (n[0] - i[0]) / t
  )), r;
}
const Xr = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class Th {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Xr[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const co = 6378137, Dr = Math.PI * co, gy = [-Dr, -Dr, Dr, Dr], my = [-180, -85, 180, 85], ko = co * Math.log(Math.tan(Math.PI / 2));
class pr extends Th {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: gy,
      global: !0,
      worldExtent: my,
      getPointResolution: function(t, i) {
        return t / Math.cosh(i[1] / co);
      }
    });
  }
}
const sd = [
  new pr("EPSG:3857"),
  new pr("EPSG:102100"),
  new pr("EPSG:102113"),
  new pr("EPSG:900913"),
  new pr("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new pr("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function _y(n, e, t, i) {
  const r = n.length;
  t = t > 1 ? t : 2, i = i ?? t, e === void 0 && (t > 2 ? e = n.slice() : e = new Array(r));
  for (let s = 0; s < r; s += i) {
    e[s] = Dr * n[s] / 180;
    let o = co * Math.log(Math.tan(Math.PI * (+n[s + 1] + 90) / 360));
    o > ko ? o = ko : o < -ko && (o = -ko), e[s + 1] = o;
  }
  return e;
}
function py(n, e, t, i) {
  const r = n.length;
  t = t > 1 ? t : 2, i = i ?? t, e === void 0 && (t > 2 ? e = n.slice() : e = new Array(r));
  for (let s = 0; s < r; s += i)
    e[s] = 180 * n[s] / Dr, e[s + 1] = 360 * Math.atan(Math.exp(n[s + 1] / co)) / Math.PI - 90;
  return e;
}
const yy = 6378137, od = [-180, -90, 180, 90], xy = Math.PI * yy / 180;
class Di extends Th {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: od,
      axisOrientation: t,
      global: !0,
      metersPerUnit: xy,
      worldExtent: od
    });
  }
}
const ad = [
  new Di("CRS:84"),
  new Di("EPSG:4326", "neu"),
  new Di("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Di("urn:ogc:def:crs:OGC:2:84"),
  new Di("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Di("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Di("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Lc = {};
function vy(n) {
  return Lc[n] || Lc[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Ey(n, e) {
  Lc[n] = e;
}
let Nr = {};
function Us(n, e, t) {
  const i = n.getCode(), r = e.getCode();
  i in Nr || (Nr[i] = {}), Nr[i][r] = t;
}
function Ml(n, e) {
  return n in Nr && e in Nr[n] ? Nr[n][e] : null;
}
const ha = 0.9996, Vt = 669438e-8, Va = Vt * Vt, Xa = Va * Vt, Ui = Vt / (1 - Vt), ld = Math.sqrt(1 - Vt), Hr = (1 - ld) / (1 + ld), og = Hr * Hr, wh = og * Hr, Sh = wh * Hr, ag = Sh * Hr, lg = 1 - Vt / 4 - 3 * Va / 64 - 5 * Xa / 256, Ty = 3 * Vt / 8 + 3 * Va / 32 + 45 * Xa / 1024, wy = 15 * Va / 256 + 45 * Xa / 1024, Sy = 35 * Xa / 3072, by = 3 / 2 * Hr - 27 / 32 * wh + 269 / 512 * ag, Ry = 21 / 16 * og - 55 / 32 * Sh, Cy = 151 / 96 * wh - 417 / 128 * ag, Py = 1097 / 512 * Sh, ua = 6378137;
function Iy(n, e, t) {
  const i = n - 5e5, o = (t.north ? e : e - 1e7) / ha / (ua * lg), a = o + by * Math.sin(2 * o) + Ry * Math.sin(4 * o) + Cy * Math.sin(6 * o) + Py * Math.sin(8 * o), l = Math.sin(a), c = l * l, h = Math.cos(a), u = l / h, d = u * u, f = d * d, g = 1 - Vt * c, _ = Math.sqrt(1 - Vt * c), m = ua / _, y = (1 - Vt) / g, p = Ui * h ** 2, E = p * p, x = i / (m * ha), v = x * x, S = v * x, w = S * x, b = w * x, P = b * x, O = a - u / y * (v / 2 - w / 24 * (5 + 3 * d + 10 * p - 4 * E - 9 * Ui)) + P / 720 * (61 + 90 * d + 298 * p + 45 * f - 252 * Ui - 3 * E);
  let N = (x - S / 6 * (1 + 2 * d + p) + b / 120 * (5 - 2 * p + 28 * d - 3 * E + 8 * Ui + 24 * f)) / h;
  return N = Ac(
    N + wi(cg(t.number)),
    -Math.PI,
    Math.PI
  ), [id(N), id(O)];
}
const cd = -80, hd = 84, Ay = -180, Ly = 180;
function Oy(n, e, t) {
  n = Ac(n, Ay, Ly), e < cd ? e = cd : e > hd && (e = hd);
  const i = wi(e), r = Math.sin(i), s = Math.cos(i), o = r / s, a = o * o, l = a * a, c = wi(n), h = cg(t.number), u = wi(h), d = ua / Math.sqrt(1 - Vt * r ** 2), f = Ui * s ** 2, g = s * Ac(c - u, -Math.PI, Math.PI), _ = g * g, m = _ * g, y = m * g, p = y * g, E = p * g, x = ua * (lg * i - Ty * Math.sin(2 * i) + wy * Math.sin(4 * i) - Sy * Math.sin(6 * i)), v = ha * d * (g + m / 6 * (1 - a + f) + p / 120 * (5 - 18 * a + l + 72 * f - 58 * Ui)) + 5e5;
  let S = ha * (x + d * o * (_ / 2 + y / 24 * (5 - a + 9 * f + 4 * f ** 2) + E / 720 * (61 - 58 * a + l + 600 * f - 330 * Ui)));
  return t.north || (S += 1e7), [v, S];
}
function cg(n) {
  return (n - 1) * 6 - 180 + 3;
}
const My = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function hg(n) {
  let e = 0;
  for (const r of My) {
    const s = n.match(r);
    if (s) {
      e = parseInt(s[1]);
      break;
    }
  }
  if (!e)
    return null;
  let t = 0, i = !1;
  return e > 32700 && e < 32761 ? t = e - 32700 : e > 32600 && e < 32661 && (i = !0, t = e - 32600), t ? { number: t, north: i } : null;
}
function ud(n, e) {
  return function(t, i, r, s) {
    const o = t.length;
    r = r > 1 ? r : 2, s = s ?? r, i || (r > 2 ? i = t.slice() : i = new Array(o));
    for (let a = 0; a < o; a += s) {
      const l = t[a], c = t[a + 1], h = n(l, c, e);
      i[a] = h[0], i[a + 1] = h[1];
    }
    return i;
  };
}
function Dy(n) {
  return hg(n) ? new Th({ code: n, units: "m" }) : null;
}
function Fy(n) {
  const e = hg(n.getCode());
  return e ? {
    forward: ud(Oy, e),
    inverse: ud(Iy, e)
  } : null;
}
const ky = [Fy], Ny = [Dy];
let Oc = !0;
function ug(n) {
  Oc = !1;
}
function bh(n, e) {
  if (e !== void 0) {
    for (let t = 0, i = n.length; t < i; ++t)
      e[t] = n[t];
    e = e;
  } else
    e = n.slice();
  return e;
}
function Mc(n) {
  Ey(n.getCode(), n), Us(n, n, bh);
}
function Gy(n) {
  n.forEach(Mc);
}
function Ie(n) {
  if (typeof n != "string")
    return n;
  const e = vy(n);
  if (e)
    return e;
  for (const t of Ny) {
    const i = t(n);
    if (i)
      return i;
  }
  return null;
}
function da(n, e, t, i) {
  n = Ie(n);
  let r;
  const s = n.getPointResolutionFunc();
  if (s) {
    if (r = s(e, t), i && i !== n.getUnits()) {
      const o = n.getMetersPerUnit();
      o && (r = r * o / Xr[i]);
    }
  } else {
    const o = n.getUnits();
    if (o == "degrees" && !i || i == "degrees")
      r = e;
    else {
      const a = Ha(
        n,
        Ie("EPSG:4326")
      );
      if (!a && o !== "degrees")
        r = e * n.getMetersPerUnit();
      else {
        let c = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        c = a(c, c, 2);
        const h = la(c.slice(0, 2), c.slice(2, 4)), u = la(c.slice(4, 6), c.slice(6, 8));
        r = (h + u) / 2;
      }
      const l = i ? Xr[i] : n.getMetersPerUnit();
      l !== void 0 && (r /= l);
    }
  }
  return r;
}
function dd(n) {
  Gy(n), n.forEach(function(e) {
    n.forEach(function(t) {
      e !== t && Us(e, t, bh);
    });
  });
}
function Uy(n, e, t, i) {
  n.forEach(function(r) {
    e.forEach(function(s) {
      Us(r, s, t), Us(s, r, i);
    });
  });
}
function Rh(n, e) {
  return n ? typeof n == "string" ? Ie(n) : (
    /** @type {Projection} */
    n
  ) : Ie(e);
}
function By(n) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function(e, t, i, r) {
      const s = e.length;
      i = i !== void 0 ? i : 2, r = r ?? i, t = t !== void 0 ? t : new Array(s);
      for (let o = 0; o < s; o += r) {
        const a = n(e.slice(o, o + i)), l = a.length;
        for (let c = 0, h = r; c < h; ++c)
          t[o + c] = c >= l ? e[o + c] : a[c];
      }
      return t;
    }
  );
}
function zy(n, e) {
  return ug(), rn(
    n,
    "EPSG:4326",
    "EPSG:3857"
  );
}
function Qo(n, e) {
  if (n === e)
    return !0;
  const t = n.getUnits() === e.getUnits();
  return (n.getCode() === e.getCode() || Ha(n, e) === bh) && t;
}
function Ha(n, e) {
  const t = n.getCode(), i = e.getCode();
  let r = Ml(t, i);
  if (r)
    return r;
  let s = null, o = null;
  for (const l of ky)
    s || (s = l(n)), o || (o = l(e));
  if (!s && !o)
    return null;
  const a = "EPSG:4326";
  if (o)
    if (s)
      r = Dl(
        s.inverse,
        o.forward
      );
    else {
      const l = Ml(t, a);
      l && (r = Dl(
        l,
        o.forward
      ));
    }
  else {
    const l = Ml(a, i);
    l && (r = Dl(
      s.inverse,
      l
    ));
  }
  return r && (Mc(n), Mc(e), Us(n, e, r)), r;
}
function Dl(n, e) {
  return function(t, i, r, s) {
    return i = n(t, i, r, s), e(i, i, r, s);
  };
}
function Kr(n, e) {
  const t = Ie(n), i = Ie(e);
  return Ha(t, i);
}
function rn(n, e, t) {
  const i = Kr(e, t);
  if (!i) {
    const r = Ie(e).getCode(), s = Ie(t).getCode();
    throw new Error(
      `No transform available between ${r} and ${s}`
    );
  }
  return i(n, void 0, n.length);
}
function Wy(n, e, t, i) {
  const r = Kr(e, t);
  return Jf(n, r, void 0);
}
function Dc(n, e) {
  return n;
}
function Bn(n, e) {
  return Oc && !ca(n, [0, 0]) && n[0] >= -180 && n[0] <= 180 && n[1] >= -90 && n[1] <= 90 && (Oc = !1, tg(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), n;
}
function dg(n, e) {
  return n;
}
function yi(n, e) {
  return n;
}
function Yy() {
  dd(sd), dd(ad), Uy(
    ad,
    sd,
    _y,
    py
  );
}
Yy();
const $y = new Array(6);
function Ke() {
  return [1, 0, 0, 1, 0, 0];
}
function Ch(n, e) {
  const t = n[0], i = n[1], r = n[2], s = n[3], o = n[4], a = n[5], l = e[0], c = e[1], h = e[2], u = e[3], d = e[4], f = e[5];
  return n[0] = t * l + r * c, n[1] = i * l + s * c, n[2] = t * h + r * u, n[3] = i * h + s * u, n[4] = t * d + r * f + o, n[5] = i * d + s * f + a, n;
}
function jy(n, e, t, i, r, s, o) {
  return n[0] = e, n[1] = t, n[2] = i, n[3] = r, n[4] = s, n[5] = o, n;
}
function fg(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n;
}
function Ue(n, e) {
  const t = e[0], i = e[1];
  return e[0] = n[0] * t + n[2] * i + n[4], e[1] = n[1] * t + n[3] * i + n[5], e;
}
function Vy(n, e, t) {
  return Ch(n, jy($y, 1, 0, 0, 1, e, t));
}
function sn(n, e, t, i, r, s, o, a) {
  const l = Math.sin(s), c = Math.cos(s);
  return n[0] = i * c, n[1] = r * l, n[2] = -i * l, n[3] = r * c, n[4] = o * i * c - a * i * l + e, n[5] = o * r * l + a * r * c + t, n;
}
function Bs(n, e) {
  const t = Xy(e);
  ge(t !== 0, "Transformation matrix cannot be inverted");
  const i = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5];
  return n[0] = o / t, n[1] = -r / t, n[2] = -s / t, n[3] = i / t, n[4] = (s * l - o * a) / t, n[5] = -(i * l - r * a) / t, n;
}
function Xy(n) {
  return n[0] * n[3] - n[1] * n[2];
}
const Hy = [1e5, 1e5, 1e5, 1e5, 2, 2];
function Ky(n) {
  return "matrix(" + n.join(", ") + ")";
}
function fd(n) {
  return n.substring(7, n.length - 1).split(",").map(parseFloat);
}
function Zy(n, e) {
  const t = fd(n), i = fd(e);
  for (let r = 0; r < 6; ++r)
    if (Math.round((t[r] - i[r]) * Hy[r]) !== 0)
      return !1;
  return !0;
}
function Sn(n, e, t, i, r, s, o) {
  s = s || [], o = o || 2;
  let a = 0;
  for (let l = e; l < t; l += i) {
    const c = n[l], h = n[l + 1];
    s[a++] = r[0] * c + r[2] * h + r[4], s[a++] = r[1] * c + r[3] * h + r[5];
    for (let u = 2; u < o; u++)
      s[a++] = n[l + u];
  }
  return s && s.length != a && (s.length = a), s;
}
function gg(n, e, t, i, r, s, o) {
  o = o || [];
  const a = Math.cos(r), l = Math.sin(r), c = s[0], h = s[1];
  let u = 0;
  for (let d = e; d < t; d += i) {
    const f = n[d] - c, g = n[d + 1] - h;
    o[u++] = c + f * a - g * l, o[u++] = h + f * l + g * a;
    for (let _ = d + 2; _ < d + i; ++_)
      o[u++] = n[_];
  }
  return o && o.length != u && (o.length = u), o;
}
function qy(n, e, t, i, r, s, o, a) {
  a = a || [];
  const l = o[0], c = o[1];
  let h = 0;
  for (let u = e; u < t; u += i) {
    const d = n[u] - l, f = n[u + 1] - c;
    a[h++] = l + r * d, a[h++] = c + s * f;
    for (let g = u + 2; g < u + i; ++g)
      a[h++] = n[g];
  }
  return a && a.length != h && (a.length = h), a;
}
function Jy(n, e, t, i, r, s, o) {
  o = o || [];
  let a = 0;
  for (let l = e; l < t; l += i) {
    o[a++] = n[l] + r, o[a++] = n[l + 1] + s;
    for (let c = l + 2; c < l + i; ++c)
      o[a++] = n[c];
  }
  return o && o.length != a && (o.length = a), o;
}
const gd = Ke(), Qy = [NaN, NaN];
class mg extends Ft {
  constructor() {
    super(), this.extent_ = St(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = Vf(
      (e, t, i) => {
        if (!i)
          return this.getSimplifiedGeometry(t);
        const r = this.clone();
        return r.applyTransform(i), r.getSimplifiedGeometry(t);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Q();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, r) {
    return Q();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return this.closestPointXY(e, t, Qy, Number.MIN_VALUE) === 0;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Q();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && es(t), this.extentRevision_ = this.getRevision();
    }
    return ly(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    Q();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    Q();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return Q();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Q();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    Q();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return Q();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    Q();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const i = Ie(e), r = i.getUnits() == "tile-pixels" ? function(s, o, a) {
      const l = i.getExtent(), c = i.getWorldExtent(), h = ut(c) / ut(l);
      sn(
        gd,
        c[0],
        c[3],
        h,
        -h,
        0,
        0,
        0
      );
      const u = Sn(
        s,
        0,
        s.length,
        a,
        gd,
        o
      ), d = Kr(i, t);
      return d ? d(u, u, a) : u;
    } : Kr(i, t);
    return this.applyTransform(r), this;
  }
}
class ar extends mg {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    return vh(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Q();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = md(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    Q();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, i) {
    let r;
    if (e)
      r = md(e);
    else {
      for (let s = 0; s < i; ++s) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array<unknown>} */
        t[0];
      }
      r = t.length, e = lr(r);
    }
    this.layout = e, this.stride = r;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(e) {
    this.flatCoordinates && (e(
      this.flatCoordinates,
      this.flatCoordinates,
      this.layout.startsWith("XYZ") ? 3 : 2,
      this.stride
    ), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const r = this.getStride();
      gg(
        i,
        0,
        i.length,
        r,
        e,
        t,
        i
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(e, t, i) {
    t === void 0 && (t = e), i || (i = nn(this.getExtent()));
    const r = this.getFlatCoordinates();
    if (r) {
      const s = this.getStride();
      qy(
        r,
        0,
        r.length,
        s,
        e,
        t,
        i,
        r
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const r = this.getStride();
      Jy(
        i,
        0,
        i.length,
        r,
        e,
        t,
        i
      ), this.changed();
    }
  }
}
function lr(n) {
  let e;
  return n == 2 ? e = "XY" : n == 3 ? e = "XYZ" : n == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function md(n) {
  let e;
  return n == "XY" ? e = 2 : n == "XYZ" || n == "XYM" ? e = 3 : n == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function e0(n, e, t) {
  const i = n.getFlatCoordinates();
  if (!i)
    return null;
  const r = n.getStride();
  return Sn(
    i,
    0,
    i.length,
    r,
    e,
    t
  );
}
function _g(n, e, t, i) {
  let r = 0;
  const s = n[t - i], o = n[t - i + 1];
  let a = 0, l = 0;
  for (; e < t; e += i) {
    const c = n[e] - s, h = n[e + 1] - o;
    r += l * c - a * h, a = c, l = h;
  }
  return r / 2;
}
function pg(n, e, t, i) {
  let r = 0;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r += _g(n, e, a, i), e = a;
  }
  return r;
}
function t0(n, e, t, i) {
  let r = 0;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r += pg(n, e, a, i), e = a[a.length - 1];
  }
  return r;
}
function _d(n, e, t, i, r, s, o) {
  const a = n[e], l = n[e + 1], c = n[t] - a, h = n[t + 1] - l;
  let u;
  if (c === 0 && h === 0)
    u = e;
  else {
    const d = ((r - a) * c + (s - l) * h) / (c * c + h * h);
    if (d > 1)
      u = t;
    else if (d > 0) {
      for (let f = 0; f < i; ++f)
        o[f] = Nt(
          n[e + f],
          n[t + f],
          d
        );
      o.length = i;
      return;
    } else
      u = e;
  }
  for (let d = 0; d < i; ++d)
    o[d] = n[u + d];
  o.length = i;
}
function Ph(n, e, t, i, r) {
  let s = n[e], o = n[e + 1];
  for (e += i; e < t; e += i) {
    const a = n[e], l = n[e + 1], c = Xi(s, o, a, l);
    c > r && (r = c), s = a, o = l;
  }
  return r;
}
function Ih(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r = Ph(n, e, a, i, r), e = a;
  }
  return r;
}
function n0(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r = Ih(n, e, a, i, r), e = a[a.length - 1];
  }
  return r;
}
function Ah(n, e, t, i, r, s, o, a, l, c, h) {
  if (e == t)
    return c;
  let u, d;
  if (r === 0) {
    if (d = Xi(
      o,
      a,
      n[e],
      n[e + 1]
    ), d < c) {
      for (u = 0; u < i; ++u)
        l[u] = n[e + u];
      return l.length = i, d;
    }
    return c;
  }
  h = h || [NaN, NaN];
  let f = e + i;
  for (; f < t; )
    if (_d(
      n,
      f - i,
      f,
      i,
      o,
      a,
      h
    ), d = Xi(o, a, h[0], h[1]), d < c) {
      for (c = d, u = 0; u < i; ++u)
        l[u] = h[u];
      l.length = i, f += i;
    } else
      f += i * Math.max(
        (Math.sqrt(d) - Math.sqrt(c)) / r | 0,
        1
      );
  if (s && (_d(
    n,
    t - i,
    e,
    i,
    o,
    a,
    h
  ), d = Xi(o, a, h[0], h[1]), d < c)) {
    for (c = d, u = 0; u < i; ++u)
      l[u] = h[u];
    l.length = i;
  }
  return c;
}
function Lh(n, e, t, i, r, s, o, a, l, c, h) {
  h = h || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    c = Ah(
      n,
      e,
      f,
      i,
      r,
      s,
      o,
      a,
      l,
      c,
      h
    ), e = f;
  }
  return c;
}
function i0(n, e, t, i, r, s, o, a, l, c, h) {
  h = h || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    c = Lh(
      n,
      e,
      f,
      i,
      r,
      s,
      o,
      a,
      l,
      c,
      h
    ), e = f[f.length - 1];
  }
  return c;
}
function r0(n, e, t, i) {
  for (let r = 0, s = t.length; r < s; ++r)
    n[e++] = t[r];
  return e;
}
function Ka(n, e, t, i) {
  for (let r = 0, s = t.length; r < s; ++r) {
    const o = t[r];
    for (let a = 0; a < i; ++a)
      n[e++] = o[a];
  }
  return e;
}
function ho(n, e, t, i, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Ka(
      n,
      e,
      t[o],
      i
    );
    r[s++] = l, e = l;
  }
  return r.length = s, r;
}
function yg(n, e, t, i, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = ho(
      n,
      e,
      t[o],
      i,
      r[s]
    );
    l.length === 0 && (l[0] = e), r[s++] = l, e = l[l.length - 1];
  }
  return r.length = s, r;
}
function xi(n, e, t, i, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = e; o < t; o += i)
    r[s++] = n.slice(o, o + i);
  return r.length = s, r;
}
function zs(n, e, t, i, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r[s++] = xi(
      n,
      e,
      l,
      i,
      r[s]
    ), e = l;
  }
  return r.length = s, r;
}
function Fc(n, e, t, i, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r[s++] = l.length === 1 && l[0] === e ? [] : zs(
      n,
      e,
      l,
      i,
      r[s]
    ), e = l[l.length - 1];
  }
  return r.length = s, r;
}
function Za(n, e, t, i, r, s, o) {
  const a = (t - e) / i;
  if (a < 3) {
    for (; e < t; e += i)
      s[o++] = n[e], s[o++] = n[e + 1];
    return o;
  }
  const l = new Array(a);
  l[0] = 1, l[a - 1] = 1;
  const c = [e, t - i];
  let h = 0;
  for (; c.length > 0; ) {
    const u = c.pop(), d = c.pop();
    let f = 0;
    const g = n[d], _ = n[d + 1], m = n[u], y = n[u + 1];
    for (let p = d + i; p < u; p += i) {
      const E = n[p], x = n[p + 1], v = hy(E, x, g, _, m, y);
      v > f && (h = p, f = v);
    }
    f > r && (l[(h - e) / i] = 1, d + i < h && c.push(d, h), h + i < u && c.push(h, u));
  }
  for (let u = 0; u < a; ++u)
    l[u] && (s[o++] = n[e + u * i], s[o++] = n[e + u * i + 1]);
  return o;
}
function xg(n, e, t, i, r, s, o, a) {
  for (let l = 0, c = t.length; l < c; ++l) {
    const h = t[l];
    o = Za(
      n,
      e,
      h,
      i,
      r,
      s,
      o
    ), a.push(o), e = h;
  }
  return o;
}
function Ni(n, e) {
  return e * Math.round(n / e);
}
function s0(n, e, t, i, r, s, o) {
  if (e == t)
    return o;
  let a = Ni(n[e], r), l = Ni(n[e + 1], r);
  e += i, s[o++] = a, s[o++] = l;
  let c, h;
  do
    if (c = Ni(n[e], r), h = Ni(n[e + 1], r), e += i, e == t)
      return s[o++] = c, s[o++] = h, o;
  while (c == a && h == l);
  for (; e < t; ) {
    const u = Ni(n[e], r), d = Ni(n[e + 1], r);
    if (e += i, u == c && d == h)
      continue;
    const f = c - a, g = h - l, _ = u - a, m = d - l;
    if (f * m == g * _ && (f < 0 && _ < f || f == _ || f > 0 && _ > f) && (g < 0 && m < g || g == m || g > 0 && m > g)) {
      c = u, h = d;
      continue;
    }
    s[o++] = c, s[o++] = h, a = c, l = h, c = u, h = d;
  }
  return s[o++] = c, s[o++] = h, o;
}
function Oh(n, e, t, i, r, s, o, a) {
  for (let l = 0, c = t.length; l < c; ++l) {
    const h = t[l];
    o = s0(
      n,
      e,
      h,
      i,
      r,
      s,
      o
    ), a.push(o), e = h;
  }
  return o;
}
function o0(n, e, t, i, r, s, o, a) {
  for (let l = 0, c = t.length; l < c; ++l) {
    const h = t[l], u = [];
    o = Oh(
      n,
      e,
      h,
      i,
      r,
      s,
      o,
      u
    ), a.push(u), e = h[h.length - 1];
  }
  return o;
}
class Ws extends ar {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new Ws(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    return r < sr(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ph(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Ah(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      r
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return _g(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = Za(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Ws(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ka(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
class on extends ar {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new on(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    const s = this.flatCoordinates, o = Xi(
      e,
      t,
      s[0],
      s[1]
    );
    if (o < r) {
      const a = this.stride;
      for (let l = 0; l < a; ++l)
        i[l] = s[l];
      return i.length = a, o;
    }
    return r;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    return xh(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return yh(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = r0(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
function a0(n, e, t, i, r) {
  return !Zf(
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !Bi(
        n,
        e,
        t,
        i,
        o[0],
        o[1]
      );
    }
  );
}
function Bi(n, e, t, i, r, s) {
  let o = 0, a = n[t - i], l = n[t - i + 1];
  for (; e < t; e += i) {
    const c = n[e], h = n[e + 1];
    l <= s ? h > s && (c - a) * (s - l) - (r - a) * (h - l) > 0 && o++ : h <= s && (c - a) * (s - l) - (r - a) * (h - l) < 0 && o--, a = c, l = h;
  }
  return o !== 0;
}
function Mh(n, e, t, i, r, s) {
  if (t.length === 0 || !Bi(n, e, t[0], i, r, s))
    return !1;
  for (let o = 1, a = t.length; o < a; ++o)
    if (Bi(n, t[o - 1], t[o], i, r, s))
      return !1;
  return !0;
}
function l0(n, e, t, i, r, s) {
  if (t.length === 0)
    return !1;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    if (Mh(n, e, l, i, r, s))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function Dh(n, e, t, i, r, s, o) {
  let a, l, c, h, u, d, f;
  const g = r[s + 1], _ = [];
  for (let p = 0, E = t.length; p < E; ++p) {
    const x = t[p];
    for (h = n[x - i], d = n[x - i + 1], a = e; a < x; a += i)
      u = n[a], f = n[a + 1], (g <= d && f <= g || d <= g && g <= f) && (c = (g - d) / (f - d) * (u - h) + h, _.push(c)), h = u, d = f;
  }
  let m = NaN, y = -1 / 0;
  for (_.sort(Kn), h = _[0], a = 1, l = _.length; a < l; ++a) {
    u = _[a];
    const p = Math.abs(u - h);
    p > y && (c = (h + u) / 2, Mh(n, e, t, i, c, g) && (m = c, y = p)), h = u;
  }
  return isNaN(m) && (m = r[s]), o ? (o.push(m, g, y), o) : [m, g, y];
}
function vg(n, e, t, i, r) {
  let s = [];
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s = Dh(
      n,
      e,
      l,
      i,
      r,
      2 * o,
      s
    ), e = l[l.length - 1];
  }
  return s;
}
function Eg(n, e, t, i, r) {
  let s;
  for (e += i; e < t; e += i)
    if (s = r(
      n.slice(e - i, e),
      n.slice(e, e + i)
    ), s)
      return s;
  return !1;
}
function qa(n, e, t, i, r, s) {
  return s = s ?? Kf(St(), n, e, t, i), vt(r, s) ? s[0] >= r[0] && s[2] <= r[2] || s[1] >= r[1] && s[3] <= r[3] ? !0 : Eg(
    n,
    e,
    t,
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, a) {
      return cy(r, o, a);
    }
  ) : !1;
}
function c0(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    if (qa(n, e, t[s], i, r))
      return !0;
    e = t[s];
  }
  return !1;
}
function Tg(n, e, t, i, r) {
  return !!(qa(n, e, t, i, r) || Bi(
    n,
    e,
    t,
    i,
    r[0],
    r[1]
  ) || Bi(
    n,
    e,
    t,
    i,
    r[0],
    r[3]
  ) || Bi(
    n,
    e,
    t,
    i,
    r[2],
    r[1]
  ) || Bi(
    n,
    e,
    t,
    i,
    r[2],
    r[3]
  ));
}
function wg(n, e, t, i, r) {
  if (!Tg(n, e, t[0], i, r))
    return !1;
  if (t.length === 1)
    return !0;
  for (let s = 1, o = t.length; s < o; ++s)
    if (a0(
      n,
      t[s - 1],
      t[s],
      i,
      r
    ) && !qa(
      n,
      t[s - 1],
      t[s],
      i,
      r
    ))
      return !1;
  return !0;
}
function h0(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    if (wg(n, e, a, i, r))
      return !0;
    e = a[a.length - 1];
  }
  return !1;
}
function u0(n, e, t, i) {
  for (; e < t - i; ) {
    for (let r = 0; r < i; ++r) {
      const s = n[e + r];
      n[e + r] = n[t - i + r], n[t - i + r] = s;
    }
    e += i, t -= i;
  }
}
function Fh(n, e, t, i) {
  let r = 0, s = n[t - i], o = n[t - i + 1];
  for (; e < t; e += i) {
    const a = n[e], l = n[e + 1];
    r += (a - s) * (l + o), s = a, o = l;
  }
  return r === 0 ? void 0 : r > 0;
}
function kh(n, e, t, i, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s], l = Fh(
      n,
      e,
      a,
      i
    );
    if (s === 0) {
      if (r && l || !r && !l)
        return !1;
    } else if (r && !l || !r && l)
      return !1;
    e = a;
  }
  return !0;
}
function Sg(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    if (!kh(n, e, a, i, r))
      return !1;
    a.length && (e = a[a.length - 1]);
  }
  return !0;
}
function fa(n, e, t, i, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s], l = Fh(
      n,
      e,
      a,
      i
    );
    (s === 0 ? r && l || !r && !l : r && !l || !r && l) && u0(n, e, a, i), e = a;
  }
  return e;
}
function kc(n, e, t, i, r) {
  for (let s = 0, o = t.length; s < o; ++s)
    e = fa(
      n,
      e,
      t[s],
      i,
      r
    );
  return e;
}
function bg(n, e) {
  const t = [];
  let i = 0, r = 0, s;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o], c = Fh(n, i, l, 2);
    if (s === void 0 && (s = c), c === s)
      t.push(e.slice(r, o + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[r]);
    }
    r = o + 1, i = l;
  }
  return t;
}
class Ci extends ar {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, i) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = i) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? wn(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Ci(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    return r < sr(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ih(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Lh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    return Mh(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return pg(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), fa(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, zs(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = nn(this.getExtent());
      this.flatInteriorPoint_ = Dh(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new on(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new Ws(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, i = this.ends_, r = [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], c = new Ws(
        t.slice(s, l),
        e
      );
      r.push(c), s = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      kh(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = fa(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = Oh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new Ci(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return wg(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = ho(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
function pd(n) {
  if (ao(n))
    throw new Error("Cannot create polygon from empty extent");
  const e = n[0], t = n[1], i = n[2], r = n[3], s = [
    e,
    t,
    e,
    r,
    i,
    r,
    i,
    t,
    e,
    t
  ];
  return new Ci(s, "XY", [s.length]);
}
function ga(n, e, t, i, r, s, o) {
  let a, l;
  const c = (t - e) / i;
  if (c === 1)
    a = e;
  else if (c === 2)
    a = e, l = r;
  else if (c !== 0) {
    let h = n[e], u = n[e + 1], d = 0;
    const f = [0];
    for (let m = e + i; m < t; m += i) {
      const y = n[m], p = n[m + 1];
      d += Math.sqrt((y - h) * (y - h) + (p - u) * (p - u)), f.push(d), h = y, u = p;
    }
    const g = r * d, _ = qp(f, g);
    _ < 0 ? (l = (g - f[-_ - 2]) / (f[-_ - 1] - f[-_ - 2]), a = e + (-_ - 2) * i) : a = e + _ * i;
  }
  o = o > 1 ? o : 2, s = s || new Array(o);
  for (let h = 0; h < o; ++h)
    s[h] = a === void 0 ? NaN : l === void 0 ? n[a + h] : Nt(n[a + h], n[a + i + h], l);
  return s;
}
function Nc(n, e, t, i, r, s) {
  if (t == e)
    return null;
  let o;
  if (r < n[e + i - 1])
    return s ? (o = n.slice(e, e + i), o[i - 1] = r, o) : null;
  if (n[t - 1] < r)
    return s ? (o = n.slice(t - i, t), o[i - 1] = r, o) : null;
  if (r == n[e + i - 1])
    return n.slice(e, e + i);
  let a = e / i, l = t / i;
  for (; a < l; ) {
    const d = a + l >> 1;
    r < n[(d + 1) * i - 1] ? l = d : a = d + 1;
  }
  const c = n[a * i - 1];
  if (r == c)
    return n.slice((a - 1) * i, (a - 1) * i + i);
  const h = n[(a + 1) * i - 1], u = (r - c) / (h - c);
  o = [];
  for (let d = 0; d < i - 1; ++d)
    o.push(
      Nt(
        n[(a - 1) * i + d],
        n[a * i + d],
        u
      )
    );
  return o.push(r), o;
}
function d0(n, e, t, i, r, s, o) {
  if (o)
    return Nc(
      n,
      e,
      t[t.length - 1],
      i,
      r,
      s
    );
  let a;
  if (r < n[i - 1])
    return s ? (a = n.slice(0, i), a[i - 1] = r, a) : null;
  if (n[n.length - 1] < r)
    return s ? (a = n.slice(n.length - i), a[i - 1] = r, a) : null;
  for (let l = 0, c = t.length; l < c; ++l) {
    const h = t[l];
    if (e != h) {
      if (r < n[e + i - 1])
        return null;
      if (r <= n[h - 1])
        return Nc(
          n,
          e,
          h,
          i,
          r,
          !1
        );
      e = h;
    }
  }
  return null;
}
function Nh(n, e, t, i) {
  let r = n[e], s = n[e + 1], o = 0;
  for (let a = e + i; a < t; a += i) {
    const l = n[a], c = n[a + 1];
    o += Math.sqrt((l - r) * (l - r) + (c - s) * (c - s)), r = l, s = c;
  }
  return o;
}
class Zr extends ar {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    wn(this.flatCoordinates, e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Zr(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    return r < sr(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ph(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Ah(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      r
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return Eg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, Nc(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return ga(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Nh(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = Za(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Zr(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return qa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      this.getExtent()
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ka(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const et = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, tr = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", f0 = tr.includes("safari") && !tr.includes("chrom"), g0 = f0 && (tr.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(tr)), m0 = tr.includes("webkit") && !tr.includes("edge"), Rg = tr.includes("macintosh"), _0 = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Gh = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Cg = typeof Image < "u" && Image.prototype.decode, Pg = function() {
  let n = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        n = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return n;
}(), le = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};
function je(n, e, t, i) {
  let r;
  return t && t.length ? r = /** @type {HTMLCanvasElement} */
  t.shift() : Gh ? r = new OffscreenCanvas(n || 300, e || 300) : r = document.createElement("canvas"), n && (r.width = n), e && (r.height = e), /** @type {CanvasRenderingContext2D} */
  r.getContext("2d", i);
}
let Fl;
function ma() {
  return Fl || (Fl = je(1, 1)), Fl;
}
function Ja(n) {
  const e = n.canvas;
  e.width = 1, e.height = 1, n.clearRect(0, 0, 1, 1);
}
function p0(n) {
  let e = n.offsetWidth;
  const t = getComputedStyle(n);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function y0(n) {
  let e = n.offsetHeight;
  const t = getComputedStyle(n);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function yd(n, e) {
  const t = e.parentNode;
  t && t.replaceChild(n, e);
}
function Ig(n) {
  for (; n.lastChild; )
    n.lastChild.remove();
}
function x0(n, e) {
  const t = n.childNodes;
  for (let i = 0; ; ++i) {
    const r = t[i], s = e[i];
    if (!r && !s)
      break;
    if (r !== s) {
      if (!r) {
        n.appendChild(s);
        continue;
      }
      if (!s) {
        n.removeChild(r), --i;
        continue;
      }
      n.insertBefore(s, r);
    }
  }
}
const Uh = [NaN, NaN, NaN, 0];
let kl;
function v0() {
  return kl || (kl = je(1, 1, void 0, {
    willReadFrequently: !0,
    desynchronized: !0
  })), kl;
}
const E0 = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, T0 = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, w0 = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, S0 = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
function No(n, e) {
  return n.endsWith("%") ? Number(n.substring(0, n.length - 1)) / e : Number(n);
}
function Ls(n) {
  throw new Error('failed to parse "' + n + '" as color');
}
function Ag(n) {
  if (n.toLowerCase().startsWith("rgb")) {
    const s = n.match(T0) || n.match(E0) || n.match(w0);
    if (s) {
      const o = s[4], a = 100 / 255;
      return [
        De(No(s[1], a) + 0.5 | 0, 0, 255),
        De(No(s[2], a) + 0.5 | 0, 0, 255),
        De(No(s[3], a) + 0.5 | 0, 0, 255),
        o !== void 0 ? De(No(o, 100), 0, 1) : 1
      ];
    }
    Ls(n);
  }
  if (n.startsWith("#")) {
    if (S0.test(n)) {
      const s = n.substring(1), o = s.length <= 4 ? 1 : 2, a = [0, 0, 0, 255];
      for (let l = 0, c = s.length; l < c; l += o) {
        let h = parseInt(s.substring(l, l + o), 16);
        o === 1 && (h += h << 4), a[l / o] = h;
      }
      return a[3] = a[3] / 255, a;
    }
    Ls(n);
  }
  const e = v0();
  e.fillStyle = "#abcdef";
  let t = e.fillStyle;
  e.fillStyle = n, e.fillStyle === t && (e.fillStyle = "#fedcba", t = e.fillStyle, e.fillStyle = n, e.fillStyle === t && Ls(n));
  const i = e.fillStyle;
  if (i.startsWith("#") || i.startsWith("rgba"))
    return Ag(i);
  e.clearRect(0, 0, 1, 1), e.fillRect(0, 0, 1, 1);
  const r = Array.from(e.getImageData(0, 0, 1, 1).data);
  return r[3] = lo(r[3] / 255, 3), r;
}
function Vn(n) {
  return typeof n == "string" ? n : zh(n);
}
const b0 = 1024, ms = {};
let Nl = 0;
function R0(n) {
  if (n.length === 4)
    return n;
  const e = n.slice();
  return e[3] = 1, e;
}
function Gl(n) {
  return n > 31308e-7 ? Math.pow(n, 1 / 2.4) * 269.025 - 14.025 : n * 3294.6;
}
function Ul(n) {
  return n > 0.2068965 ? Math.pow(n, 3) : (n - 4 / 29) * (108 / 841);
}
function Bl(n) {
  return n > 10.314724 ? Math.pow((n + 14.025) / 269.025, 2.4) : n / 3294.6;
}
function zl(n) {
  return n > 88564e-7 ? Math.pow(n, 1 / 3) : n / (108 / 841) + 4 / 29;
}
function xd(n) {
  const e = Bl(n[0]), t = Bl(n[1]), i = Bl(n[2]), r = zl(e * 0.222488403 + t * 0.716873169 + i * 0.06060791), s = 500 * (zl(e * 0.452247074 + t * 0.399439023 + i * 0.148375274) - r), o = 200 * (r - zl(e * 0.016863605 + t * 0.117638439 + i * 0.865350722)), a = Math.atan2(o, s) * (180 / Math.PI);
  return [
    116 * r - 16,
    Math.sqrt(s * s + o * o),
    a < 0 ? a + 360 : a,
    n[3]
  ];
}
function C0(n) {
  const e = (n[0] + 16) / 116, t = n[1], i = n[2] * Math.PI / 180, r = Ul(e), s = Ul(e + t / 500 * Math.cos(i)), o = Ul(e - t / 200 * Math.sin(i)), a = Gl(s * 3.021973625 - r * 1.617392459 - o * 0.404875592), l = Gl(s * -0.943766287 + r * 1.916279586 + o * 0.027607165), c = Gl(s * 0.069407491 - r * 0.22898585 + o * 1.159737864);
  return [
    De(a + 0.5 | 0, 0, 255),
    De(l + 0.5 | 0, 0, 255),
    De(c + 0.5 | 0, 0, 255),
    n[3]
  ];
}
function Bh(n) {
  if (n === "none")
    return Uh;
  if (ms.hasOwnProperty(n))
    return ms[n];
  if (Nl >= b0) {
    let t = 0;
    for (const i in ms)
      t++ & 3 || (delete ms[i], --Nl);
  }
  const e = Ag(n);
  e.length !== 4 && Ls(n);
  for (const t of e)
    isNaN(t) && Ls(n);
  return ms[n] = e, ++Nl, e;
}
function an(n) {
  return Array.isArray(n) ? n : Bh(n);
}
function zh(n) {
  let e = n[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = n[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let i = n[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const r = n[3] === void 0 ? 1 : Math.round(n[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + t + "," + i + "," + r + ")";
}
function P0(n, e, t) {
  const i = (
    /** @type {HTMLImageElement} */
    n
  );
  let r = !0, s = !1, o = !1;
  const a = [
    aa(i, ie.LOAD, function() {
      o = !0, s || e();
    })
  ];
  return i.src && Cg ? (s = !0, i.decode().then(function() {
    r && e();
  }).catch(function(l) {
    r && (o ? e() : t());
  })) : a.push(aa(i, ie.ERROR, t)), function() {
    r = !1, a.forEach(Re);
  };
}
function I0(n, e) {
  return new Promise((t, i) => {
    function r() {
      o(), t(n);
    }
    function s() {
      o(), i(new Error("Image load error"));
    }
    function o() {
      n.removeEventListener("load", r), n.removeEventListener("error", s);
    }
    n.addEventListener("load", r), n.addEventListener("error", s);
  });
}
function A0(n, e) {
  return e && (n.src = e), n.src && Cg ? new Promise(
    (t, i) => n.decode().then(() => t(n)).catch(
      (r) => n.complete && n.width ? t(n) : i(r)
    )
  ) : I0(n);
}
class L0 {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const i = this.cache_[t];
        !(e++ & 3) && !i.hasListener() && (delete this.cache_[t], delete this.patternCache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, i) {
    const r = Wl(e, t, i);
    return r in this.cache_ ? this.cache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, t, i) {
    const r = Wl(e, t, i);
    return r in this.patternCache_ ? this.patternCache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, t, i, r, s) {
    const o = Wl(e, t, i), a = o in this.cache_;
    this.cache_[o] = r, s && (r.getImageState() === le.IDLE && r.load(), r.getImageState() === le.LOADING ? r.ready().then(() => {
      this.patternCache_[o] = ma().createPattern(
        r.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = ma().createPattern(
      r.getImage(1),
      "repeat"
    )), a || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `1024`. Change this value when
   * your map uses more than 1024 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function Wl(n, e, t) {
  const i = t ? an(t) : "null";
  return e + ":" + n + ":" + i;
}
const $t = new L0();
let _s = null;
class Lg extends Wa {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, t, i, r, s) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = s, this.imageState_ = r === void 0 ? le.IDLE : r, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = t, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === le.LOADED) {
      _s || (_s = je(1, 1, void 0, {
        willReadFrequently: !0
      })), _s.drawImage(this.image_, 0, 0);
      try {
        _s.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        _s = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(ie.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = le.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = le.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], i = je(e, t);
        i.fillRect(0, 0, e, t), this.hitDetectionImage_ = i.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === le.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = le.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && A0(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== le.LOADED)
      return;
    const t = this.image_, i = je(
      Math.ceil(t.width * e),
      Math.ceil(t.height * e)
    ), r = i.canvas;
    i.scale(e, e), i.drawImage(t, 0, 0), i.globalCompositeOperation = "multiply", i.fillStyle = Vn(this.color_), i.fillRect(0, 0, r.width / e, r.height / e), i.globalCompositeOperation = "destination-in", i.drawImage(t, 0, 0), this.canvas_[e] = r;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      if (this.imageState_ === le.LOADED || this.imageState_ === le.ERROR)
        e();
      else {
        const t = () => {
          (this.imageState_ === le.LOADED || this.imageState_ === le.ERROR) && (this.removeEventListener(ie.CHANGE, t), e());
        };
        this.addEventListener(ie.CHANGE, t);
      }
    })), this.ready_;
  }
}
function Wh(n, e, t, i, r, s) {
  let o = e === void 0 ? void 0 : $t.get(e, t, r);
  return o || (o = new Lg(
    n,
    n && "src" in n ? n.src || void 0 : e,
    t,
    i,
    r
  ), $t.set(e, t, r, o, s)), s && o && !$t.getPattern(e, t, r) && $t.set(e, t, r, o, s), o;
}
function Tn(n) {
  return n ? Array.isArray(n) ? zh(n) : typeof n == "object" && "src" in n ? O0(n) : n : null;
}
function O0(n) {
  if (!n.offset || !n.size)
    return $t.getPattern(n.src, "anonymous", n.color);
  const e = n.src + ":" + n.offset, t = $t.getPattern(
    e,
    void 0,
    n.color
  );
  if (t)
    return t;
  const i = $t.get(n.src, "anonymous", null);
  if (i.getImageState() !== le.LOADED)
    return null;
  const r = je(
    n.size[0],
    n.size[1]
  );
  return r.drawImage(
    i.getImage(1),
    n.offset[0],
    n.offset[1],
    n.size[0],
    n.size[1],
    0,
    0,
    n.size[0],
    n.size[1]
  ), Wh(
    r.canvas,
    e,
    void 0,
    le.LOADED,
    n.color,
    !0
  ), $t.getPattern(e, void 0, n.color);
}
class Og {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, i, r, s) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, i) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, t, i) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, t, i) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, i) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, i) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, i) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, i) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
const Go = "ol-hidden", M0 = "ol-selectable", uo = "ol-unselectable", Yh = "ol-control", vd = "ol-collapsed", D0 = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
  ].join(""),
  "i"
), Ed = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], Gc = {
  normal: 400,
  bold: 700
}, Uc = function(n) {
  const e = n.match(D0);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "400",
      variant: "normal"
    }
  );
  for (let i = 0, r = Ed.length; i < r; ++i) {
    const s = e[i + 1];
    s !== void 0 && (t[Ed[i]] = typeof s == "string" ? s.trim() : s);
  }
  return isNaN(Number(t.weight)) && t.weight in Gc && (t.weight = Gc[t.weight]), t.families = t.family.split(/,\s?/).map((i) => i.trim().replace(/^['"]|['"]$/g, "")), t;
}, Mg = "10px sans-serif", It = "#000", qr = "round", Zn = [], qn = 0, Jr = "round", Ys = 10, $s = "#000", js = "center", _a = "middle", zi = [0, 0, 0, 0], Vs = 1, Pr = new Ft();
let ps = null, Td;
const Bc = {}, F0 = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
]);
function k0(n, e, t) {
  return `${n} ${e} 16px "${t}"`;
}
const N0 = /* @__PURE__ */ function() {
  let e, t;
  async function i(s) {
    await t.ready;
    const o = await t.load(s);
    if (o.length === 0)
      return !1;
    const a = Uc(s), l = a.families[0].toLowerCase(), c = a.weight;
    return o.some(
      /**
       * @param {import('../css.js').FontParameters} f Font.
       * @return {boolean} Font matches.
       */
      (h) => {
        const u = h.family.replace(/^['"]|['"]$/g, "").toLowerCase(), d = Gc[h.weight] || h.weight;
        return u === l && h.style === a.style && d == c;
      }
    );
  }
  async function r() {
    await t.ready;
    let s = !0;
    const o = Pr.getProperties(), a = Object.keys(o).filter(
      (l) => o[l] < 100
    );
    for (let l = a.length - 1; l >= 0; --l) {
      const c = a[l];
      let h = o[c];
      h < 100 && (await i(c) ? (Qr(Bc), Pr.set(c, 100)) : (h += 10, Pr.set(c, h, !0), h < 100 && (s = !1)));
    }
    e = void 0, s || (e = setTimeout(r, 100));
  }
  return async function(s) {
    t || (t = Gh ? self.fonts : document.fonts);
    const o = Uc(s);
    if (!o)
      return;
    const a = o.families;
    let l = !1;
    for (const c of a) {
      if (F0.has(c))
        continue;
      const h = k0(o.style, o.weight, c);
      Pr.get(h) === void 0 && (Pr.set(h, 0, !0), l = !0);
    }
    l && (clearTimeout(e), e = setTimeout(r, 100));
  };
}(), G0 = /* @__PURE__ */ function() {
  let n;
  return function(e) {
    let t = Bc[e];
    if (t == null) {
      if (Gh) {
        const i = Uc(e), r = Dg(e, "Žg");
        t = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
      } else
        n || (n = document.createElement("div"), n.innerHTML = "M", n.style.minHeight = "0", n.style.maxHeight = "none", n.style.height = "auto", n.style.padding = "0", n.style.border = "none", n.style.position = "absolute", n.style.display = "block", n.style.left = "-99999px"), n.style.font = e, document.body.appendChild(n), t = n.offsetHeight, document.body.removeChild(n);
      Bc[e] = t;
    }
    return t;
  };
}();
function Dg(n, e) {
  return ps || (ps = je(1, 1)), n != Td && (ps.font = n, Td = ps.font), ps.measureText(e);
}
function Fg(n, e) {
  return Dg(n, e).width;
}
function wd(n, e, t) {
  if (e in t)
    return t[e];
  const i = e.split(`
`).reduce((r, s) => Math.max(r, Fg(n, s)), 0);
  return t[e] = i, i;
}
function U0(n, e) {
  const t = [], i = [], r = [];
  let s = 0, o = 0, a = 0, l = 0;
  for (let c = 0, h = e.length; c <= h; c += 2) {
    const u = e[c];
    if (u === `
` || c === h) {
      s = Math.max(s, o), r.push(o), o = 0, a += l, l = 0;
      continue;
    }
    const d = e[c + 1] || n.font, f = Fg(d, u);
    t.push(f), o += f;
    const g = G0(d);
    i.push(g), l = Math.max(l, g);
  }
  return { width: s, height: a, widths: t, heights: i, lineWidths: r };
}
function B0(n, e, t, i, r, s, o, a, l, c, h) {
  n.save(), t !== 1 && (n.globalAlpha === void 0 ? n.globalAlpha = (u) => u.globalAlpha *= t : n.globalAlpha *= t), e && n.transform.apply(n, e), /** @type {*} */
  i.contextInstructions ? (n.translate(l, c), n.scale(h[0], h[1]), z0(
    /** @type {Label} */
    i,
    n
  )) : h[0] < 0 || h[1] < 0 ? (n.translate(l, c), n.scale(h[0], h[1]), n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    r,
    s,
    o,
    a,
    0,
    0,
    o,
    a
  )) : n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    r,
    s,
    o,
    a,
    l,
    c,
    o * h[0],
    a * h[1]
  ), n.restore();
}
function z0(n, e) {
  const t = n.contextInstructions;
  for (let i = 0, r = t.length; i < r; i += 2)
    Array.isArray(t[i + 1]) ? e[t[i]].apply(
      e,
      t[i + 1]
    ) : e[t[i]] = t[i + 1];
}
class kg extends Og {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, i, r, s, o, a) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = i, this.transform_ = r, this.transformRotation_ = r ? lo(Math.atan2(r[1], r[0]), 10) : 0, this.viewRotation_ = s, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Ke();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, i, r) {
    if (!this.image_)
      return;
    const s = Sn(
      e,
      t,
      i,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, a = this.tmpLocalTransform_, l = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
    let c = this.imageRotation_;
    this.transformRotation_ === 0 && (c -= this.viewRotation_), this.imageRotateWithView_ && (c += this.viewRotation_);
    for (let h = 0, u = s.length; h < u; h += 2) {
      const d = s[h] - this.imageAnchorX_, f = s[h + 1] - this.imageAnchorY_;
      if (c !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = d + this.imageAnchorX_, _ = f + this.imageAnchorY_;
        sn(
          a,
          g,
          _,
          1,
          1,
          c,
          -g,
          -_
        ), o.save(), o.transform.apply(o, a), o.translate(g, _), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          d,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, i, r) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const s = Sn(
      e,
      t,
      i,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let a = this.textRotation_;
    for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); t < i; t += r) {
      const l = s[t] + this.textOffsetX_, c = s[t + 1] + this.textOffsetY_;
      a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, c - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, c), this.textFillState_ && o.fillText(this.text_, l, c));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, i, r, s) {
    const o = this.context_, a = Sn(
      e,
      t,
      i,
      r,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(a[0], a[1]);
    let l = a.length;
    s && (l -= 2);
    for (let c = 2; c < l; c += 2)
      o.lineTo(a[c], a[c + 1]);
    return s && o.closePath(), i;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, i, r) {
    for (let s = 0, o = i.length; s < o; ++s)
      t = this.moveToLineTo_(
        e,
        t,
        i[s],
        r,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   * @override
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!vt(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = e0(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), i = t[2] - t[0], r = t[3] - t[1], s = Math.sqrt(i * i + r * r), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          s,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   * @override
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   * @override
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   * @override
   */
  drawFeature(e, t) {
    const i = t.getGeometryFunction()(e);
    i && (this.setStyle(t), this.drawGeometry(i));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let i = 0, r = t.length; i < r; ++i)
      this.drawGeometry(t[i]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!vt(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          i,
          0,
          i.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (vt(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const i = this.context_, r = e.getFlatCoordinates();
        let s = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), a = e.getStride();
        i.beginPath();
        for (let l = 0, c = o.length; l < c; ++l)
          s = this.moveToLineTo_(
            r,
            s,
            o[l],
            a,
            !1
          );
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = e.getFlatMidpoints();
        this.drawText_(i, 0, i.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!vt(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!vt(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getOrientedFlatCoordinates();
        let r = 0;
        const s = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let a = 0, l = s.length; a < l; ++a) {
          const c = s[a];
          r = this.drawRings_(i, r, c, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, i = this.contextFillState_;
    i ? i.fillStyle != e.fillStyle && (i.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, i = this.contextStrokeState_;
    i ? (i.lineCap != e.lineCap && (i.lineCap = e.lineCap, t.lineCap = e.lineCap), oi(i.lineDash, e.lineDash) || t.setLineDash(
      i.lineDash = e.lineDash
    ), i.lineDashOffset != e.lineDashOffset && (i.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), i.lineJoin != e.lineJoin && (i.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), i.lineWidth != e.lineWidth && (i.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), i.miterLimit != e.miterLimit && (i.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), i.strokeStyle != e.strokeStyle && (i.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, i = this.contextTextState_, r = e.textAlign ? e.textAlign : js;
    i ? (i.font != e.font && (i.font = e.font, t.font = e.font), i.textAlign != r && (i.textAlign = r, t.textAlign = r), i.textBaseline != e.textBaseline && (i.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = r, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: r,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const i = e.getColor();
      this.fillState_ = {
        fillStyle: Tn(
          i || It
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const i = t.getColor(), r = t.getLineCap(), s = t.getLineDash(), o = t.getLineDashOffset(), a = t.getLineJoin(), l = t.getWidth(), c = t.getMiterLimit(), h = s || Zn;
      this.strokeState_ = {
        lineCap: r !== void 0 ? r : qr,
        lineDash: this.pixelRatio_ === 1 ? h : h.map((u) => u * this.pixelRatio_),
        lineDashOffset: (o || qn) * this.pixelRatio_,
        lineJoin: a !== void 0 ? a : Jr,
        lineWidth: (l !== void 0 ? l : Vs) * this.pixelRatio_,
        miterLimit: c !== void 0 ? c : Ys,
        strokeStyle: Tn(
          i || $s
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const i = e.getPixelRatio(this.pixelRatio_), r = e.getAnchor(), s = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * i, this.imageAnchorY_ = r[1] * i, this.imageHeight_ = t[1] * i, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = s[0], this.imageOriginY_ = s[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / i,
      o[1] * this.pixelRatio_ / i
    ], this.imageWidth_ = t[0] * i;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const f = t.getColor();
        this.textFillState_ = {
          fillStyle: Tn(
            f || It
          )
        };
      }
      const i = e.getStroke();
      if (!i)
        this.textStrokeState_ = null;
      else {
        const f = i.getColor(), g = i.getLineCap(), _ = i.getLineDash(), m = i.getLineDashOffset(), y = i.getLineJoin(), p = i.getWidth(), E = i.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : qr,
          lineDash: _ || Zn,
          lineDashOffset: m || qn,
          lineJoin: y !== void 0 ? y : Jr,
          lineWidth: p !== void 0 ? p : Vs,
          miterLimit: E !== void 0 ? E : Ys,
          strokeStyle: Tn(
            f || $s
          )
        };
      }
      const r = e.getFont(), s = e.getOffsetX(), o = e.getOffsetY(), a = e.getRotateWithView(), l = e.getRotation(), c = e.getScaleArray(), h = e.getText(), u = e.getTextAlign(), d = e.getTextBaseline();
      this.textState_ = {
        font: r !== void 0 ? r : Mg,
        textAlign: u !== void 0 ? u : js,
        textBaseline: d !== void 0 ? d : _a
      }, this.text_ = h !== void 0 ? Array.isArray(h) ? h.reduce((f, g, _) => f += _ % 2 ? " " : g, "") : h : "", this.textOffsetX_ = s !== void 0 ? this.pixelRatio_ * s : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * c[0],
        this.pixelRatio_ * c[1]
      ];
    }
  }
}
const W0 = 0.5, Ng = {
  Point: Z0,
  LineString: X0,
  Polygon: J0,
  MultiPoint: q0,
  MultiLineString: H0,
  MultiPolygon: K0,
  GeometryCollection: V0,
  Circle: $0
};
function Y0(n, e) {
  return parseInt(q(n), 10) - parseInt(q(e), 10);
}
function Sd(n, e) {
  const t = Gg(n, e);
  return t * t;
}
function Gg(n, e) {
  return W0 * n / e;
}
function $0(n, e, t, i, r) {
  const s = t.getFill(), o = t.getStroke();
  if (s || o) {
    const l = n.getBuilder(t.getZIndex(), "Circle");
    l.setFillStrokeStyle(s, o), l.drawCircle(e, i, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = n.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, i);
  }
}
function bd(n, e, t, i, r, s, o, a) {
  const l = [], c = t.getImage();
  if (c) {
    let d = !0;
    const f = c.getImageState();
    f == le.LOADED || f == le.ERROR ? d = !1 : f == le.IDLE && c.load(), d && l.push(c.ready());
  }
  const h = t.getFill();
  h && h.loading() && l.push(h.ready());
  const u = l.length > 0;
  return u && Promise.all(l).then(() => r(null)), j0(
    n,
    e,
    t,
    i,
    s,
    o,
    a
  ), u;
}
function j0(n, e, t, i, r, s, o) {
  const a = t.getGeometryFunction()(e);
  if (!a)
    return;
  const l = a.simplifyTransformed(
    i,
    r
  );
  if (t.getRenderer())
    Ug(n, l, t, e, o);
  else {
    const h = Ng[l.getType()];
    h(
      n,
      l,
      t,
      e,
      o,
      s
    );
  }
}
function Ug(n, e, t, i, r) {
  if (e.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let a = 0, l = o.length; a < l; ++a)
      Ug(n, o[a], t, i, r);
    return;
  }
  n.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    i,
    t.getRenderer(),
    t.getHitDetectionRenderer(),
    r
  );
}
function V0(n, e, t, i, r, s) {
  const o = e.getGeometriesArray();
  let a, l;
  for (a = 0, l = o.length; a < l; ++a) {
    const c = Ng[o[a].getType()];
    c(
      n,
      o[a],
      t,
      i,
      r,
      s
    );
  }
}
function X0(n, e, t, i, r) {
  const s = t.getStroke();
  if (s) {
    const a = n.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawLineString(e, i, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = n.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, i, r);
  }
}
function H0(n, e, t, i, r) {
  const s = t.getStroke();
  if (s) {
    const a = n.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawMultiLineString(e, i, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = n.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, i, r);
  }
}
function K0(n, e, t, i, r) {
  const s = t.getFill(), o = t.getStroke();
  if (o || s) {
    const l = n.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawMultiPolygon(e, i, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = n.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, i, r);
  }
}
function Z0(n, e, t, i, r, s) {
  const o = t.getImage(), a = t.getText(), l = a && a.getText(), c = s && o && l ? {} : void 0;
  if (o) {
    if (o.getImageState() != le.LOADED)
      return;
    const h = n.getBuilder(t.getZIndex(), "Image");
    h.setImageStyle(o, c), h.drawPoint(e, i, r);
  }
  if (l) {
    const h = n.getBuilder(t.getZIndex(), "Text");
    h.setTextStyle(a, c), h.drawText(e, i, r);
  }
}
function q0(n, e, t, i, r, s) {
  const o = t.getImage(), a = o && o.getOpacity() !== 0, l = t.getText(), c = l && l.getText(), h = s && a && c ? {} : void 0;
  if (a) {
    if (o.getImageState() != le.LOADED)
      return;
    const u = n.getBuilder(t.getZIndex(), "Image");
    u.setImageStyle(o, h), u.drawMultiPoint(e, i, r);
  }
  if (c) {
    const u = n.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l, h), u.drawText(e, i, r);
  }
}
function J0(n, e, t, i, r) {
  const s = t.getFill(), o = t.getStroke();
  if (s || o) {
    const l = n.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawPolygon(e, i, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = n.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, i, r);
  }
}
let Q0 = !1;
function ex(n, e, t, i, r, s, o) {
  const a = new XMLHttpRequest();
  a.open(
    "GET",
    typeof n == "function" ? n(t, i, r) : n,
    !0
  ), e.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = Q0, a.onload = function(l) {
    if (!a.status || a.status >= 200 && a.status < 300) {
      const c = e.getType();
      try {
        let h;
        c == "text" || c == "json" ? h = a.responseText : c == "xml" ? h = a.responseXML || a.responseText : c == "arraybuffer" && (h = /** @type {ArrayBuffer} */
        a.response), h ? s(
          /** @type {Array<FeatureType>} */
          e.readFeatures(h, {
            extent: t,
            featureProjection: r
          }),
          e.readProjection(h)
        ) : o();
      } catch {
        o();
      }
    } else
      o();
  }, a.onerror = o, a.send();
}
function Rd(n, e) {
  return function(t, i, r, s, o) {
    ex(
      n,
      e,
      t,
      i,
      r,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      (a, l) => {
        this.addFeatures(a), s !== void 0 && s(a);
      },
      () => {
        this.changed(), o !== void 0 && o();
      }
    );
  };
}
function tx(n, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function Bg(n, e, t, i) {
  const r = [];
  let s = St();
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s = vh(
      n,
      e,
      l[0],
      i
    ), r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = l[l.length - 1];
  }
  return r;
}
class pa extends mg {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(Re), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const e = this.geometries_;
    for (let t = 0, i = e.length; t < i; ++t)
      this.changeEventsKeys_.push(
        ce(e[t], ie.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new pa(
      Yl(this.geometries_)
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    if (r < sr(this.getExtent(), e, t))
      return r;
    const s = this.geometries_;
    for (let o = 0, a = s.length; o < a; ++o)
      r = s[o].closestPointXY(
        e,
        t,
        i,
        r
      );
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    const i = this.geometries_;
    for (let r = 0, s = i.length; r < s; ++r)
      if (i[r].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    es(e);
    const t = this.geometries_;
    for (let i = 0, r = t.length; i < r; ++i)
      Hf(e, t[i].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return Yl(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let i = 0, r = t.length; i < r; ++i)
      t[i].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[i].getGeometriesArrayRecursive()
      ) : e.push(t[i]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   * @override
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], i = this.geometries_;
    let r = !1;
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s], l = a.getSimplifiedGeometry(e);
      t.push(l), l !== a && (r = !0);
    }
    return r ? new pa(
      t
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let i = 0, r = t.length; i < r; ++i)
      if (t[i].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(e, t) {
    const i = this.geometries_;
    for (let r = 0, s = i.length; r < s; ++r)
      i[r].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(e, t, i) {
    i || (i = nn(this.getExtent()));
    const r = this.geometries_;
    for (let s = 0, o = r.length; s < o; ++s)
      r[s].scale(e, t, i);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(Yl(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let i = 0, r = t.length; i < r; ++i)
      t[i].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(e, t) {
    const i = this.geometries_;
    for (let r = 0, s = i.length; r < s; ++r)
      i[r].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function Yl(n) {
  return n.map((e) => e.clone());
}
class ya extends ar {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, i) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && i)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = i;
    else {
      const r = (
        /** @type {Array<LineString>} */
        e
      ), s = [], o = [];
      for (let l = 0, c = r.length; l < c; ++l) {
        const h = r[l];
        wn(s, h.getFlatCoordinates()), o.push(s.length);
      }
      const a = r.length === 0 ? this.getLayout() : r[0].getLayout();
      this.setFlatCoordinates(a, s), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    wn(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new ya(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    return r < sr(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ih(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Lh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      r
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, i) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, i = i !== void 0 ? i : !1, d0(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      i
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return zs(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new Zr(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, i = this.layout, r = [];
    let s = 0;
    for (let o = 0, a = t.length; o < a; ++o) {
      const l = t[o], c = new Zr(
        e.slice(s, l),
        i
      );
      r.push(c), s = l;
    }
    return r;
  }
  /**
   * Return the sum of all line string lengths
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    const e = this.ends_;
    let t = 0, i = 0;
    for (let r = 0, s = e.length; r < s; ++r)
      i += Nh(
        this.flatCoordinates,
        t,
        e[r],
        this.stride
      ), t = e[r];
    return i;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let i = 0;
    const r = this.ends_, s = this.stride;
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o], c = ga(
        t,
        i,
        l,
        s,
        0.5
      );
      wn(e, c), i = l;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = xg(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      i
    ), new ya(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return c0(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = ho(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
class Qa extends ar {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    wn(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Qa(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    if (r < sr(this.getExtent(), e, t))
      return r;
    const s = this.flatCoordinates, o = this.stride;
    for (let a = 0, l = s.length; a < l; a += o) {
      const c = Xi(
        e,
        t,
        s[a],
        s[a + 1]
      );
      if (c < r) {
        r = c;
        for (let h = 0; h < o; ++h)
          i[h] = s[a + h];
        i.length = o;
      }
    }
    return r;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates.length / this.stride;
    return e < 0 || t <= e ? null : new on(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, i = this.stride, r = [];
    for (let s = 0, o = e.length; s < o; s += i) {
      const a = new on(e.slice(s, s + i), t);
      r.push(a);
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, i = this.stride;
    for (let r = 0, s = t.length; r < s; r += i) {
      const o = t[r], a = t[r + 1];
      if (yh(e, o, a))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ka(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
class xa extends ar {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, i) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(e[0])) {
      const r = (
        /** @type {Array<Polygon>} */
        e
      ), s = [], o = [];
      for (let a = 0, l = r.length; a < l; ++a) {
        const c = r[a], h = s.length, u = c.getEnds();
        for (let d = 0, f = u.length; d < f; ++d)
          u[d] += h;
        wn(s, c.getFlatCoordinates()), o.push(u);
      }
      t = r.length === 0 ? this.getLayout() : r[0].getLayout(), e = s, i = o;
    }
    t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = i) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const i = this.flatCoordinates.length;
      wn(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let r = 0, s = t.length; r < s; ++r)
        t[r] += i;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   * @override
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let r = 0; r < e; ++r)
      t[r] = this.endss_[r].slice();
    const i = new xa(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return i.applyProperties(this), i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, i, r) {
    return r < sr(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      n0(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), i0(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    return l0(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return t0(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), kc(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, Fc(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = Bg(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = vg(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new Qa(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      Sg(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = kc(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = o0(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new xa(t, "XY", i);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const s = this.endss_[e - 1];
      t = s[s.length - 1];
    }
    const i = this.endss_[e].slice(), r = i[i.length - 1];
    if (t !== 0)
      for (let s = 0, o = i.length; s < o; ++s)
        i[s] -= t;
    return new Ci(
      this.flatCoordinates.slice(t, r),
      this.layout,
      i
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, i = this.endss_, r = [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o].slice(), c = l[l.length - 1];
      if (s !== 0)
        for (let u = 0, d = l.length; u < d; ++u)
          l[u] -= s;
      const h = new Ci(
        t.slice(s, c),
        e,
        l
      );
      r.push(h), s = c;
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return h0(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const i = yg(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (i.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const r = i[i.length - 1];
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
    }
    this.changed();
  }
}
const Cd = Ke();
class At {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, i, r, s, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = s, this.squaredTolerance_, this.stride_ = r, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? xh(this.flatCoordinates_) : vh(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = nn(this.getExtent());
      this.flatInteriorPoints_ = Dh(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = bg(this.flatCoordinates_, this.ends_), t = Bg(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = vg(
        this.flatCoordinates_,
        0,
        e,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = ga(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const i = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let r = 0, s = i.length; r < s; ++r) {
        const o = i[r], a = ga(e, t, o, 2, 0.5);
        wn(this.flatMidpoints_, a), t = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = Ie(e);
    const t = e.getExtent(), i = e.getWorldExtent();
    if (t && i) {
      const r = ut(i) / ut(t);
      sn(
        Cd,
        i[0],
        i[3],
        r,
        -r,
        0,
        0,
        0
      ), Sn(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        Cd,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var e;
    return new At(
      this.type_,
      this.flatCoordinates_.slice(),
      (e = this.ends_) == null ? void 0 : e.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = Vf((e, t) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), t && this.simplifiedGeometry_.applyTransform(t);
      const i = this.simplifiedGeometry_.getFlatCoordinates();
      let r;
      switch (this.type_) {
        case "LineString":
          i.length = Za(
            i,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0
          ), r = [i.length];
          break;
        case "MultiLineString":
          r = [], i.length = xg(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0,
            r
          );
          break;
        case "Polygon":
          r = [], i.length = Oh(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            i,
            0,
            r
          );
          break;
      }
      return r && (this.simplifiedGeometry_ = new At(
        this.type_,
        i,
        r,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
At.prototype.getFlatCoordinates = At.prototype.getOrientedFlatCoordinates;
function zg(n, e, t = 0, i = n.length - 1, r = nx) {
  for (; i > t; ) {
    if (i - t > 600) {
      const l = i - t + 1, c = e - t + 1, h = Math.log(l), u = 0.5 * Math.exp(2 * h / 3), d = 0.5 * Math.sqrt(h * u * (l - u) / l) * (c - l / 2 < 0 ? -1 : 1), f = Math.max(t, Math.floor(e - c * u / l + d)), g = Math.min(i, Math.floor(e + (l - c) * u / l + d));
      zg(n, e, f, g, r);
    }
    const s = n[e];
    let o = t, a = i;
    for (ys(n, t, e), r(n[i], s) > 0 && ys(n, t, i); o < a; ) {
      for (ys(n, o, a), o++, a--; r(n[o], s) < 0; ) o++;
      for (; r(n[a], s) > 0; ) a--;
    }
    r(n[t], s) === 0 ? ys(n, t, a) : (a++, ys(n, a, i)), a <= e && (t = a + 1), e <= a && (i = a - 1);
  }
}
function ys(n, e, t) {
  const i = n[e];
  n[e] = n[t], n[t] = i;
}
function nx(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
let Wg = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!Bo(e, t)) return i;
    const r = this.toBBox, s = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const a = t.children[o], l = t.leaf ? r(a) : a;
        Bo(e, l) && (t.leaf ? i.push(a) : jl(e, l) ? this._all(a, i) : s.push(a));
      }
      t = s.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (!Bo(e, t)) return !1;
    const i = [];
    for (; t; ) {
      for (let r = 0; r < t.children.length; r++) {
        const s = t.children[r], o = t.leaf ? this.toBBox(s) : s;
        if (Bo(e, o)) {
          if (t.leaf || jl(e, o)) return !0;
          i.push(s);
        }
      }
      t = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const i = this.data;
        this.data = t, t = i;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = Ir([]), this;
  }
  remove(e, t) {
    if (!e) return this;
    let i = this.data;
    const r = this.toBBox(e), s = [], o = [];
    let a, l, c;
    for (; i || s.length; ) {
      if (i || (i = s.pop(), l = s[s.length - 1], a = o.pop(), c = !0), i.leaf) {
        const h = ix(e, i.children, t);
        if (h !== -1)
          return i.children.splice(h, 1), s.push(i), this._condense(s), this;
      }
      !c && !i.leaf && jl(i, r) ? (s.push(i), o.push(a), a = 0, l = i, i = i.children[0]) : l ? (a++, i = l.children[a], c = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const i = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
    return t;
  }
  _build(e, t, i, r) {
    const s = i - t + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = Ir(e.slice(t, i + 1)), yr(a, this.toBBox), a;
    r || (r = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, r - 1))), a = Ir([]), a.leaf = !1, a.height = r;
    const l = Math.ceil(s / o), c = l * Math.ceil(Math.sqrt(o));
    Pd(e, t, i, c, this.compareMinX);
    for (let h = t; h <= i; h += c) {
      const u = Math.min(h + c - 1, i);
      Pd(e, h, u, l, this.compareMinY);
      for (let d = h; d <= u; d += l) {
        const f = Math.min(d + l - 1, u);
        a.children.push(this._build(e, d, f, r - 1));
      }
    }
    return yr(a, this.toBBox), a;
  }
  _chooseSubtree(e, t, i, r) {
    for (; r.push(t), !(t.leaf || r.length - 1 === i); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < t.children.length; l++) {
        const c = t.children[l], h = $l(c), u = ox(e, c) - h;
        u < o ? (o = u, s = h < s ? h : s, a = c) : u === o && h < s && (s = h, a = c);
      }
      t = a || t.children[0];
    }
    return t;
  }
  _insert(e, t, i) {
    const r = i ? e : this.toBBox(e), s = [], o = this._chooseSubtree(r, this.data, t, s);
    for (o.children.push(e), Rs(o, r); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(r, s, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const i = e[t], r = i.children.length, s = this._minEntries;
    this._chooseSplitAxis(i, s, r);
    const o = this._chooseSplitIndex(i, s, r), a = Ir(i.children.splice(o, i.children.length - o));
    a.height = i.height, a.leaf = i.leaf, yr(i, this.toBBox), yr(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    this.data = Ir([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, yr(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let r, s = 1 / 0, o = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const l = bs(e, 0, a, this.toBBox), c = bs(e, a, i, this.toBBox), h = ax(l, c), u = $l(l) + $l(c);
      h < s ? (s = h, r = a, o = u < o ? u : o) : h === s && u < o && (o = u, r = a);
    }
    return r || i - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, i) {
    const r = e.leaf ? this.compareMinX : rx, s = e.leaf ? this.compareMinY : sx, o = this._allDistMargin(e, t, i, r), a = this._allDistMargin(e, t, i, s);
    o < a && e.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, i, r) {
    e.children.sort(r);
    const s = this.toBBox, o = bs(e, 0, t, s), a = bs(e, i - t, i, s);
    let l = Uo(o) + Uo(a);
    for (let c = t; c < i - t; c++) {
      const h = e.children[c];
      Rs(o, e.leaf ? s(h) : h), l += Uo(o);
    }
    for (let c = i - t - 1; c >= t; c--) {
      const h = e.children[c];
      Rs(a, e.leaf ? s(h) : h), l += Uo(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let r = i; r >= 0; r--)
      Rs(t[r], e);
  }
  _condense(e) {
    for (let t = e.length - 1, i; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (i = e[t - 1].children, i.splice(i.indexOf(e[t]), 1)) : this.clear() : yr(e[t], this.toBBox);
  }
};
function ix(n, e, t) {
  if (!t) return e.indexOf(n);
  for (let i = 0; i < e.length; i++)
    if (t(n, e[i])) return i;
  return -1;
}
function yr(n, e) {
  bs(n, 0, n.children.length, e, n);
}
function bs(n, e, t, i, r) {
  r || (r = Ir(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let s = e; s < t; s++) {
    const o = n.children[s];
    Rs(r, n.leaf ? i(o) : o);
  }
  return r;
}
function Rs(n, e) {
  return n.minX = Math.min(n.minX, e.minX), n.minY = Math.min(n.minY, e.minY), n.maxX = Math.max(n.maxX, e.maxX), n.maxY = Math.max(n.maxY, e.maxY), n;
}
function rx(n, e) {
  return n.minX - e.minX;
}
function sx(n, e) {
  return n.minY - e.minY;
}
function $l(n) {
  return (n.maxX - n.minX) * (n.maxY - n.minY);
}
function Uo(n) {
  return n.maxX - n.minX + (n.maxY - n.minY);
}
function ox(n, e) {
  return (Math.max(e.maxX, n.maxX) - Math.min(e.minX, n.minX)) * (Math.max(e.maxY, n.maxY) - Math.min(e.minY, n.minY));
}
function ax(n, e) {
  const t = Math.max(n.minX, e.minX), i = Math.max(n.minY, e.minY), r = Math.min(n.maxX, e.maxX), s = Math.min(n.maxY, e.maxY);
  return Math.max(0, r - t) * Math.max(0, s - i);
}
function jl(n, e) {
  return n.minX <= e.minX && n.minY <= e.minY && e.maxX <= n.maxX && e.maxY <= n.maxY;
}
function Bo(n, e) {
  return e.minX <= n.maxX && e.minY <= n.maxY && e.maxX >= n.minX && e.maxY >= n.minY;
}
function Ir(n) {
  return {
    children: n,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Pd(n, e, t, i, r) {
  const s = [e, t];
  for (; s.length; ) {
    if (t = s.pop(), e = s.pop(), t - e <= i) continue;
    const o = e + Math.ceil((t - e) / i / 2) * i;
    zg(n, o, e, t, r), s.push(e, o, o, t);
  }
}
class Id {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new Wg(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const i = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(i), this.items_[q(t)] = i;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const i = new Array(t.length);
    for (let r = 0, s = t.length; r < s; r++) {
      const o = e[r], a = t[r], l = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: a
      };
      i[r] = l, this.items_[q(a)] = l;
    }
    this.rbush_.load(i);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = q(e), i = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(i) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const i = this.items_[q(t)], r = [i.minX, i.minY, i.maxX, i.maxY];
    Vr(r, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(r) {
      return r.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   * @private
   */
  forEach_(e, t) {
    let i;
    for (let r = 0, s = e.length; r < s; r++)
      if (i = t(e[r]), i)
        return i;
    return i;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return er(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return ii(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush<T>} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
class Yg extends Ft {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = Ie(e.projection), this.attributions_ = Ad(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(i, r) {
      t.viewResolver = i, t.viewRejector = r;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = Ad(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function Ad(n) {
  return n ? typeof n == "function" ? n : (Array.isArray(n) || (n = [n]), (e) => n) : null;
}
const ct = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
class ui extends ai {
  /**
   * @param {string} type Type.
   * @param {FeatureType} [feature] Feature.
   * @param {Array<FeatureType>} [features] Features.
   */
  constructor(e, t, i) {
    super(e), this.feature = t, this.features = i;
  }
}
class fo extends Yg {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Gs, this.format_ = e.format || null, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (ge(this.format_, "`format` must be set when `url` is set"), this.loader_ = Rd(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : tx;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new Id() : null, this.loadedExtentsRtree_ = new Id(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let i, r;
    Array.isArray(e.features) ? r = e.features : e.features && (i = e.features, r = i.getArray()), !t && i === void 0 && (i = new En(r)), r !== void 0 && this.addFeaturesInternal(r), i !== void 0 && this.bindFeaturesCollection_(i);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = q(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const i = e.getGeometry();
    if (i) {
      const r = i.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(r, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new ui(ct.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    t instanceof At || (this.featureChangeKeys_[e] = [
      ce(t, ie.CHANGE, this.handleFeatureChange_, this),
      ce(
        t,
        $r.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let i = !0;
    if (t.getId() !== void 0) {
      const r = String(t.getId());
      if (!(r in this.idIndex_))
        this.idIndex_[r] = t;
      else if (t instanceof At) {
        const s = this.idIndex_[r];
        s instanceof At ? Array.isArray(s) ? s.push(t) : this.idIndex_[r] = [s, t] : i = !1;
      } else
        i = !1;
    }
    return i && (ge(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = t), i;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], i = [], r = [];
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s], l = q(a);
      this.addToIndex_(l, a) && i.push(a);
    }
    for (let s = 0, o = i.length; s < o; s++) {
      const a = i[s], l = q(a);
      this.setupChangeEvents_(l, a);
      const c = a.getGeometry();
      if (c) {
        const h = c.getExtent();
        t.push(h), r.push(a);
      } else
        this.nullGeometryFeatures_[l] = a;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, r), this.hasListener(ct.ADDFEATURE))
      for (let s = 0, o = i.length; s < o; s++)
        this.dispatchEvent(
          new ui(ct.ADDFEATURE, i[s])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      ct.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.push(i.feature), t = !1);
      }
    ), this.addEventListener(
      ct.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.remove(i.feature), t = !1);
      }
    ), e.addEventListener(
      Pt.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.addFeature(i.element), t = !1);
      }
    ), e.addEventListener(
      Pt.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.removeFeature(i.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const i in this.featureChangeKeys_)
        this.featureChangeKeys_[i].forEach(Re);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      this.featuresRtree_.forEach((i) => {
        this.removeFeatureInternal(i);
      });
      for (const i in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[i]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new ui(ct.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const i = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(i, function(r) {
      const s = r.getGeometry();
      if (s instanceof At || s.intersectsCoordinate(e))
        return t(r);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(i) {
        const r = i.getGeometry();
        if (r instanceof At || r.intersectsExtent(e)) {
          const s = t(i);
          if (s)
            return s;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with a {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), er(this.nullGeometryFeatures_) || wn(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(i) {
      t.push(i);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const r = eg(e, t);
      return [].concat(
        ...r.map((s) => this.featuresRtree_.getInExtent(s))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType|null} Closest feature (or `null` if none found).
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const i = e[0], r = e[1];
    let s = null;
    const o = [NaN, NaN];
    let a = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || Ns, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(c) {
        if (t(c)) {
          const h = c.getGeometry(), u = a;
          if (a = h instanceof At ? 0 : h.closestPointXY(i, r, o, a), a < u) {
            s = c;
            const d = Math.sqrt(a);
            l[0] = i - d, l[1] = r - d, l[2] = i + d, l[3] = r + d;
          }
        }
      }
    ), s;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      t
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {FeatureType} */
      e.target
    ), i = q(t), r = t.getGeometry();
    if (!r)
      i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[i] = t);
    else {
      const o = r.getExtent();
      i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const s = t.getId();
    if (s !== void 0) {
      const o = s.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[i] = t;
    this.changed(), this.dispatchEvent(
      new ui(ct.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : q(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && er(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, i) {
    const r = this.loadedExtentsRtree_, s = this.strategy_(e, t, i);
    for (let o = 0, a = s.length; o < a; ++o) {
      const l = s[o];
      r.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(h) {
          return Mr(h.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new ui(ct.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        t,
        i,
        /**
         * @param {Array<FeatureType>} features Loaded features
         */
        (h) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new ui(
              ct.FEATURESLOADEND,
              void 0,
              h
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new ui(ct.FEATURESLOADERROR)
          );
        }
      ), r.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  /**
   * @override
   */
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_, i = t.forEachInExtent(e, function(r) {
      if (Vr(r.extent, e))
        return r;
    });
    i && t.remove(i);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(e) {
    let t = !1;
    for (let i = 0, r = e.length; i < r; ++i)
      t = this.removeFeatureInternal(e[i]) || t;
    t && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {boolean} True if the feature was removed, false if it was not found.
   * @protected
   */
  removeFeatureInternal(e) {
    const t = q(e);
    if (!(t in this.uidIndex_))
      return !1;
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e);
    const i = this.featureChangeKeys_[t];
    i == null || i.forEach(Re), delete this.featureChangeKeys_[t];
    const r = e.getId();
    if (r !== void 0) {
      const s = r.toString(), o = this.idIndex_[s];
      o === e ? delete this.idIndex_[s] : Array.isArray(o) && (o.splice(o.indexOf(e), 1), o.length === 1 && (this.idIndex_[s] = o[0]));
    }
    return delete this.uidIndex_[t], this.hasListener(ct.REMOVEFEATURE) && this.dispatchEvent(
      new ui(ct.REMOVEFEATURE, e)
    ), !0;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @private
   */
  removeFromIdIndex_(e) {
    for (const t in this.idIndex_)
      if (this.idIndex_[t] === e) {
        delete this.idIndex_[t];
        break;
      }
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    ge(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(Rd(e, this.format_));
  }
  /**
   * @param {boolean} overlaps The source can have overlapping geometries.
   */
  setOverlaps(e) {
    this.overlaps_ = e, this.changed();
  }
}
class ri {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new ri({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const t = Wh(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      t.ready().then(() => {
        this.patternImage_ = null;
      }), t.getImageState() === le.IDLE && t.load(), t.getImageState() === le.LOADING && (this.patternImage_ = t);
    }
    this.color_ = e;
  }
  /**
   * @return {string} Key of the fill for cache lookup.
   */
  getKey() {
    const e = this.getColor();
    return e ? e instanceof CanvasPattern || e instanceof CanvasGradient ? q(e) : typeof e == "object" && "src" in e ? e.src + ":" + e.offset : an(e).toString() : "";
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class Gt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Gt({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
function Ld(n) {
  return n[0] > 0 && n[1] > 0;
}
function lx(n, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = n[0] * e + 0.5 | 0, t[1] = n[1] * e + 0.5 | 0, t;
}
function Tt(n, e) {
  return Array.isArray(n) ? n : (e === void 0 ? e = [n, n] : (e[0] = n, e[1] = n), e);
}
class el {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = Tt(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new el({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Q();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return Q();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return Q();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Q();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Q();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Q();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Q();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Tt(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    Q();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Q();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    Q();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
class tl extends el {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? le.LOADING : le.LOADED, this.imageState_ === le.LOADING && this.ready().then(() => this.imageState_ = le.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const e = this.getScale(), t = new tl({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const e = this.size_, t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / i[0],
      e[1] / 2 + t[1] / i[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   * @override
   */
  getImage(e) {
    var s, o;
    const t = (s = this.fill_) == null ? void 0 : s.getKey(), i = `${e},${this.angle_},${this.radius},${this.radius2_},${this.points_},${t}` + Object.values(this.renderOptions_).join(",");
    let r = (
      /** @type {HTMLCanvasElement} */
      (o = $t.get(i, null, null)) == null ? void 0 : o.getImage(1)
    );
    if (!r) {
      const a = this.renderOptions_, l = Math.ceil(a.size * e), c = je(l, l);
      this.draw_(a, c, e), r = c.canvas, $t.set(
        i,
        null,
        null,
        new Lg(r, void 0, null, le.LOADED, null)
      );
    }
    return r;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, i) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let r = this.radius, s = this.radius2_ === void 0 ? r : this.radius2_;
    if (r < s) {
      const S = r;
      r = s, s = S;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, l = s * Math.sin(a), c = Math.sqrt(s * s - l * l), h = r - c, u = Math.sqrt(l * l + h * h), d = u / l;
    if (e === "miter" && d <= i)
      return d * t;
    const f = t / 2 / d, g = t / 2 * (h / u), m = Math.sqrt((r + f) * (r + f) + g * g) - r;
    if (this.radius2_ === void 0 || e === "bevel")
      return m * 2;
    const y = r * Math.sin(a), p = Math.sqrt(r * r - y * y), E = s - p, v = Math.sqrt(y * y + E * E) / y;
    if (v <= i) {
      const S = v * t / 2 - s - r;
      return 2 * Math.max(m, S);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = qr, t = Jr, i = 0, r = null, s = 0, o, a = 0;
    this.stroke_ && (o = Tn(this.stroke_.getColor() ?? $s), a = this.stroke_.getWidth() ?? Vs, r = this.stroke_.getLineDash(), s = this.stroke_.getLineDashOffset() ?? 0, t = this.stroke_.getLineJoin() ?? Jr, e = this.stroke_.getLineCap() ?? qr, i = this.stroke_.getMiterLimit() ?? Ys);
    const l = this.calculateLineJoinSize_(t, a, i), c = Math.max(this.radius, this.radius2_ || 0), h = Math.ceil(2 * c + l);
    return {
      strokeStyle: o,
      strokeWidth: a,
      size: h,
      lineCap: e,
      lineDash: r,
      lineDashOffset: s,
      lineJoin: t,
      miterLimit: i
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, i) {
    if (t.scale(i, i), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let r = this.fill_.getColor();
      r === null && (r = It), t.fillStyle = Tn(r), t.fill();
    }
    e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let t;
    if (this.fill_) {
      let i = this.fill_.getColor(), r = 0;
      typeof i == "string" && (i = an(i)), i === null ? r = 1 : Array.isArray(i) && (r = i.length === 4 ? i[3] : 1), r === 0 && (t = je(e.size, e.size), this.drawHitDetectionCanvas_(e, t));
    }
    return t ? t.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const i = this.radius;
    if (t === 1 / 0)
      e.arc(0, 0, i, 0, 2 * Math.PI);
    else {
      const r = this.radius2_ === void 0 ? i : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const s = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let a = 0; a < t; a++) {
        const l = s + a * o, c = a % 2 === 0 ? i : r;
        e.lineTo(c * Math.cos(l), c * Math.sin(l));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = It, t.fill(), e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class nr extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const e = this.getScale(), t = new nr({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius = e, this.render();
  }
}
class wt {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = Od, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new wt({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = Od, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function cx(n) {
  let e;
  if (typeof n == "function")
    e = n;
  else {
    let t;
    Array.isArray(n) ? t = n : (ge(
      typeof /** @type {?} */
      n.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), t = [
      /** @type {Style} */
      n
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let Vl = null;
function $g(n, e) {
  if (!Vl) {
    const t = new ri({
      color: "rgba(255,255,255,0.4)"
    }), i = new Gt({
      color: "#3399CC",
      width: 1.25
    });
    Vl = [
      new wt({
        image: new nr({
          fill: t,
          stroke: i,
          radius: 5
        }),
        fill: t,
        stroke: i
      })
    ];
  }
  return Vl;
}
function Od(n) {
  return n.getGeometry();
}
const hx = "#333";
class Ki {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.keepUpright_ = e.keepUpright, this.scale_ = e.scale, this.scaleArray_ = Tt(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new ri({ color: hx }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Ki({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      keepUpright: this.getKeepUpright(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Determine whether the text can be rendered upside down.
   * @return {boolean|undefined} Keep text upright.
   * @api
   */
  getKeepUpright() {
    return this.keepUpright_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set whether the text can be rendered upside down.
   *
   * @param {boolean} keepUpright Keep text upright.
   * @api
   */
  setKeepUpright(e) {
    this.keepUpright_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Tt(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
const Qe = {
  ANIMATING: 0,
  INTERACTING: 1
}, K = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, zo = [K.FILL], vi = [K.STROKE], Wi = [K.BEGIN_PATH], Md = [K.CLOSE_PATH];
class go extends Og {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(i) {
      return i * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const i = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, s = this.coordinates;
    let o = s.length;
    for (let a = 0, l = e.length; a < l; a += t)
      r[0] = e[a], r[1] = e[a + 1], jr(i, r) && (s[o++] = r[0], s[o++] = r[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, i, r, s, o) {
    const a = this.coordinates;
    let l = a.length;
    const c = this.getBufferedMaxExtent();
    o && (t += r);
    let h = e[t], u = e[t + 1];
    const d = this.tmpCoordinate_;
    let f = !0, g, _, m;
    for (g = t + r; g < i; g += r)
      d[0] = e[g], d[1] = e[g + 1], m = Cc(c, d), m !== _ ? (f && (a[l++] = h, a[l++] = u, f = !1), a[l++] = d[0], a[l++] = d[1]) : m === Je.INTERSECTING ? (a[l++] = d[0], a[l++] = d[1], f = !1) : f = !0, h = d[0], u = d[1], _ = m;
    return (s && f || g === t + r) && (a[l++] = h, a[l++] = u), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, i, r, s) {
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], c = this.appendFlatLineCoordinates(
        e,
        t,
        l,
        r,
        !1,
        !1
      );
      s.push(c), t = l;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCustom(e, t, i, r, s) {
    this.beginGeometry(e, t, s);
    const o = e.getType(), a = e.getStride(), l = this.coordinates.length;
    let c, h, u, d, f;
    switch (o) {
      case "MultiPolygon":
        c = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), d = [];
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        f = 0;
        for (let _ = 0, m = g.length; _ < m; ++_) {
          const y = [];
          f = this.drawCustomCoordinates_(
            c,
            f,
            g[_],
            a,
            y
          ), d.push(y);
        }
        this.instructions.push([
          K.CUSTOM,
          l,
          d,
          e,
          i,
          Fc,
          s
        ]), this.hitDetectionInstructions.push([
          K.CUSTOM,
          l,
          d,
          e,
          r || i,
          Fc,
          s
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        u = [], c = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), f = this.drawCustomCoordinates_(
          c,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          a,
          u
        ), this.instructions.push([
          K.CUSTOM,
          l,
          u,
          e,
          i,
          zs,
          s
        ]), this.hitDetectionInstructions.push([
          K.CUSTOM,
          l,
          u,
          e,
          r || i,
          zs,
          s
        ]);
        break;
      case "LineString":
      case "Circle":
        c = e.getFlatCoordinates(), h = this.appendFlatLineCoordinates(
          c,
          0,
          c.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          i,
          xi,
          s
        ]), this.hitDetectionInstructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          r || i,
          xi,
          s
        ]);
        break;
      case "MultiPoint":
        c = e.getFlatCoordinates(), h = this.appendFlatPointCoordinates(c, a), h > l && (this.instructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          i,
          xi,
          s
        ]), this.hitDetectionInstructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          r || i,
          xi,
          s
        ]));
        break;
      case "Point":
        c = e.getFlatCoordinates(), this.coordinates.push(c[0], c[1]), h = this.coordinates.length, this.instructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          i,
          void 0,
          s
        ]), this.hitDetectionInstructions.push([
          K.CUSTOM,
          l,
          h,
          e,
          r || i,
          void 0,
          s
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, t, i) {
    this.beginGeometryInstruction1_ = [
      K.BEGIN_GEOMETRY,
      t,
      0,
      e,
      i
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      K.BEGIN_GEOMETRY,
      t,
      0,
      e,
      i
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const i = e.length;
    let r, s, o = -1;
    for (t = 0; t < i; ++t)
      r = e[t], s = /** @type {import("./Instruction.js").default} */
      r[0], s == K.END_GEOMETRY ? o = t : s == K.BEGIN_GEOMETRY && (r[2] = t, Qp(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import('../canvas.js').FillStrokeState} [state] State.
   * @return {import('../canvas.js').FillStrokeState} State.
   */
  fillStyleToState(e, t = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (e) {
      const i = e.getColor();
      t.fillPatternScale = i && typeof i == "object" && "src" in i ? this.pixelRatio : 1, t.fillStyle = Tn(
        i || It
      );
    } else
      t.fillStyle = void 0;
    return t;
  }
  /**
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {import("../canvas.js").FillStrokeState} State.
   */
  strokeStyleToState(e, t = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (e) {
      const i = e.getColor();
      t.strokeStyle = Tn(
        i || $s
      );
      const r = e.getLineCap();
      t.lineCap = r !== void 0 ? r : qr;
      const s = e.getLineDash();
      t.lineDash = s ? s.slice() : Zn;
      const o = e.getLineDashOffset();
      t.lineDashOffset = o || qn;
      const a = e.getLineJoin();
      t.lineJoin = a !== void 0 ? a : Jr;
      const l = e.getWidth();
      t.lineWidth = l !== void 0 ? l : Vs;
      const c = e.getMiterLimit();
      t.miterLimit = c !== void 0 ? c : Ys, t.lineWidth > this.maxLineWidth && (this.maxLineWidth = t.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      t.strokeStyle = void 0, t.lineCap = void 0, t.lineDash = null, t.lineDashOffset = void 0, t.lineJoin = void 0, t.lineWidth = void 0, t.miterLimit = void 0;
    return t;
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(e, t) {
    const i = this.state;
    this.fillStyleToState(e, i), this.strokeStyleToState(t, i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, i = [K.SET_FILL_STYLE, t];
    return typeof t != "string" && i.push(e.fillPatternScale), i;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      K.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      e.lineDash ? this.applyPixelRatio(e.lineDash) : null,
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const i = e.fillStyle;
    (typeof i != "string" || e.currentFillStyle != i) && (this.instructions.push(t.call(this, e)), e.currentFillStyle = i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const i = e.strokeStyle, r = e.lineCap, s = e.lineDash, o = e.lineDashOffset, a = e.lineJoin, l = e.lineWidth, c = e.miterLimit;
    (e.currentStrokeStyle != i || e.currentLineCap != r || s != e.currentLineDash && !oi(e.currentLineDash, s) || e.currentLineDashOffset != o || e.currentLineJoin != a || e.currentLineWidth != l || e.currentMiterLimit != c) && (t.call(this, e), e.currentStrokeStyle = i, e.currentLineCap = r, e.currentLineDash = s, e.currentLineDashOffset = o, e.currentLineJoin = a, e.currentLineWidth = l, e.currentMiterLimit = c);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [K.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Xf(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      ni(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class ux extends go {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    super(e, t, i, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPoint(e, t, i) {
    if (!this.image_ || this.maxExtent && !jr(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, t, i);
    const r = e.getFlatCoordinates(), s = e.getStride(), o = this.coordinates.length, a = this.appendFlatPointCoordinates(r, s);
    this.instructions.push([
      K.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      K.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPoint(e, t, i) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t, i);
    const r = e.getFlatCoordinates(), s = [];
    for (let l = 0, c = r.length; l < c; l += e.getStride())
      (!this.maxExtent || jr(this.maxExtent, r.slice(l, l + 2))) && s.push(
        r[l],
        r[l + 1]
      );
    const o = this.coordinates.length, a = this.appendFlatPointCoordinates(s, 2);
    this.instructions.push([
      K.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      K.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setImageStyle(e, t) {
    const i = e.getAnchor(), r = e.getSize(), s = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = e.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = r[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
class dx extends go {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, i, r) {
    const s = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      i,
      r,
      !1,
      !1
    ), a = [
      K.MOVE_TO_LINE_TO,
      s,
      o
    ];
    return this.instructions.push(a), this.hitDetectionInstructions.push(a), i;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawLineString(e, t, i) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t, i), this.hitDetectionInstructions.push(
      [
        K.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        Zn,
        qn
      ],
      Wi
    );
    const a = e.getFlatCoordinates(), l = e.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      l
    ), this.hitDetectionInstructions.push(vi), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiLineString(e, t, i) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t, i), this.hitDetectionInstructions.push(
      [
        K.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        Zn,
        qn
      ],
      Wi
    );
    const a = e.getEnds(), l = e.getFlatCoordinates(), c = e.getStride();
    let h = 0;
    for (let u = 0, d = a.length; u < d; ++u)
      h = this.drawFlatCoordinates_(
        l,
        h,
        /** @type {number} */
        a[u],
        c
      );
    this.hitDetectionInstructions.push(vi), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(vi), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @override
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(vi), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(Wi);
  }
}
class Dd extends go {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, i, r) {
    const s = this.state, o = s.fillStyle !== void 0, a = s.strokeStyle !== void 0, l = i.length;
    this.instructions.push(Wi), this.hitDetectionInstructions.push(Wi);
    for (let c = 0; c < l; ++c) {
      const h = i[c], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
        e,
        t,
        h,
        r,
        !0,
        !a
      ), f = [
        K.MOVE_TO_LINE_TO,
        u,
        d
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), a && (this.instructions.push(Md), this.hitDetectionInstructions.push(Md)), t = h;
    }
    return o && (this.instructions.push(zo), this.hitDetectionInstructions.push(zo)), a && (this.instructions.push(vi), this.hitDetectionInstructions.push(vi)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCircle(e, t, i) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_FILL_STYLE,
      It
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Zn,
      qn
    ]);
    const a = e.getFlatCoordinates(), l = e.getStride(), c = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      l,
      !1,
      !1
    );
    const h = [K.CIRCLE, c];
    this.instructions.push(Wi, h), this.hitDetectionInstructions.push(Wi, h), r.fillStyle !== void 0 && (this.instructions.push(zo), this.hitDetectionInstructions.push(zo)), r.strokeStyle !== void 0 && (this.instructions.push(vi), this.hitDetectionInstructions.push(vi)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPolygon(e, t, i) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_FILL_STYLE,
      It
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Zn,
      qn
    ]);
    const a = e.getEnds(), l = e.getOrientedFlatCoordinates(), c = e.getStride();
    this.drawFlatCoordinatess_(
      l,
      0,
      /** @type {Array<number>} */
      a,
      c
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPolygon(e, t, i) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_FILL_STYLE,
      It
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      K.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Zn,
      qn
    ]);
    const a = e.getEndss(), l = e.getOrientedFlatCoordinates(), c = e.getStride();
    let h = 0;
    for (let u = 0, d = a.length; u < d; ++u)
      h = this.drawFlatCoordinatess_(
        l,
        h,
        a[u],
        c
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let i = 0, r = t.length; i < r; ++i)
        t[i] = Ni(t[i], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    this.updateFillStyle(e, this.createFill), this.updateStrokeStyle(e, this.applyStroke);
  }
}
function fx(n, e, t, i, r) {
  const s = [];
  let o = t, a = 0, l = e.slice(t, 2);
  for (; a < n && o + r < i; ) {
    const [c, h] = l.slice(-2), u = e[o + r], d = e[o + r + 1], f = Math.sqrt(
      (u - c) * (u - c) + (d - h) * (d - h)
    );
    if (a += f, a >= n) {
      const g = (n - a + f) / f, _ = Nt(c, u, g), m = Nt(h, d, g);
      l.push(_, m), s.push(l), l = [_, m], a == n && (o += r), a = 0;
    } else if (a < n)
      l.push(
        e[o + r],
        e[o + r + 1]
      ), o += r;
    else {
      const g = f - a, _ = Nt(c, u, g / f), m = Nt(h, d, g / f);
      l.push(_, m), s.push(l), l = [_, m], a = 0, o += r;
    }
  }
  return a > 0 && s.push(l), s;
}
function gx(n, e, t, i, r) {
  let s = t, o = t, a = 0, l = 0, c = t, h, u, d, f, g, _, m, y, p, E;
  for (u = t; u < i; u += r) {
    const x = e[u], v = e[u + 1];
    g !== void 0 && (p = x - g, E = v - _, f = Math.sqrt(p * p + E * E), m !== void 0 && (l += d, h = Math.acos((m * p + y * E) / (d * f)), h > n && (l > a && (a = l, s = c, o = u), l = 0, c = u - r)), d = f, m = p, y = E), g = x, _ = v;
  }
  return l += f, l > a ? [c, u] : [s, o];
}
const va = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class mx extends go {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    super(e, t, i, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[It] = { fillStyle: It }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawText(e, t, i) {
    const r = this.textFillState_, s = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !r && !s)
      return;
    const a = this.coordinates;
    let l = a.length;
    const c = e.getType();
    let h = null, u = e.getStride();
    if (o.placement === "line" && (c == "LineString" || c == "MultiLineString" || c == "Polygon" || c == "MultiPolygon")) {
      if (!vt(this.maxExtent, e.getExtent()))
        return;
      let d;
      if (h = e.getFlatCoordinates(), c == "LineString")
        d = [h.length];
      else if (c == "MultiLineString")
        d = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (c == "Polygon")
        d = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (c == "MultiPolygon") {
        const m = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        d = [];
        for (let y = 0, p = m.length; y < p; ++y)
          d.push(m[y][0]);
      }
      this.beginGeometry(e, t, i);
      const f = o.repeat, g = f ? void 0 : o.textAlign;
      let _ = 0;
      for (let m = 0, y = d.length; m < y; ++m) {
        let p;
        f ? p = fx(
          f * this.resolution,
          h,
          _,
          d[m],
          u
        ) : p = [h.slice(_, d[m])];
        for (let E = 0, x = p.length; E < x; ++E) {
          const v = p[E];
          let S = 0, w = v.length;
          if (g == null) {
            const P = gx(
              o.maxAngle,
              v,
              0,
              v.length,
              2
            );
            S = P[0], w = P[1];
          }
          for (let P = S; P < w; P += u)
            a.push(v[P], v[P + 1]);
          const b = a.length;
          _ = d[m], this.drawChars_(l, b), l = b;
        }
      }
      this.endGeometry(t);
    } else {
      let d = o.overflow ? null : [];
      switch (c) {
        case "Point":
        case "MultiPoint":
          h = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          h = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          h = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          h = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), u = 2;
          break;
        case "Polygon":
          h = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), o.overflow || d.push(h[2] / this.resolution), u = 3;
          break;
        case "MultiPolygon":
          const x = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          h = [];
          for (let v = 0, S = x.length; v < S; v += 3)
            o.overflow || d.push(x[v + 2] / this.resolution), h.push(x[v], x[v + 1]);
          if (h.length === 0)
            return;
          u = 2;
          break;
      }
      const f = this.appendFlatPointCoordinates(h, u);
      if (f === l)
        return;
      if (d && (f - l) / 2 !== h.length / u) {
        let x = l / 2;
        d = d.filter((v, S) => {
          const w = a[(x + S) * 2] === h[S * u] && a[(x + S) * 2 + 1] === h[S * u + 1];
          return w || --x, w;
        });
      }
      this.saveTextStates_();
      const g = o.backgroundFill ? this.createFill(this.fillStyleToState(o.backgroundFill)) : null, _ = o.backgroundStroke ? this.createStroke(this.strokeStyleToState(o.backgroundStroke)) : null;
      this.beginGeometry(e, t, i);
      let m = o.padding;
      if (m != zi && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let x = o.padding[0], v = o.padding[1], S = o.padding[2], w = o.padding[3];
        o.scale[0] < 0 && (v = -v, w = -w), o.scale[1] < 0 && (x = -x, S = -S), m = [x, v, S, w];
      }
      const y = this.pixelRatio;
      this.instructions.push([
        K.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        m == zi ? zi : m.map(function(x) {
          return x * y;
        }),
        g,
        _,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]);
      const p = 1 / y, E = g ? g.slice(0) : null;
      E && (E[1] = It), this.hitDetectionInstructions.push([
        K.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [p, p],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        m,
        E,
        _,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? It : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, i = this.textFillState_, r = this.strokeKey_;
    e && (r in this.strokeStates || (this.strokeStates[r] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const s = this.textKey_;
    s in this.textStates || (this.textStates[s] = {
      font: t.font,
      textAlign: t.textAlign || js,
      justify: t.justify,
      textBaseline: t.textBaseline || _a,
      scale: t.scale
    });
    const o = this.fillKey_;
    i && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: i.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const i = this.textStrokeState_, r = this.textState_, s = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, c = va[r.textBaseline], h = this.textOffsetY_ * l, u = this.text_, d = i ? i.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
    this.instructions.push([
      K.DRAW_CHARS,
      e,
      t,
      c,
      r.overflow,
      a,
      r.maxAngle,
      l,
      h,
      s,
      d * l,
      u,
      o,
      1,
      this.declutterMode_,
      this.textKeepUpright_
    ]), this.hitDetectionInstructions.push([
      K.DRAW_CHARS,
      e,
      t,
      c,
      r.overflow,
      a && It,
      r.maxAngle,
      l,
      h,
      s,
      d * l,
      u,
      o,
      1 / l,
      this.declutterMode_,
      this.textKeepUpright_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setTextStyle(e, t) {
    let i, r, s;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (r = this.textFillState_, r || (r = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = r), r.fillStyle = Tn(
        o.getColor() || It
      )) : (r = null, this.textFillState_ = r);
      const a = e.getStroke();
      if (!a)
        s = null, this.textStrokeState_ = s;
      else {
        s = this.textStrokeState_, s || (s = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = s);
        const _ = a.getLineDash(), m = a.getLineDashOffset(), y = a.getWidth(), p = a.getMiterLimit();
        s.lineCap = a.getLineCap() || qr, s.lineDash = _ ? _.slice() : Zn, s.lineDashOffset = m === void 0 ? qn : m, s.lineJoin = a.getLineJoin() || Jr, s.lineWidth = y === void 0 ? Vs : y, s.miterLimit = p === void 0 ? Ys : p, s.strokeStyle = Tn(
          a.getColor() || $s
        );
      }
      i = this.textState_;
      const l = e.getFont() || Mg;
      N0(l);
      const c = e.getScaleArray();
      i.overflow = e.getOverflow(), i.font = l, i.maxAngle = e.getMaxAngle(), i.placement = e.getPlacement(), i.textAlign = e.getTextAlign(), i.repeat = e.getRepeat(), i.justify = e.getJustify(), i.textBaseline = e.getTextBaseline() || _a, i.backgroundFill = e.getBackgroundFill(), i.backgroundStroke = e.getBackgroundStroke(), i.padding = e.getPadding() || zi, i.scale = c === void 0 ? [1, 1] : c;
      const h = e.getOffsetX(), u = e.getOffsetY(), d = e.getRotateWithView(), f = e.getKeepUpright(), g = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = h === void 0 ? 0 : h, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textKeepUpright_ = f === void 0 ? !0 : f, this.textRotation_ = g === void 0 ? 0 : g, this.strokeKey_ = s ? (typeof s.strokeStyle == "string" ? s.strokeStyle : q(s.strokeStyle)) + s.lineCap + s.lineDashOffset + "|" + s.lineWidth + s.lineJoin + s.miterLimit + "[" + s.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = r && r.fillStyle ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + q(r.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const _x = {
  Circle: Dd,
  Default: go,
  Image: ux,
  LineString: dx,
  Polygon: Dd,
  Text: mx
};
class px {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, r) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = r, this.resolution_ = i, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const i = this.buildersByZIndex_[t];
      for (const r in i) {
        const s = i[r].finish();
        e[t][r] = s;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const i = e !== void 0 ? e.toString() : "0";
    let r = this.buildersByZIndex_[i];
    r === void 0 && (r = {}, this.buildersByZIndex_[i] = r);
    let s = r[t];
    if (s === void 0) {
      const o = _x[t];
      s = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), r[t] = s;
    }
    return s;
  }
}
function yx(n, e, t, i, r, s, o, a, l, c, h, u, d = !0) {
  let f = n[e], g = n[e + 1], _ = 0, m = 0, y = 0, p = 0;
  function E() {
    _ = f, m = g, e += i, f = n[e], g = n[e + 1], p += y, y = Math.sqrt((f - _) * (f - _) + (g - m) * (g - m));
  }
  do
    E();
  while (e < t - i && p + y < s);
  let x = y === 0 ? 0 : (s - p) / y;
  const v = Nt(_, f, x), S = Nt(m, g, x), w = e - i, b = p, P = s + a * l(c, r, h);
  for (; e < t - i && p + y < P; )
    E();
  x = y === 0 ? 0 : (P - p) / y;
  const O = Nt(_, f, x), N = Nt(m, g, x);
  let k = !1;
  if (d)
    if (u) {
      const F = [v, S, O, N];
      gg(F, 0, 4, 2, u, F, F), k = F[0] > F[2];
    } else
      k = v > O;
  const D = Math.PI, U = [], X = w + i === e;
  e = w, y = 0, p = b, f = n[e], g = n[e + 1];
  let I;
  if (X) {
    E(), I = Math.atan2(g - m, f - _), k && (I += I > 0 ? -D : D);
    const F = (O + v) / 2, B = (N + S) / 2;
    return U[0] = [F, B, (P - s) / 2, I, r], U;
  }
  r = r.replace(/\n/g, " ");
  for (let F = 0, B = r.length; F < B; ) {
    E();
    let $ = Math.atan2(g - m, f - _);
    if (k && ($ += $ > 0 ? -D : D), I !== void 0) {
      let Ce = $ - I;
      if (Ce += Ce > D ? -2 * D : Ce < -D ? 2 * D : 0, Math.abs(Ce) > o)
        return null;
    }
    I = $;
    const H = F;
    let re = 0;
    for (; F < B; ++F) {
      const Ce = k ? B - F - 1 : F, nt = a * l(c, r[Ce], h);
      if (e + i < t && p + y < s + re + nt / 2)
        break;
      re += nt;
    }
    if (F === H)
      continue;
    const A = k ? r.substring(B - H, B - F) : r.substring(H, F);
    x = y === 0 ? 0 : (s + re / 2 - p) / y;
    const Fe = Nt(_, f, x), ze = Nt(m, g, x);
    U.push([Fe, ze, re / 2, $, A]), s += re;
  }
  return U;
}
class jg {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    Jt(this, "pushMethodArgs_", (...e) => (this.push_(e), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(ma(), {
      get: (e, t) => {
        if (typeof /** @type {*} */
        ma()[t] == "function")
          return this.push_(t), this.pushMethodArgs_;
      },
      set: (e, t, i) => (this.push_(t, i), !0)
    });
  }
  /**
   * @param {...*} args Arguments to push to the instructions array.
   * @private
   */
  push_(...e) {
    const t = this.instructions_, i = this.zIndex + this.offset_;
    t[i] || (t[i] = []), t[i].push(...e);
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(e) {
    this.push_(e);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((t) => {
      for (let i = 0, r = t.length; i < r; ++i) {
        const s = t[i];
        if (typeof s == "function") {
          s(e);
          continue;
        }
        const o = t[++i];
        if (typeof /** @type {*} */
        e[s] == "function")
          e[s](...o);
        else {
          if (typeof o == "function") {
            e[s] = o(e);
            continue;
          }
          e[s] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const xr = St(), di = [], kn = [], Nn = [], fi = [];
function Fd(n) {
  return n[3].declutterBox;
}
const kd = new RegExp(
  /* eslint-disable prettier/prettier */
  "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
  /* eslint-enable prettier/prettier */
);
function Xl(n, e) {
  return e === "start" ? e = kd.test(n) ? "right" : "left" : e === "end" && (e = kd.test(n) ? "left" : "right"), va[e];
}
function xx(n, e, t) {
  return t > 0 && n.push(`
`, ""), n.push(e, ""), n;
}
function vx(n, e, t) {
  return t % 2 === 0 && (n += e), n;
}
class Ex {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, t, i, r, s) {
    this.overlaps = i, this.pixelRatio = t, this.resolution = e, this.alignAndScaleFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = Ke(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = s ? new jg() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, i, r) {
    const s = e + t + i + r;
    if (this.labels_[s])
      return this.labels_[s];
    const o = r ? this.strokeStates[r] : null, a = i ? this.fillStates[i] : null, l = this.textStates[t], c = this.pixelRatio, h = [
      l.scale[0] * c,
      l.scale[1] * c
    ], u = l.justify ? va[l.justify] : Xl(
      Array.isArray(e) ? e[0] : e,
      l.textAlign || js
    ), d = r && o.lineWidth ? o.lineWidth : 0, f = Array.isArray(e) ? e : String(e).split(`
`).reduce(xx, []), { width: g, height: _, widths: m, heights: y, lineWidths: p } = U0(
      l,
      f
    ), E = g + d, x = [], v = (E + 2) * h[0], S = (_ + d) * h[1], w = {
      width: v < 0 ? Math.floor(v) : Math.ceil(v),
      height: S < 0 ? Math.floor(S) : Math.ceil(S),
      contextInstructions: x
    };
    (h[0] != 1 || h[1] != 1) && x.push("scale", h), r && (x.push("strokeStyle", o.strokeStyle), x.push("lineWidth", d), x.push("lineCap", o.lineCap), x.push("lineJoin", o.lineJoin), x.push("miterLimit", o.miterLimit), x.push("setLineDash", [o.lineDash]), x.push("lineDashOffset", o.lineDashOffset)), i && x.push("fillStyle", a.fillStyle), x.push("textBaseline", "middle"), x.push("textAlign", "center");
    const b = 0.5 - u;
    let P = u * E + b * d;
    const O = [], N = [];
    let k = 0, D = 0, U = 0, X = 0, I;
    for (let F = 0, B = f.length; F < B; F += 2) {
      const $ = f[F];
      if ($ === `
`) {
        D += k, k = 0, P = u * E + b * d, ++X;
        continue;
      }
      const H = f[F + 1] || l.font;
      H !== I && (r && O.push("font", H), i && N.push("font", H), I = H), k = Math.max(k, y[U]);
      const re = [
        $,
        P + b * m[U] + u * (m[U] - p[X]),
        0.5 * (d + k) + D
      ];
      P += m[U], r && O.push("strokeText", re), i && N.push("fillText", re), ++U;
    }
    return Array.prototype.push.apply(x, O), Array.prototype.push.apply(x, N), this.labels_[s] = w, w;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, i, r, s, o, a) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, i), e.lineTo.apply(e, r), e.lineTo.apply(e, s), e.lineTo.apply(e, t), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], e.fillStyle = /** @type {string} */
    o[1], this.fill_(e)), a && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      a
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, i, r, s, o, a, l, c, h, u, d, f, g, _, m) {
    a *= d[0], l *= d[1];
    let y = i - a, p = r - l;
    const E = s + c > e ? e - c : s, x = o + h > t ? t - h : o, v = g[3] + E * d[0] + g[1], S = g[0] + x * d[1] + g[2], w = y - g[3], b = p - g[0];
    (_ || u !== 0) && (di[0] = w, fi[0] = w, di[1] = b, kn[1] = b, kn[0] = w + v, Nn[0] = kn[0], Nn[1] = b + S, fi[1] = Nn[1]);
    let P;
    return u !== 0 ? (P = sn(
      Ke(),
      i,
      r,
      1,
      1,
      u,
      -i,
      -r
    ), Ue(P, di), Ue(P, kn), Ue(P, Nn), Ue(P, fi), ii(
      Math.min(di[0], kn[0], Nn[0], fi[0]),
      Math.min(di[1], kn[1], Nn[1], fi[1]),
      Math.max(di[0], kn[0], Nn[0], fi[0]),
      Math.max(di[1], kn[1], Nn[1], fi[1]),
      xr
    )) : ii(
      Math.min(w, w + v),
      Math.min(b, b + S),
      Math.max(w, w + v),
      Math.max(b, b + S),
      xr
    ), f && (y = Math.round(y), p = Math.round(p)), {
      drawImageX: y,
      drawImageY: p,
      drawImageW: E,
      drawImageH: x,
      originX: c,
      originY: h,
      declutterBox: {
        minX: xr[0],
        minY: xr[1],
        maxX: xr[2],
        maxY: xr[3],
        value: m
      },
      canvasTransform: P,
      scale: d
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, i, r, s, o, a) {
    const l = !!(o || a), c = r.declutterBox, h = a ? a[2] * r.scale[0] / 2 : 0;
    return c.minX - h <= t[0] && c.maxX + h >= 0 && c.minY - h <= t[1] && c.maxY + h >= 0 && (l && this.replayTextBackground_(
      e,
      di,
      kn,
      Nn,
      fi,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      a
    ), B0(
      e,
      r.canvasTransform,
      s,
      i,
      r.originX,
      r.originY,
      r.drawImageW,
      r.drawImageH,
      r.drawImageX,
      r.drawImageY,
      r.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const t = this.alignAndScaleFill_;
    if (t) {
      const i = Ue(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
      e.save(), e.translate(i[0] % r, i[1] % r), t !== 1 && e.scale(t, t), e.rotate(this.viewRotation_);
    }
    e.fill(), t && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], t[1] && (e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    ));
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, i, r) {
    const s = this.textStates[t], o = this.createLabel(e, t, r, i), a = this.strokeStates[i], l = this.pixelRatio, c = Xl(
      Array.isArray(e) ? e[0] : e,
      s.textAlign || js
    ), h = va[s.textBaseline || _a], u = a && a.lineWidth ? a.lineWidth : 0, d = o.width / l - 2 * s.scale[0], f = c * d + 2 * (0.5 - c) * u, g = h * o.height / l + 2 * (0.5 - h) * u;
    return {
      label: o,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, i, r, s, o, a, l) {
    const c = this.zIndexContext_;
    let h;
    this.pixelCoordinates_ && oi(i, this.renderedTransform_) ? h = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), h = Sn(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      i,
      this.pixelCoordinates_
    ), fg(this.renderedTransform_, i));
    let u = 0;
    const d = r.length;
    let f = 0, g, _, m, y, p, E, x, v, S, w, b, P, O, N = 0, k = 0;
    const D = this.coordinateCache_, U = this.viewRotation_, X = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, I = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: U
      }
    ), F = this.instructions != r || this.overlaps ? 0 : 200;
    let B, $, H, re;
    for (; u < d; ) {
      const A = r[u];
      switch (
        /** @type {import("./Instruction.js").default} */
        A[0]
      ) {
        case K.BEGIN_GEOMETRY:
          B = /** @type {import("../../Feature.js").FeatureLike} */
          A[1], re = A[3], B.getGeometry() ? a !== void 0 && !vt(a, re.getExtent()) ? u = /** @type {number} */
          A[2] + 1 : ++u : u = /** @type {number} */
          A[2], c && (c.zIndex = A[4]);
          break;
        case K.BEGIN_PATH:
          N > F && (this.fill_(e), N = 0), k > F && (e.stroke(), k = 0), !N && !k && (e.beginPath(), p = NaN, E = NaN), ++u;
          break;
        case K.CIRCLE:
          f = /** @type {number} */
          A[1];
          const ze = h[f], Ce = h[f + 1], nt = h[f + 2], We = h[f + 3], ft = nt - ze, gt = We - Ce, qe = Math.sqrt(ft * ft + gt * gt);
          e.moveTo(ze + qe, Ce), e.arc(ze, Ce, qe, 0, 2 * Math.PI, !0), ++u;
          break;
        case K.CLOSE_PATH:
          e.closePath(), ++u;
          break;
        case K.CUSTOM:
          f = /** @type {number} */
          A[1], g = A[2];
          const dr = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            A[3]
          ), fr = A[4], Ai = A[5];
          I.geometry = dr, I.feature = B, u in D || (D[u] = []);
          const In = D[u];
          Ai ? Ai(h, f, g, 2, In) : (In[0] = h[f], In[1] = h[f + 1], In.length = 2), c && (c.zIndex = A[6]), fr(In, I), ++u;
          break;
        case K.DRAW_IMAGE:
          f = /** @type {number} */
          A[1], g = /** @type {number} */
          A[2], S = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          A[3], _ = /** @type {number} */
          A[4], m = /** @type {number} */
          A[5];
          let it = (
            /** @type {number} */
            A[6]
          );
          const ot = (
            /** @type {number} */
            A[7]
          ), An = (
            /** @type {number} */
            A[8]
          ), Ln = (
            /** @type {number} */
            A[9]
          ), fn = (
            /** @type {boolean} */
            A[10]
          );
          let On = (
            /** @type {number} */
            A[11]
          );
          const hi = (
            /** @type {import("../../size.js").Size} */
            A[12]
          );
          let gn = (
            /** @type {number} */
            A[13]
          );
          y = A[14] || "declutter";
          const Ye = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            A[15]
          );
          if (!S && A.length >= 20) {
            w = /** @type {string} */
            A[19], b = /** @type {string} */
            A[20], P = /** @type {string} */
            A[21], O = /** @type {string} */
            A[22];
            const mt = this.drawLabelWithPointPlacement_(
              w,
              b,
              P,
              O
            );
            S = mt.label, A[3] = S;
            const Fn = (
              /** @type {number} */
              A[23]
            );
            _ = (mt.anchorX - Fn) * this.pixelRatio, A[4] = _;
            const _t = (
              /** @type {number} */
              A[24]
            );
            m = (mt.anchorY - _t) * this.pixelRatio, A[5] = m, it = S.height, A[6] = it, gn = S.width, A[13] = gn;
          }
          let os;
          A.length > 25 && (os = /** @type {number} */
          A[25]);
          let gr, Li, Oi;
          A.length > 17 ? (gr = /** @type {Array<number>} */
          A[16], Li = /** @type {Array<*>} */
          A[17], Oi = /** @type {Array<*>} */
          A[18]) : (gr = zi, Li = null, Oi = null), fn && X ? On += U : !fn && !X && (On -= U);
          let Pl = 0;
          for (; f < g; f += 2) {
            if (os && os[Pl++] < gn / this.pixelRatio)
              continue;
            const mt = this.calculateImageOrLabelDimensions_(
              S.width,
              S.height,
              h[f],
              h[f + 1],
              gn,
              it,
              _,
              m,
              An,
              Ln,
              On,
              hi,
              s,
              gr,
              !!Li || !!Oi,
              B
            ), Fn = [
              e,
              t,
              S,
              mt,
              ot,
              Li,
              Oi
            ];
            if (l) {
              let _t, kt, bt;
              if (Ye) {
                const Pe = g - f;
                if (!Ye[Pe]) {
                  Ye[Pe] = { args: Fn, declutterMode: y };
                  continue;
                }
                const rt = Ye[Pe];
                _t = rt.args, kt = rt.declutterMode, delete Ye[Pe], bt = Fd(_t);
              }
              let Zt, zt;
              if (_t && (kt !== "declutter" || !l.collides(bt)) && (Zt = !0), (y !== "declutter" || !l.collides(mt.declutterBox)) && (zt = !0), kt === "declutter" && y === "declutter") {
                const Pe = Zt && zt;
                Zt = Pe, zt = Pe;
              }
              Zt && (kt !== "none" && l.insert(bt), this.replayImageOrLabel_.apply(this, _t)), zt && (y !== "none" && l.insert(mt.declutterBox), this.replayImageOrLabel_.apply(this, Fn));
            } else
              this.replayImageOrLabel_.apply(this, Fn);
          }
          ++u;
          break;
        case K.DRAW_CHARS:
          const as = (
            /** @type {number} */
            A[1]
          ), ls = (
            /** @type {number} */
            A[2]
          ), cs = (
            /** @type {number} */
            A[3]
          ), Il = (
            /** @type {number} */
            A[4]
          );
          O = /** @type {string} */
          A[5];
          const Al = (
            /** @type {number} */
            A[6]
          ), Po = (
            /** @type {number} */
            A[7]
          ), Io = (
            /** @type {number} */
            A[8]
          );
          P = /** @type {string} */
          A[9];
          const hs = (
            /** @type {number} */
            A[10]
          );
          w = /** @type {string|Array<string>} */
          A[11], Array.isArray(w) && (w = w.reduce(vx, "")), b = /** @type {string} */
          A[12];
          const Ao = [
            /** @type {number} */
            A[13],
            /** @type {number} */
            A[13]
          ];
          y = A[14] || "declutter";
          const us = (
            /** @type {boolean} */
            A[15]
          ), mr = this.textStates[b], Bt = mr.font, Mn = [
            mr.scale[0] * Po,
            mr.scale[1] * Po
          ];
          let Dn;
          Bt in this.widths_ ? Dn = this.widths_[Bt] : (Dn = {}, this.widths_[Bt] = Dn);
          const ds = Nh(h, as, ls, 2), Lo = Math.abs(Mn[0]) * wd(Bt, w, Dn);
          if (Il || Lo <= ds) {
            const mt = this.textStates[b].textAlign, Fn = (ds - Lo) * Xl(w, mt), _t = yx(
              h,
              as,
              ls,
              2,
              w,
              Fn,
              Al,
              Math.abs(Mn[0]),
              wd,
              Bt,
              Dn,
              X ? 0 : this.viewRotation_,
              us
            );
            e: if (_t) {
              const kt = [];
              let bt, Zt, zt, Pe, rt;
              if (P)
                for (bt = 0, Zt = _t.length; bt < Zt; ++bt) {
                  rt = _t[bt], zt = /** @type {string} */
                  rt[4], Pe = this.createLabel(zt, b, "", P), _ = /** @type {number} */
                  rt[2] + (Mn[0] < 0 ? -hs : hs), m = cs * Pe.height + (0.5 - cs) * 2 * hs * Mn[1] / Mn[0] - Io;
                  const qt = this.calculateImageOrLabelDimensions_(
                    Pe.width,
                    Pe.height,
                    rt[0],
                    rt[1],
                    Pe.width,
                    Pe.height,
                    _,
                    m,
                    0,
                    0,
                    rt[3],
                    Ao,
                    !1,
                    zi,
                    !1,
                    B
                  );
                  if (l && y === "declutter" && l.collides(qt.declutterBox))
                    break e;
                  kt.push([
                    e,
                    t,
                    Pe,
                    qt,
                    1,
                    null,
                    null
                  ]);
                }
              if (O)
                for (bt = 0, Zt = _t.length; bt < Zt; ++bt) {
                  rt = _t[bt], zt = /** @type {string} */
                  rt[4], Pe = this.createLabel(zt, b, O, ""), _ = /** @type {number} */
                  rt[2], m = cs * Pe.height - Io;
                  const qt = this.calculateImageOrLabelDimensions_(
                    Pe.width,
                    Pe.height,
                    rt[0],
                    rt[1],
                    Pe.width,
                    Pe.height,
                    _,
                    m,
                    0,
                    0,
                    rt[3],
                    Ao,
                    !1,
                    zi,
                    !1,
                    B
                  );
                  if (l && y === "declutter" && l.collides(qt.declutterBox))
                    break e;
                  kt.push([
                    e,
                    t,
                    Pe,
                    qt,
                    1,
                    null,
                    null
                  ]);
                }
              l && y !== "none" && l.load(kt.map(Fd));
              for (let qt = 0, Ll = kt.length; qt < Ll; ++qt)
                this.replayImageOrLabel_.apply(this, kt[qt]);
            }
          }
          ++u;
          break;
        case K.END_GEOMETRY:
          if (o !== void 0) {
            B = /** @type {import("../../Feature.js").FeatureLike} */
            A[1];
            const mt = o(
              B,
              re,
              y
            );
            if (mt)
              return mt;
          }
          ++u;
          break;
        case K.FILL:
          F ? N++ : this.fill_(e), ++u;
          break;
        case K.MOVE_TO_LINE_TO:
          for (f = /** @type {number} */
          A[1], g = /** @type {number} */
          A[2], $ = h[f], H = h[f + 1], e.moveTo($, H), p = $ + 0.5 | 0, E = H + 0.5 | 0, f += 2; f < g; f += 2)
            $ = h[f], H = h[f + 1], x = $ + 0.5 | 0, v = H + 0.5 | 0, (f == g - 2 || x !== p || v !== E) && (e.lineTo($, H), p = x, E = v);
          ++u;
          break;
        case K.SET_FILL_STYLE:
          this.alignAndScaleFill_ = A[2], N && (this.fill_(e), N = 0, k && (e.stroke(), k = 0)), e.fillStyle = A[1], ++u;
          break;
        case K.SET_STROKE_STYLE:
          k && (e.stroke(), k = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            A
          ), ++u;
          break;
        case K.STROKE:
          F ? k++ : e.stroke(), ++u;
          break;
        default:
          ++u;
          break;
      }
    }
    N && this.fill_(e), k && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   */
  execute(e, t, i, r, s, o) {
    this.viewRotation_ = r, this.execute_(
      e,
      t,
      i,
      this.instructions,
      s,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, i, r, s) {
    return this.viewRotation_ = i, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      t,
      this.hitDetectionInstructions,
      !0,
      r,
      s
    );
  }
}
const Gi = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], Vg = ["Image", "Text"], Tx = Gi.filter(
  (n) => !Vg.includes(n)
);
class wx {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, t, i, r, s, o, a) {
    this.maxExtent_ = e, this.overlaps_ = r, this.pixelRatio_ = i, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Ke(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(s, a);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const i = this.getClipCoords(t);
    e.beginPath(), e.moveTo(i[0], i[1]), e.lineTo(i[2], i[3]), e.lineTo(i[4], i[5]), e.lineTo(i[6], i[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, t) {
    for (const i in e) {
      let r = this.executorsByZIndex_[i];
      r === void 0 && (r = {}, this.executorsByZIndex_[i] = r);
      const s = e[i];
      for (const o in s) {
        const a = s[o];
        r[o] = new Ex(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a,
          t
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const i = this.executorsByZIndex_[t];
      for (let r = 0, s = e.length; r < s; ++r)
        if (e[r] in i)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, r, s, o) {
    r = Math.round(r);
    const a = r * 2 + 1, l = sn(
      this.hitDetectionTransform_,
      r + 0.5,
      r + 0.5,
      1 / t,
      -1 / t,
      -i,
      -e[0],
      -e[1]
    ), c = !this.hitDetectionContext_;
    c && (this.hitDetectionContext_ = je(
      a,
      a
    ));
    const h = this.hitDetectionContext_;
    h.canvas.width !== a || h.canvas.height !== a ? (h.canvas.width = a, h.canvas.height = a) : c || h.clearRect(0, 0, a, a);
    let u;
    this.renderBuffer_ !== void 0 && (u = St(), As(u, e), ni(
      u,
      t * (this.renderBuffer_ + r),
      u
    ));
    const d = Sx(r);
    let f;
    function g(v, S, w) {
      const b = h.getImageData(
        0,
        0,
        a,
        a
      ).data;
      for (let P = 0, O = d.length; P < O; P++)
        if (b[d[P]] > 0) {
          if (!o || w === "none" || f !== "Image" && f !== "Text" || o.includes(v)) {
            const N = (d[P] - 3) / 4, k = r - N % a, D = r - (N / a | 0), U = s(v, S, k * k + D * D);
            if (U)
              return U;
          }
          h.clearRect(0, 0, a, a);
          break;
        }
    }
    const _ = Object.keys(this.executorsByZIndex_).map(Number);
    _.sort(Kn);
    let m, y, p, E, x;
    for (m = _.length - 1; m >= 0; --m) {
      const v = _[m].toString();
      for (p = this.executorsByZIndex_[v], y = Gi.length - 1; y >= 0; --y)
        if (f = Gi[y], E = p[f], E !== void 0 && (x = E.executeHitDetection(
          h,
          l,
          i,
          g,
          u
        ), x))
          return x;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const i = t[0], r = t[1], s = t[2], o = t[3], a = [i, r, i, o, s, o, s, r];
    return Sn(a, 0, 8, 2, e, a), a;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return er(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, t, i, r, s, o, a) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(a ? Jp : Kn), o = o || Gi;
    const c = Gi.length;
    for (let h = 0, u = l.length; h < u; ++h) {
      const d = l[h].toString(), f = this.executorsByZIndex_[d];
      for (let g = 0, _ = o.length; g < _; ++g) {
        const m = o[g], y = f[m];
        if (y !== void 0) {
          const p = a === null ? void 0 : y.getZIndexContext(), E = p ? p.getContext() : e, x = this.maxExtent_ && m !== "Image" && m !== "Text";
          if (x && (E.save(), this.clip(E, i)), !p || m === "Text" || m === "Image" ? y.execute(
            E,
            t,
            i,
            r,
            s,
            a
          ) : p.pushFunction(
            (v) => y.execute(
              v,
              t,
              i,
              r,
              s,
              a
            )
          ), x && E.restore(), p) {
            p.offset();
            const v = l[h] * c + Gi.indexOf(m);
            this.deferredZIndexContexts_[v] || (this.deferredZIndexContexts_[v] = []), this.deferredZIndexContexts_[v].push(p);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const e = this.deferredZIndexContexts_, t = Object.keys(e).map(Number).sort(Kn);
    for (let i = 0, r = t.length; i < r; ++i)
      e[t[i]].forEach((s) => {
        s.draw(this.renderedContext_), s.clear();
      }), e[t[i]].length = 0;
  }
}
const Hl = {};
function Sx(n) {
  if (Hl[n] !== void 0)
    return Hl[n];
  const e = n * 2 + 1, t = n * n, i = new Array(t + 1);
  for (let s = 0; s <= n; ++s)
    for (let o = 0; o <= n; ++o) {
      const a = s * s + o * o;
      if (a > t)
        break;
      let l = i[a];
      l || (l = [], i[a] = l), l.push(((n + s) * e + (n + o)) * 4 + 3), s > 0 && l.push(((n - s) * e + (n + o)) * 4 + 3), o > 0 && (l.push(((n + s) * e + (n - o)) * 4 + 3), s > 0 && l.push(((n - s) * e + (n - o)) * 4 + 3));
    }
  const r = [];
  for (let s = 0, o = i.length; s < o; ++s)
    i[s] && r.push(...i[s]);
  return Hl[n] = r, r;
}
function Nd(n, e, t, i) {
  return t !== void 0 && i !== void 0 ? [t / n, i / e] : t !== void 0 ? t / n : i !== void 0 ? i / e : 1;
}
class mo extends el {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, i = e.rotation !== void 0 ? e.rotation : 0, r = e.scale !== void 0 ? e.scale : 1, s = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: i,
      scale: r,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: s,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    let a = e.src;
    ge(
      !(a !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
    o.src || q(o)), ge(
      a !== void 0 && a.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), ge(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let l;
    if (e.src !== void 0 ? l = le.IDLE : o !== void 0 && ("complete" in o ? o.complete ? l = o.src ? le.LOADED : le.IDLE : l = le.LOADING : l = le.LOADED), this.color_ = e.color !== void 0 ? an(e.color) : null, this.iconImage_ = Wh(
      o,
      /** @type {string} */
      a,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, this.initialOptions_, e.width !== void 0 || e.height !== void 0) {
      let c, h;
      if (e.size)
        [c, h] = e.size;
      else {
        const u = this.getImage(1);
        if (u.width && u.height)
          c = u.width, h = u.height;
        else if (u instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const d = () => {
            if (this.unlistenImageChange(d), !this.initialOptions_)
              return;
            const f = this.iconImage_.getSize();
            this.setScale(
              Nd(
                f[0],
                f[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(d);
          return;
        }
      }
      c !== void 0 && this.setScale(
        Nd(c, h, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let e, t, i;
    return this.initialOptions_ ? (t = this.initialOptions_.width, i = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new mo({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: t,
      height: i,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const r = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!r)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= r[0]), this.anchorYUnits_ == "fraction" && (e[1] *= r[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!r)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + r[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] - t[0] / i[0],
      e[1] + t[1] / i[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), i = this.iconImage_.getSize();
      if (!t || !i)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = i[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = i[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == le.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == le.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(ie.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(ie.CHANGE, e);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
}
const yn = 0.5;
function bx(n, e, t, i, r, s, o, a, l) {
  const c = r, h = n[0] * yn, u = n[1] * yn, d = je(h, u);
  d.imageSmoothingEnabled = !1;
  const f = d.canvas, g = new kg(
    d,
    yn,
    r,
    null,
    o,
    a,
    null
  ), _ = t.length, m = Math.floor((256 * 256 * 256 - 1) / _), y = {};
  for (let E = 1; E <= _; ++E) {
    const x = t[E - 1], v = x.getStyleFunction() || i;
    if (!v)
      continue;
    let S = v(x, s);
    if (!S)
      continue;
    Array.isArray(S) || (S = [S]);
    const b = (E * m).toString(16).padStart(7, "#00000");
    for (let P = 0, O = S.length; P < O; ++P) {
      const N = S[P], k = N.getGeometryFunction()(x);
      if (!k || !vt(c, k.getExtent()))
        continue;
      const D = N.clone(), U = D.getFill();
      U && U.setColor(b);
      const X = D.getStroke();
      X && (X.setColor(b), X.setLineDash(null)), D.setText(void 0);
      const I = N.getImage();
      if (I) {
        const H = I.getImageSize();
        if (!H)
          continue;
        const re = je(
          H[0],
          H[1],
          void 0,
          { alpha: !1 }
        ), A = re.canvas;
        re.fillStyle = b, re.fillRect(0, 0, A.width, A.height), D.setImage(
          new mo({
            img: A,
            anchor: I.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: I.getOrigin(),
            opacity: 1,
            size: I.getSize(),
            scale: I.getScale(),
            rotation: I.getRotation(),
            rotateWithView: I.getRotateWithView()
          })
        );
      }
      const F = D.getZIndex() || 0;
      let B = y[F];
      B || (B = {}, y[F] = B, B.Polygon = [], B.Circle = [], B.LineString = [], B.Point = []);
      const $ = k.getType();
      if ($ === "GeometryCollection") {
        const H = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          k.getGeometriesArrayRecursive()
        );
        for (let re = 0, A = H.length; re < A; ++re) {
          const Fe = H[re];
          B[Fe.getType().replace("Multi", "")].push(
            Fe,
            D
          );
        }
      } else
        B[$.replace("Multi", "")].push(k, D);
    }
  }
  const p = Object.keys(y).map(Number).sort(Kn);
  for (let E = 0, x = p.length; E < x; ++E) {
    const v = y[p[E]];
    for (const S in v) {
      const w = v[S];
      for (let b = 0, P = w.length; b < P; b += 2) {
        g.setStyle(w[b + 1]);
        for (let O = 0, N = e.length; O < N; ++O)
          g.setTransform(e[O]), g.drawGeometry(w[b]);
      }
    }
  }
  return d.getImageData(0, 0, f.width, f.height);
}
function Rx(n, e, t) {
  const i = [];
  if (t) {
    const r = Math.floor(Math.round(n[0]) * yn), s = Math.floor(Math.round(n[1]) * yn), o = (De(r, 0, t.width - 1) + De(s, 0, t.height - 1) * t.width) * 4, a = t.data[o], l = t.data[o + 1], h = t.data[o + 2] + 256 * (l + 256 * a), u = Math.floor((256 * 256 * 256 - 1) / e.length);
    h && h % u === 0 && i.push(e[h / u - 1]);
  }
  return i;
}
class Os extends ai {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, i, r) {
    super(e), this.inversePixelTransform = t, this.frameState = i, this.context = r;
  }
}
const Cx = 5;
class Xg extends oo {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.staleKeys_ = new Array(), this.maxStaleKeys = Cx;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(e) {
    this.staleKeys_.unshift(e), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return Q();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return Q();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    return Q();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, r, s) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (t.getState() === le.LOADED || t.getState() === le.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != le.LOADED && t != le.ERROR && e.addEventListener(ie.CHANGE, this.boundHandleImageChange_), t == le.IDLE && (e.load(), t = e.getState()), t == le.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const Gd = [];
let Ar = null;
function Px() {
  Ar = je(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class Hg extends Xg {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = Ke(), this.pixelTransform = Ke(), this.inversePixelTransform = Ke(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, i) {
    Ar || Px(), Ar.clearRect(0, 0, 1, 1);
    let r;
    try {
      Ar.drawImage(e, t, i, 1, 1, 0, 0, 1, 1), r = Ar.getImageData(0, 0, 1, 1).data;
    } catch {
      return Ar = null, null;
    }
    return r;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let i = this.getLayer().getBackground();
    return typeof i == "function" && (i = i(e.viewState.resolution)), i || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS transform matrix.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, i) {
    const r = this.getLayer().getClassName();
    let s, o;
    if (e && e.className === r && (!i || e && e.style.backgroundColor && oi(
      an(e.style.backgroundColor),
      an(i)
    ))) {
      const a = e.firstElementChild;
      a instanceof HTMLCanvasElement && (o = a.getContext("2d"));
    }
    if (o && Zy(o.canvas.style.transform, t) ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      s = document.createElement("div"), s.className = r;
      let a = s.style;
      a.position = "absolute", a.width = "100%", a.height = "100%", o = je();
      const l = o.canvas;
      s.appendChild(l), a = l.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = s, this.context = o;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, i) {
    const r = or(i), s = ja(i), o = $a(i), a = Ya(i);
    Ue(t.coordinateToPixelTransform, r), Ue(t.coordinateToPixelTransform, s), Ue(t.coordinateToPixelTransform, o), Ue(t.coordinateToPixelTransform, a);
    const l = this.inversePixelTransform;
    Ue(l, r), Ue(l, s), Ue(l, o), Ue(l, a), e.save(), e.beginPath(), e.moveTo(Math.round(r[0]), Math.round(r[1])), e.lineTo(Math.round(s[0]), Math.round(s[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(e, t) {
    const i = e.extent, r = e.viewState.resolution, s = e.viewState.rotation, o = e.pixelRatio, a = Math.round(Ee(i) / r * o), l = Math.round(ut(i) / r * o);
    sn(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / o,
      1 / o,
      s,
      -a / 2,
      -l / 2
    ), Bs(this.inversePixelTransform, this.pixelTransform);
    const c = Ky(this.pixelTransform);
    if (this.useContainer(t, c, this.getBackground(e)), !this.containerReused) {
      const h = this.context.canvas;
      h.width != a || h.height != l ? (h.width = a, h.height = l) : this.context.clearRect(0, 0, a, l), c !== h.style.transform && (h.style.transform = c);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, i) {
    const r = this.getLayer();
    if (r.hasListener(e)) {
      const s = new Os(
        e,
        this.inversePixelTransform,
        i,
        t
      );
      r.dispatchEvent(s);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, !t.declutter && this.dispatchRenderEvent_(et.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    t.declutter || this.dispatchRenderEvent_(et.POSTRENDER, e, t);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new jg()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      et.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      et.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, i, r, s, o, a) {
    const l = s / 2, c = o / 2, h = r / t, u = -h, d = -e[0] + a, f = -e[1];
    return sn(
      this.tempTransform,
      l,
      c,
      h,
      u,
      -i,
      d,
      f
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
class Ix extends Hg {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = St(), this.wrappedRenderedExtent_ = St(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, t, i) {
    const r = t.extent, s = t.viewState, o = s.center, a = s.resolution, l = s.projection, c = s.rotation, h = l.getExtent(), u = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), f = t.pixelRatio, g = t.viewHints, _ = !(g[Qe.ANIMATING] || g[Qe.INTERACTING]), m = this.context, y = Math.round(Ee(r) / a * f), p = Math.round(ut(r) / a * f), E = u.getWrapX() && l.canWrapX(), x = E ? Ee(h) : null, v = E ? Math.ceil((r[2] - h[2]) / x) + 1 : 1;
    let S = E ? Math.floor((r[0] - h[0]) / x) : 0;
    do {
      let w = this.getRenderTransform(
        o,
        a,
        0,
        f,
        y,
        p,
        S * x
      );
      t.declutter && (w = w.slice(0)), e.execute(
        m,
        [m.canvas.width, m.canvas.height],
        w,
        c,
        _,
        i === void 0 ? Gi : i ? Vg : Tx,
        i ? d && t.declutter[d] : void 0
      );
    } while (++S < v);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = je(
      this.context.canvas.width,
      this.context.canvas.height,
      Gd
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1 && this.targetContext_) {
      const e = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, Ja(this.context), Gd.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(e) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e, t) {
    const i = e.layerStatesArray[e.layerIndex];
    this.opacity_ = i.opacity;
    const r = e.viewState;
    this.prepareContainer(e, t);
    const s = this.context, o = this.replayGroup_;
    let a = o && !o.isEmpty();
    if (!a && !(this.getLayer().hasListener(et.PRERENDER) || this.getLayer().hasListener(et.POSTRENDER)))
      return this.container;
    if (this.setDrawContext_(), this.preRender(s, e), r.projection, this.clipped_ = !1, a && i.extent && this.clipping) {
      const l = yi(i.extent);
      a = vt(l, e.extent), this.clipped_ = a && !Mr(l, e.extent), this.clipped_ && this.clipUnrotated(s, e, l);
    }
    return a && this.renderWorlds(
      o,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !e.declutter && this.clipped_ && s.restore(), this.postRender(s, e), this.renderedRotation_ !== r.rotation && (this.renderedRotation_ = r.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   * @override
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const i = this.frameState.size.slice(), r = this.renderedCenter_, s = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.wrappedRenderedExtent_, c = this.getLayer(), h = [], u = i[0] * yn, d = i[1] * yn;
        h.push(
          this.getRenderTransform(
            r,
            s,
            o,
            yn,
            u,
            d,
            0
          ).slice()
        );
        const f = c.getSource(), g = a.getExtent();
        if (f.getWrapX() && a.canWrapX() && !Mr(g, l)) {
          let _ = l[0];
          const m = Ee(g);
          let y = 0, p;
          for (; _ < g[0]; )
            --y, p = m * y, h.push(
              this.getRenderTransform(
                r,
                s,
                o,
                yn,
                u,
                d,
                p
              ).slice()
            ), _ += m;
          for (y = 0, _ = l[2]; _ > g[2]; )
            ++y, p = m * y, h.push(
              this.getRenderTransform(
                r,
                s,
                o,
                yn,
                u,
                d,
                p
              ).slice()
            ), _ -= m;
        }
        this.hitDetectionImageData_ = bx(
          i,
          h,
          this.renderedFeatures_,
          c.getStyleFunction(),
          l,
          s,
          o,
          Sd(s, this.renderedPixelRatio_)
        );
      }
      t(
        Rx(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, i, r, s) {
    var d, f;
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, a = t.viewState.rotation, l = this.getLayer(), c = {}, h = function(g, _, m) {
      const y = q(g), p = c[y];
      if (p) {
        if (p !== !0 && m < p.distanceSq) {
          if (m === 0)
            return c[y] = !0, s.splice(s.lastIndexOf(p), 1), r(g, l, _);
          p.geometry = _, p.distanceSq = m;
        }
      } else {
        if (m === 0)
          return c[y] = !0, r(g, l, _);
        s.push(
          c[y] = {
            feature: g,
            layer: l,
            geometry: _,
            distanceSq: m,
            callback: r
          }
        );
      }
    }, u = this.getLayer().getDeclutter();
    return this.replayGroup_.forEachFeatureAtCoordinate(
      e,
      o,
      a,
      i,
      h,
      u ? (f = (d = t.declutter) == null ? void 0 : d[u]) == null ? void 0 : f.all().map((g) => g.value) : null
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    const t = this.getLayer(), i = t.getSource();
    if (!i)
      return !1;
    const r = e.viewHints[Qe.ANIMATING], s = e.viewHints[Qe.INTERACTING], o = t.getUpdateWhileAnimating(), a = t.getUpdateWhileInteracting();
    if (this.ready && !o && r || !a && s)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = e.extent, c = e.viewState, h = c.projection, u = c.resolution, d = e.pixelRatio, f = t.getRevision(), g = t.getRenderBuffer();
    let _ = t.getRenderOrder();
    _ === void 0 && (_ = Y0);
    const m = c.center.slice(), y = ni(
      l,
      g * u
    ), p = y.slice(), E = [y.slice()], x = h.getExtent();
    if (i.getWrapX() && h.canWrapX() && !Mr(x, e.extent)) {
      const U = Ee(x), X = Math.max(Ee(y) / 2, U);
      y[0] = x[0] - X, y[2] = x[2] + X, sg(m, h);
      const I = Qf(E[0], h);
      I[0] < x[0] && I[2] < x[2] ? E.push([
        I[0] + U,
        I[1],
        I[2] + U,
        I[3]
      ]) : I[0] > x[0] && I[2] > x[2] && E.push([
        I[0] - U,
        I[1],
        I[2] - U,
        I[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == f && this.renderedRenderOrder_ == _ && this.renderedFrameDeclutter_ === !!e.declutter && Mr(this.wrappedRenderedExtent_, y))
      return oi(this.renderedExtent_, p) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = p), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const v = new px(
      Gg(u, d),
      y,
      u,
      d
    );
    let S;
    for (let U = 0, X = E.length; U < X; ++U)
      i.loadFeatures(E[U], u, h);
    const w = Sd(u, d);
    let b = !0;
    const P = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (U, X) => {
        let I;
        const F = U.getStyleFunction() || t.getStyleFunction();
        if (F && (I = F(U, u)), I) {
          const B = this.renderFeature(
            U,
            w,
            I,
            v,
            S,
            this.getLayer().getDeclutter(),
            X
          );
          b = b && !B;
        }
      }
    ), O = dg(y), N = i.getFeaturesInExtent(O);
    _ && N.sort(_);
    for (let U = 0, X = N.length; U < X; ++U)
      P(N[U], U);
    this.renderedFeatures_ = N, this.ready = b;
    const k = v.finish(), D = new wx(
      y,
      u,
      d,
      i.getOverlaps(),
      k,
      t.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = u, this.renderedRevision_ = f, this.renderedRenderOrder_ = _, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = p, this.wrappedRenderedExtent_ = y, this.renderedCenter_ = m, this.renderedProjection_ = h, this.renderedPixelRatio_ = d, this.replayGroup_ = D, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, i, r, s, o, a) {
    if (!i)
      return !1;
    let l = !1;
    if (Array.isArray(i))
      for (let c = 0, h = i.length; c < h; ++c)
        l = bd(
          r,
          e,
          i[c],
          t,
          this.boundHandleStyleImageChange_,
          s,
          o,
          a
        ) || l;
    else
      l = bd(
        r,
        e,
        i,
        t,
        this.boundHandleStyleImageChange_,
        s,
        o,
        a
      );
    return l;
  }
}
let cr = 0;
const Xe = 1 << cr++, Y = 1 << cr++, He = 1 << cr++, Me = 1 << cr++, Dt = 1 << cr++, jt = 1 << cr++, Wo = Math.pow(2, cr) - 1, $h = {
  [Xe]: "boolean",
  [Y]: "number",
  [He]: "string",
  [Me]: "color",
  [Dt]: "number[]",
  [jt]: "size"
}, Ax = Object.keys($h).map(Number).sort(Kn);
function Lx(n) {
  return n in $h;
}
function Fr(n) {
  const e = [];
  for (const t of Ax)
    Cs(n, t) && e.push($h[t]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function Cs(n, e) {
  return (n & e) === e;
}
function gi(n, e) {
  return n === e;
}
class Ve {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, t) {
    if (!Lx(e))
      throw new Error(
        `literal expressions must have a specific type, got ${Fr(e)}`
      );
    this.type = e, this.value = t;
  }
}
class Kg {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, t, ...i) {
    this.type = e, this.operator = t, this.args = i;
  }
}
function nl() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    mapState: !1
  };
}
function tt(n, e, t) {
  switch (typeof n) {
    case "boolean": {
      if (gi(e, He))
        return new Ve(He, n ? "true" : "false");
      if (!Cs(e, Xe))
        throw new Error(
          `got a boolean, but expected ${Fr(e)}`
        );
      return new Ve(Xe, n);
    }
    case "number": {
      if (gi(e, jt))
        return new Ve(jt, Tt(n));
      if (gi(e, Xe))
        return new Ve(Xe, !!n);
      if (gi(e, He))
        return new Ve(He, n.toString());
      if (!Cs(e, Y))
        throw new Error(`got a number, but expected ${Fr(e)}`);
      return new Ve(Y, n);
    }
    case "string": {
      if (gi(e, Me))
        return new Ve(Me, Bh(n));
      if (gi(e, Xe))
        return new Ve(Xe, !!n);
      if (!Cs(e, He))
        throw new Error(`got a string, but expected ${Fr(e)}`);
      return new Ve(He, n);
    }
  }
  if (!Array.isArray(n))
    throw new Error("expression must be an array or a primitive value");
  if (n.length === 0)
    throw new Error("empty expression");
  if (typeof n[0] == "string")
    return Wx(n, e, t);
  for (const i of n)
    if (typeof i != "number")
      throw new Error("expected an array of numbers");
  if (gi(e, jt)) {
    if (n.length !== 2)
      throw new Error(
        `expected an array of two values for a size, got ${n.length}`
      );
    return new Ve(jt, n);
  }
  if (gi(e, Me)) {
    if (n.length === 3)
      return new Ve(Me, [...n, 1]);
    if (n.length === 4)
      return new Ve(Me, n);
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${n.length}`
    );
  }
  if (!Cs(e, Dt))
    throw new Error(
      `got an array of numbers, but expected ${Fr(e)}`
    );
  return new Ve(Dt, n);
}
const R = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
}, Ox = {
  [R.Get]: J(oe(1, 1 / 0), Ud),
  [R.Var]: J(oe(1, 1), Mx),
  [R.Has]: J(oe(1, 1 / 0), Ud),
  [R.Id]: J(Dx, vr),
  [R.Concat]: J(
    oe(2, 1 / 0),
    xe(He)
  ),
  [R.GeometryType]: J(Fx, vr),
  [R.LineMetric]: J(vr),
  [R.Resolution]: J(Kl, vr),
  [R.Zoom]: J(Kl, vr),
  [R.Time]: J(Kl, vr),
  [R.Any]: J(
    oe(2, 1 / 0),
    xe(Xe)
  ),
  [R.All]: J(
    oe(2, 1 / 0),
    xe(Xe)
  ),
  [R.Not]: J(
    oe(1, 1),
    xe(Xe)
  ),
  [R.Equal]: J(
    oe(2, 2),
    xe(Wo)
  ),
  [R.NotEqual]: J(
    oe(2, 2),
    xe(Wo)
  ),
  [R.GreaterThan]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.GreaterThanOrEqualTo]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.LessThan]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.LessThanOrEqualTo]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.Multiply]: J(
    oe(2, 1 / 0),
    Bd
  ),
  [R.Coalesce]: J(
    oe(2, 1 / 0),
    Bd
  ),
  [R.Divide]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.Add]: J(
    oe(2, 1 / 0),
    xe(Y)
  ),
  [R.Subtract]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.Clamp]: J(
    oe(3, 3),
    xe(Y)
  ),
  [R.Mod]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.Pow]: J(
    oe(2, 2),
    xe(Y)
  ),
  [R.Abs]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Floor]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Ceil]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Round]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Sin]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Cos]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Atan]: J(
    oe(1, 2),
    xe(Y)
  ),
  [R.Sqrt]: J(
    oe(1, 1),
    xe(Y)
  ),
  [R.Match]: J(
    oe(4, 1 / 0),
    zd,
    Nx
  ),
  [R.Between]: J(
    oe(3, 3),
    xe(Y)
  ),
  [R.Interpolate]: J(
    oe(6, 1 / 0),
    zd,
    Gx
  ),
  [R.Case]: J(
    oe(3, 1 / 0),
    kx,
    Ux
  ),
  [R.In]: J(oe(2, 2), Bx),
  [R.Number]: J(
    oe(1, 1 / 0),
    xe(Wo)
  ),
  [R.String]: J(
    oe(1, 1 / 0),
    xe(Wo)
  ),
  [R.Array]: J(
    oe(1, 1 / 0),
    xe(Y)
  ),
  [R.Color]: J(
    oe(1, 4),
    xe(Y)
  ),
  [R.Band]: J(
    oe(1, 3),
    xe(Y)
  ),
  [R.Palette]: J(
    oe(2, 2),
    zx
  ),
  [R.ToString]: J(
    oe(1, 1),
    xe(Xe | Y | He | Me)
  )
};
function Ud(n, e, t) {
  const i = n.length - 1, r = new Array(i);
  for (let s = 0; s < i; ++s) {
    const o = n[s + 1];
    switch (typeof o) {
      case "number": {
        r[s] = new Ve(Y, o);
        break;
      }
      case "string": {
        r[s] = new Ve(He, o);
        break;
      }
      default:
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${o}`
        );
    }
    s === 0 && t.properties.add(String(o));
  }
  return r;
}
function Mx(n, e, t) {
  const i = n[1];
  if (typeof i != "string")
    throw new Error("expected a string argument for var operation");
  return t.variables.add(i), [new Ve(He, i)];
}
function Dx(n, e, t) {
  t.featureId = !0;
}
function Fx(n, e, t) {
  t.geometryType = !0;
}
function Kl(n, e, t) {
  t.mapState = !0;
}
function vr(n, e, t) {
  const i = n[0];
  if (n.length !== 1)
    throw new Error(`expected no arguments for ${i} operation`);
  return [];
}
function oe(n, e) {
  return function(t, i, r) {
    const s = t[0], o = t.length - 1;
    if (n === e) {
      if (o !== n) {
        const a = n === 1 ? "" : "s";
        throw new Error(
          `expected ${n} argument${a} for ${s}, got ${o}`
        );
      }
    } else if (o < n || o > e) {
      const a = e === 1 / 0 ? `${n} or more` : `${n} to ${e}`;
      throw new Error(
        `expected ${a} arguments for ${s}, got ${o}`
      );
    }
  };
}
function Bd(n, e, t) {
  const i = n.length - 1, r = new Array(i);
  for (let s = 0; s < i; ++s) {
    const o = tt(n[s + 1], e, t);
    r[s] = o;
  }
  return r;
}
function xe(n) {
  return function(e, t, i) {
    const r = e.length - 1, s = new Array(r);
    for (let o = 0; o < r; ++o) {
      const a = tt(e[o + 1], n, i);
      s[o] = a;
    }
    return s;
  };
}
function kx(n, e, t) {
  const i = n[0], r = n.length - 1;
  if (r % 2 === 0)
    throw new Error(
      `expected an odd number of arguments for ${i}, got ${r} instead`
    );
}
function zd(n, e, t) {
  const i = n[0], r = n.length - 1;
  if (r % 2 === 1)
    throw new Error(
      `expected an even number of arguments for operation ${i}, got ${r} instead`
    );
}
function Nx(n, e, t) {
  const i = n.length - 1, r = He | Y | Xe, s = tt(n[1], r, t), o = tt(n[n.length - 1], e, t), a = new Array(i - 2);
  for (let l = 0; l < i - 2; l += 2) {
    try {
      const c = tt(n[l + 2], s.type, t);
      a[l] = c;
    } catch (c) {
      throw new Error(
        `failed to parse argument ${l + 1} of match expression: ${c.message}`
      );
    }
    try {
      const c = tt(n[l + 3], o.type, t);
      a[l + 1] = c;
    } catch (c) {
      throw new Error(
        `failed to parse argument ${l + 2} of match expression: ${c.message}`
      );
    }
  }
  return [s, ...a, o];
}
function Gx(n, e, t) {
  const i = n[1];
  let r;
  switch (i[0]) {
    case "linear":
      r = 1;
      break;
    case "exponential":
      const l = i[1];
      if (typeof l != "number" || l <= 0)
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`
        );
      r = l;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(i)}`
      );
  }
  const s = new Ve(Y, r);
  let o;
  try {
    o = tt(n[2], Y, t);
  } catch (l) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${l.message}`
    );
  }
  const a = new Array(n.length - 3);
  for (let l = 0; l < a.length; l += 2) {
    try {
      const c = tt(n[l + 3], Y, t);
      a[l] = c;
    } catch (c) {
      throw new Error(
        `failed to parse argument ${l + 2} for interpolate expression: ${c.message}`
      );
    }
    try {
      const c = tt(n[l + 4], e, t);
      a[l + 1] = c;
    } catch (c) {
      throw new Error(
        `failed to parse argument ${l + 3} for interpolate expression: ${c.message}`
      );
    }
  }
  return [s, o, ...a];
}
function Ux(n, e, t) {
  const i = tt(n[n.length - 1], e, t), r = new Array(n.length - 1);
  for (let s = 0; s < r.length - 1; s += 2) {
    try {
      const o = tt(n[s + 1], Xe, t);
      r[s] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s} of case expression: ${o.message}`
      );
    }
    try {
      const o = tt(n[s + 2], i.type, t);
      r[s + 1] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s + 1} of case expression: ${o.message}`
      );
    }
  }
  return r[r.length - 1] = i, r;
}
function Bx(n, e, t) {
  let i = n[2];
  if (!Array.isArray(i))
    throw new Error(
      'the second argument for the "in" operator must be an array'
    );
  let r;
  if (typeof i[0] == "string") {
    if (i[0] !== "literal")
      throw new Error(
        'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
      );
    if (!Array.isArray(i[1]))
      throw new Error(
        'failed to parse "in" expression: the literal operator must be followed by an array'
      );
    i = i[1], r = He;
  } else
    r = Y;
  const s = new Array(i.length);
  for (let a = 0; a < s.length; a++)
    try {
      const l = tt(i[a], r, t);
      s[a] = l;
    } catch (l) {
      throw new Error(
        `failed to parse haystack item ${a} for "in" expression: ${l.message}`
      );
    }
  return [tt(n[1], r, t), ...s];
}
function zx(n, e, t) {
  let i;
  try {
    i = tt(n[1], Y, t);
  } catch (o) {
    throw new Error(
      `failed to parse first argument in palette expression: ${o.message}`
    );
  }
  const r = n[2];
  if (!Array.isArray(r))
    throw new Error("the second argument of palette must be an array");
  const s = new Array(r.length);
  for (let o = 0; o < s.length; o++) {
    let a;
    try {
      a = tt(r[o], Me, t);
    } catch (l) {
      throw new Error(
        `failed to parse color at index ${o} in palette expression: ${l.message}`
      );
    }
    if (!(a instanceof Ve))
      throw new Error(
        `the palette color at index ${o} must be a literal value`
      );
    s[o] = a;
  }
  return [i, ...s];
}
function J(...n) {
  return function(e, t, i) {
    const r = e[0];
    let s;
    for (let o = 0; o < n.length; o++) {
      const a = n[o](e, t, i);
      if (o == n.length - 1) {
        if (!a)
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        s = a;
      }
    }
    return new Kg(t, r, ...s);
  };
}
function Wx(n, e, t) {
  const i = n[0], r = Ox[i];
  if (!r)
    throw new Error(`unknown operator: ${i}`);
  return r(n, e, t);
}
function il(n) {
  if (!n)
    return "";
  const e = n.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return il(
        /** @type {import("../geom/GeometryCollection.js").default} */
        n.getGeometries()[0]
      );
    default:
      return "";
  }
}
function jh() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function Rn(n, e, t) {
  const i = tt(n, e, t);
  return ln(i);
}
function ln(n, e) {
  if (n instanceof Ve) {
    if (n.type === Me && typeof n.value == "string") {
      const i = Bh(n.value);
      return function() {
        return i;
      };
    }
    return function() {
      return n.value;
    };
  }
  const t = n.operator;
  switch (t) {
    case R.Number:
    case R.String:
    case R.Coalesce:
      return Yx(n);
    case R.Get:
    case R.Var:
    case R.Has:
      return $x(n);
    case R.Id:
      return (i) => i.featureId;
    case R.GeometryType:
      return (i) => i.geometryType;
    case R.Concat: {
      const i = n.args.map((r) => ln(r));
      return (r) => "".concat(...i.map((s) => s(r).toString()));
    }
    case R.Resolution:
      return (i) => i.resolution;
    case R.Any:
    case R.All:
    case R.Between:
    case R.In:
    case R.Not:
      return Vx(n);
    case R.Equal:
    case R.NotEqual:
    case R.LessThan:
    case R.LessThanOrEqualTo:
    case R.GreaterThan:
    case R.GreaterThanOrEqualTo:
      return jx(n);
    case R.Multiply:
    case R.Divide:
    case R.Add:
    case R.Subtract:
    case R.Clamp:
    case R.Mod:
    case R.Pow:
    case R.Abs:
    case R.Floor:
    case R.Ceil:
    case R.Round:
    case R.Sin:
    case R.Cos:
    case R.Atan:
    case R.Sqrt:
      return Xx(n);
    case R.Case:
      return Hx(n);
    case R.Match:
      return Kx(n);
    case R.Interpolate:
      return Zx(n);
    case R.ToString:
      return qx(n);
    default:
      throw new Error(`Unsupported operator ${t}`);
  }
}
function Yx(n, e) {
  const t = n.operator, i = n.args.length, r = new Array(i);
  for (let s = 0; s < i; ++s)
    r[s] = ln(n.args[s]);
  switch (t) {
    case R.Coalesce:
      return (s) => {
        for (let o = 0; o < i; ++o) {
          const a = r[o](s);
          if (typeof a < "u" && a !== null)
            return a;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case R.Number:
    case R.String:
      return (s) => {
        for (let o = 0; o < i; ++o) {
          const a = r[o](s);
          if (typeof a === t)
            return a;
        }
        throw new Error(`Expected one of the values to be a ${t}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${t}`);
  }
}
function $x(n, e) {
  const i = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    n.args[0].value
  );
  switch (n.operator) {
    case R.Get:
      return (r) => {
        const s = n.args;
        let o = r.properties[i];
        for (let a = 1, l = s.length; a < l; ++a) {
          const h = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          o = o[h];
        }
        return o;
      };
    case R.Var:
      return (r) => r.variables[i];
    case R.Has:
      return (r) => {
        const s = n.args;
        if (!(i in r.properties))
          return !1;
        let o = r.properties[i];
        for (let a = 1, l = s.length; a < l; ++a) {
          const h = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          if (!o || !Object.hasOwn(o, h))
            return !1;
          o = o[h];
        }
        return !0;
      };
    default:
      throw new Error(`Unsupported accessor operator ${n.operator}`);
  }
}
function jx(n, e) {
  const t = n.operator, i = ln(n.args[0]), r = ln(n.args[1]);
  switch (t) {
    case R.Equal:
      return (s) => i(s) === r(s);
    case R.NotEqual:
      return (s) => i(s) !== r(s);
    case R.LessThan:
      return (s) => i(s) < r(s);
    case R.LessThanOrEqualTo:
      return (s) => i(s) <= r(s);
    case R.GreaterThan:
      return (s) => i(s) > r(s);
    case R.GreaterThanOrEqualTo:
      return (s) => i(s) >= r(s);
    default:
      throw new Error(`Unsupported comparison operator ${t}`);
  }
}
function Vx(n, e) {
  const t = n.operator, i = n.args.length, r = new Array(i);
  for (let s = 0; s < i; ++s)
    r[s] = ln(n.args[s]);
  switch (t) {
    case R.Any:
      return (s) => {
        for (let o = 0; o < i; ++o)
          if (r[o](s))
            return !0;
        return !1;
      };
    case R.All:
      return (s) => {
        for (let o = 0; o < i; ++o)
          if (!r[o](s))
            return !1;
        return !0;
      };
    case R.Between:
      return (s) => {
        const o = r[0](s), a = r[1](s), l = r[2](s);
        return o >= a && o <= l;
      };
    case R.In:
      return (s) => {
        const o = r[0](s);
        for (let a = 1; a < i; ++a)
          if (o === r[a](s))
            return !0;
        return !1;
      };
    case R.Not:
      return (s) => !r[0](s);
    default:
      throw new Error(`Unsupported logical operator ${t}`);
  }
}
function Xx(n, e) {
  const t = n.operator, i = n.args.length, r = new Array(i);
  for (let s = 0; s < i; ++s)
    r[s] = ln(n.args[s]);
  switch (t) {
    case R.Multiply:
      return (s) => {
        let o = 1;
        for (let a = 0; a < i; ++a)
          o *= r[a](s);
        return o;
      };
    case R.Divide:
      return (s) => r[0](s) / r[1](s);
    case R.Add:
      return (s) => {
        let o = 0;
        for (let a = 0; a < i; ++a)
          o += r[a](s);
        return o;
      };
    case R.Subtract:
      return (s) => r[0](s) - r[1](s);
    case R.Clamp:
      return (s) => {
        const o = r[0](s), a = r[1](s);
        if (o < a)
          return a;
        const l = r[2](s);
        return o > l ? l : o;
      };
    case R.Mod:
      return (s) => r[0](s) % r[1](s);
    case R.Pow:
      return (s) => Math.pow(r[0](s), r[1](s));
    case R.Abs:
      return (s) => Math.abs(r[0](s));
    case R.Floor:
      return (s) => Math.floor(r[0](s));
    case R.Ceil:
      return (s) => Math.ceil(r[0](s));
    case R.Round:
      return (s) => Math.round(r[0](s));
    case R.Sin:
      return (s) => Math.sin(r[0](s));
    case R.Cos:
      return (s) => Math.cos(r[0](s));
    case R.Atan:
      return i === 2 ? (s) => Math.atan2(r[0](s), r[1](s)) : (s) => Math.atan(r[0](s));
    case R.Sqrt:
      return (s) => Math.sqrt(r[0](s));
    default:
      throw new Error(`Unsupported numeric operator ${t}`);
  }
}
function Hx(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let r = 0; r < t; ++r)
    i[r] = ln(n.args[r]);
  return (r) => {
    for (let s = 0; s < t - 1; s += 2)
      if (i[s](r))
        return i[s + 1](r);
    return i[t - 1](r);
  };
}
function Kx(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let r = 0; r < t; ++r)
    i[r] = ln(n.args[r]);
  return (r) => {
    const s = i[0](r);
    for (let o = 1; o < t - 1; o += 2)
      if (s === i[o](r))
        return i[o + 1](r);
    return i[t - 1](r);
  };
}
function Zx(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let r = 0; r < t; ++r)
    i[r] = ln(n.args[r]);
  return (r) => {
    const s = i[0](r), o = i[1](r);
    let a, l;
    for (let c = 2; c < t; c += 2) {
      const h = i[c](r);
      let u = i[c + 1](r);
      const d = Array.isArray(u);
      if (d && (u = R0(u)), h >= o)
        return c === 2 ? u : d ? Jx(
          s,
          o,
          a,
          l,
          h,
          u
        ) : Ps(
          s,
          o,
          a,
          l,
          h,
          u
        );
      a = h, l = u;
    }
    return l;
  };
}
function qx(n, e) {
  const t = n.operator, i = n.args.length, r = new Array(i);
  for (let s = 0; s < i; ++s)
    r[s] = ln(n.args[s]);
  switch (t) {
    case R.ToString:
      return (s) => {
        const o = r[0](s);
        return n.args[0].type === Me ? zh(o) : o.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${t}`);
  }
}
function Ps(n, e, t, i, r, s) {
  const o = r - t;
  if (o === 0)
    return i;
  const a = e - t, l = n === 1 ? a / o : (Math.pow(n, a) - 1) / (Math.pow(n, o) - 1);
  return i + l * (s - i);
}
function Jx(n, e, t, i, r, s) {
  if (r - t === 0)
    return i;
  const a = xd(i), l = xd(s);
  let c = l[2] - a[2];
  c > 180 ? c -= 360 : c < -180 && (c += 360);
  const h = [
    Ps(n, e, t, a[0], r, l[0]),
    Ps(n, e, t, a[1], r, l[1]),
    a[2] + Ps(n, e, t, 0, r, c),
    Ps(n, e, t, i[3], r, s[3])
  ];
  return C0(h);
}
function Qx(n) {
  return !0;
}
function ev(n) {
  const e = nl(), t = tv(n, e), i = jh();
  return function(r, s) {
    if (i.properties = r.getPropertiesInternal(), i.resolution = s, e.featureId) {
      const o = r.getId();
      o !== void 0 ? i.featureId = o : i.featureId = null;
    }
    return e.geometryType && (i.geometryType = il(
      r.getGeometry()
    )), t(i);
  };
}
function Wd(n) {
  const e = nl(), t = n.length, i = new Array(t);
  for (let o = 0; o < t; ++o)
    i[o] = zc(n[o], e);
  const r = jh(), s = new Array(t);
  return function(o, a) {
    if (r.properties = o.getPropertiesInternal(), r.resolution = a, e.featureId) {
      const c = o.getId();
      c !== void 0 ? r.featureId = c : r.featureId = null;
    }
    let l = 0;
    for (let c = 0; c < t; ++c) {
      const h = i[c](r);
      h && (s[l] = h, l += 1);
    }
    return s.length = l, s;
  };
}
function tv(n, e) {
  const t = n.length, i = new Array(t);
  for (let r = 0; r < t; ++r) {
    const s = n[r], o = "filter" in s ? Rn(s.filter, Xe, e) : Qx;
    let a;
    if (Array.isArray(s.style)) {
      const l = s.style.length;
      a = new Array(l);
      for (let c = 0; c < l; ++c)
        a[c] = zc(s.style[c], e);
    } else
      a = [zc(s.style, e)];
    i[r] = { filter: o, styles: a };
  }
  return function(r) {
    const s = [];
    let o = !1;
    for (let a = 0; a < t; ++a) {
      const l = i[a].filter;
      if (l(r) && !(n[a].else && o)) {
        o = !0;
        for (const c of i[a].styles) {
          const h = c(r);
          h && s.push(h);
        }
      }
    }
    return s;
  };
}
function zc(n, e) {
  const t = Xs(n, "", e), i = Hs(n, "", e), r = nv(n, e), s = iv(n, e), o = Lt(n, "z-index", e);
  if (!t && !i && !r && !s && !er(n))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(n)
    );
  const a = new wt();
  return function(l) {
    let c = !0;
    if (t) {
      const h = t(l);
      h && (c = !1), a.setFill(h);
    }
    if (i) {
      const h = i(l);
      h && (c = !1), a.setStroke(h);
    }
    if (r) {
      const h = r(l);
      h && (c = !1), a.setText(h);
    }
    if (s) {
      const h = s(l);
      h && (c = !1), a.setImage(h);
    }
    return o && a.setZIndex(o(l)), c ? null : a;
  };
}
function Xs(n, e, t) {
  let i;
  if (e + "fill-pattern-src" in n)
    i = av(n, e + "fill-", t);
  else {
    if (n[e + "fill-color"] === "none")
      return (s) => null;
    i = Vh(
      n,
      e + "fill-color",
      t
    );
  }
  if (!i)
    return null;
  const r = new ri();
  return function(s) {
    const o = i(s);
    return o === Uh ? null : (r.setColor(o), r);
  };
}
function Hs(n, e, t) {
  const i = Lt(
    n,
    e + "stroke-width",
    t
  ), r = Vh(
    n,
    e + "stroke-color",
    t
  );
  if (!i && !r)
    return null;
  const s = $n(
    n,
    e + "stroke-line-cap",
    t
  ), o = $n(
    n,
    e + "stroke-line-join",
    t
  ), a = Zg(
    n,
    e + "stroke-line-dash",
    t
  ), l = Lt(
    n,
    e + "stroke-line-dash-offset",
    t
  ), c = Lt(
    n,
    e + "stroke-miter-limit",
    t
  ), h = new Gt();
  return function(u) {
    if (r) {
      const d = r(u);
      if (d === Uh)
        return null;
      h.setColor(d);
    }
    if (i && h.setWidth(i(u)), s) {
      const d = s(u);
      if (d !== "butt" && d !== "round" && d !== "square")
        throw new Error("Expected butt, round, or square line cap");
      h.setLineCap(d);
    }
    if (o) {
      const d = o(u);
      if (d !== "bevel" && d !== "round" && d !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      h.setLineJoin(d);
    }
    return a && h.setLineDash(a(u)), l && h.setLineDashOffset(l(u)), c && h.setMiterLimit(c(u)), h;
  };
}
function nv(n, e) {
  const t = "text-", i = $n(n, t + "value", e);
  if (!i)
    return null;
  const r = Xs(n, t, e), s = Xs(
    n,
    t + "background-",
    e
  ), o = Hs(n, t, e), a = Hs(
    n,
    t + "background-",
    e
  ), l = $n(n, t + "font", e), c = Lt(
    n,
    t + "max-angle",
    e
  ), h = Lt(
    n,
    t + "offset-x",
    e
  ), u = Lt(
    n,
    t + "offset-y",
    e
  ), d = Gr(
    n,
    t + "overflow",
    e
  ), f = $n(
    n,
    t + "placement",
    e
  ), g = Lt(n, t + "repeat", e), _ = rl(n, t + "scale", e), m = Gr(
    n,
    t + "rotate-with-view",
    e
  ), y = Lt(
    n,
    t + "rotation",
    e
  ), p = $n(n, t + "align", e), E = $n(
    n,
    t + "justify",
    e
  ), x = $n(
    n,
    t + "baseline",
    e
  ), v = Gr(
    n,
    t + "keep-upright",
    e
  ), S = Zg(
    n,
    t + "padding",
    e
  ), w = sl(
    n,
    t + "declutter-mode"
  ), b = new Ki({ declutterMode: w });
  return function(P) {
    if (b.setText(i(P)), r && b.setFill(r(P)), s && b.setBackgroundFill(s(P)), o && b.setStroke(o(P)), a && b.setBackgroundStroke(a(P)), l && b.setFont(l(P)), c && b.setMaxAngle(c(P)), h && b.setOffsetX(h(P)), u && b.setOffsetY(u(P)), d && b.setOverflow(d(P)), f) {
      const O = f(P);
      if (O !== "point" && O !== "line")
        throw new Error("Expected point or line for text-placement");
      b.setPlacement(O);
    }
    if (g && b.setRepeat(g(P)), _ && b.setScale(_(P)), m && b.setRotateWithView(m(P)), y && b.setRotation(y(P)), p) {
      const O = p(P);
      if (O !== "left" && O !== "center" && O !== "right" && O !== "end" && O !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      b.setTextAlign(O);
    }
    if (E) {
      const O = E(P);
      if (O !== "left" && O !== "right" && O !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      b.setJustify(O);
    }
    if (x) {
      const O = x(P);
      if (O !== "bottom" && O !== "top" && O !== "middle" && O !== "alphabetic" && O !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      b.setTextBaseline(O);
    }
    return S && b.setPadding(S(P)), v && b.setKeepUpright(v(P)), b;
  };
}
function iv(n, e) {
  return "icon-src" in n ? rv(n, e) : "shape-points" in n ? sv(n, e) : "circle-radius" in n ? ov(n, e) : null;
}
function rv(n, e) {
  const t = "icon-", i = t + "src", r = qg(n[i], i), s = Ea(
    n,
    t + "anchor",
    e
  ), o = rl(n, t + "scale", e), a = Lt(
    n,
    t + "opacity",
    e
  ), l = Ea(
    n,
    t + "displacement",
    e
  ), c = Lt(
    n,
    t + "rotation",
    e
  ), h = Gr(
    n,
    t + "rotate-with-view",
    e
  ), u = $d(n, t + "anchor-origin"), d = jd(
    n,
    t + "anchor-x-units"
  ), f = jd(
    n,
    t + "anchor-y-units"
  ), g = uv(n, t + "color"), _ = cv(n, t + "cross-origin"), m = hv(n, t + "offset"), y = $d(n, t + "offset-origin"), p = Ta(n, t + "width"), E = Ta(n, t + "height"), x = lv(n, t + "size"), v = sl(
    n,
    t + "declutter-mode"
  ), S = new mo({
    src: r,
    anchorOrigin: u,
    anchorXUnits: d,
    anchorYUnits: f,
    color: g,
    crossOrigin: _,
    offset: m,
    offsetOrigin: y,
    height: E,
    width: p,
    size: x,
    declutterMode: v
  });
  return function(w) {
    return a && S.setOpacity(a(w)), l && S.setDisplacement(l(w)), c && S.setRotation(c(w)), h && S.setRotateWithView(h(w)), o && S.setScale(o(w)), s && S.setAnchor(s(w)), S;
  };
}
function sv(n, e) {
  const t = "shape-", i = t + "points", r = t + "radius", s = Wc(n[i], i), o = Wc(n[r], r), a = Xs(n, t, e), l = Hs(n, t, e), c = rl(n, t + "scale", e), h = Ea(
    n,
    t + "displacement",
    e
  ), u = Lt(
    n,
    t + "rotation",
    e
  ), d = Gr(
    n,
    t + "rotate-with-view",
    e
  ), f = Ta(n, t + "radius2"), g = Ta(n, t + "angle"), _ = sl(
    n,
    t + "declutter-mode"
  ), m = new tl({
    points: s,
    radius: o,
    radius2: f,
    angle: g,
    declutterMode: _
  });
  return function(y) {
    return a && m.setFill(a(y)), l && m.setStroke(l(y)), h && m.setDisplacement(h(y)), u && m.setRotation(u(y)), d && m.setRotateWithView(d(y)), c && m.setScale(c(y)), m;
  };
}
function ov(n, e) {
  const t = "circle-", i = Xs(n, t, e), r = Hs(n, t, e), s = Lt(n, t + "radius", e), o = rl(n, t + "scale", e), a = Ea(
    n,
    t + "displacement",
    e
  ), l = Lt(
    n,
    t + "rotation",
    e
  ), c = Gr(
    n,
    t + "rotate-with-view",
    e
  ), h = sl(
    n,
    t + "declutter-mode"
  ), u = new nr({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: h
  });
  return function(d) {
    return s && u.setRadius(s(d)), i && u.setFill(i(d)), r && u.setStroke(r(d)), a && u.setDisplacement(a(d)), l && u.setRotation(l(d)), c && u.setRotateWithView(c(d)), o && u.setScale(o(d)), u;
  };
}
function Lt(n, e, t) {
  if (!(e in n))
    return;
  const i = Rn(n[e], Y, t);
  return function(r) {
    return Wc(i(r), e);
  };
}
function $n(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], He, t);
  return function(r) {
    return qg(i(r), e);
  };
}
function av(n, e, t) {
  const i = $n(
    n,
    e + "pattern-src",
    t
  ), r = Yd(
    n,
    e + "pattern-offset",
    t
  ), s = Yd(
    n,
    e + "pattern-size",
    t
  ), o = Vh(
    n,
    e + "color",
    t
  );
  return function(a) {
    return {
      src: i(a),
      offset: r && r(a),
      size: s && s(a),
      color: o && o(a)
    };
  };
}
function Gr(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], Xe, t);
  return function(r) {
    const s = i(r);
    if (typeof s != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return s;
  };
}
function Vh(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], Me, t);
  return function(r) {
    return Jg(i(r), e);
  };
}
function Zg(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], Dt, t);
  return function(r) {
    return _o(i(r), e);
  };
}
function Ea(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], Dt, t);
  return function(r) {
    const s = _o(i(r), e);
    if (s.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return s;
  };
}
function Yd(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(n[e], Dt, t);
  return function(r) {
    return Qg(i(r), e);
  };
}
function rl(n, e, t) {
  if (!(e in n))
    return null;
  const i = Rn(
    n[e],
    Dt | Y,
    t
  );
  return function(r) {
    return dv(i(r), e);
  };
}
function Ta(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
}
function lv(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t == "number")
      return Tt(t);
    if (!Array.isArray(t))
      throw new Error(`Expected a number or size array for ${e}`);
    if (t.length !== 2 || typeof t[0] != "number" || typeof t[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return t;
  }
}
function cv(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
}
function $d(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (t !== "bottom-left" && t !== "bottom-right" && t !== "top-left" && t !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return t;
  }
}
function jd(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (t !== "pixels" && t !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return t;
  }
}
function hv(n, e) {
  const t = n[e];
  if (t !== void 0)
    return _o(t, e);
}
function sl(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    if (t !== "declutter" && t !== "obstacle" && t !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return t;
  }
}
function uv(n, e) {
  const t = n[e];
  if (t !== void 0)
    return Jg(t, e);
}
function _o(n, e) {
  if (!Array.isArray(n))
    throw new Error(`Expected an array for ${e}`);
  const t = n.length;
  for (let i = 0; i < t; ++i)
    if (typeof n[i] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return n;
}
function qg(n, e) {
  if (typeof n != "string")
    throw new Error(`Expected a string for ${e}`);
  return n;
}
function Wc(n, e) {
  if (typeof n != "number")
    throw new Error(`Expected a number for ${e}`);
  return n;
}
function Jg(n, e) {
  if (typeof n == "string")
    return n;
  const t = _o(n, e), i = t.length;
  if (i < 3 || i > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return t;
}
function Qg(n, e) {
  const t = _o(n, e);
  if (t.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return t;
}
function dv(n, e) {
  return typeof n == "number" ? n : Qg(n, e);
}
const Qt = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
function Vd(n, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(i, r, s, o, a) {
      if (!i)
        return;
      if (!r && !e)
        return i;
      const l = e ? 0 : s[0] * r, c = e ? 0 : s[1] * r, h = a ? a[0] : 0, u = a ? a[1] : 0;
      let d = n[0] + l / 2 + h, f = n[2] - l / 2 + h, g = n[1] + c / 2 + u, _ = n[3] - c / 2 + u;
      d > f && (d = (f + d) / 2, f = d), g > _ && (g = (_ + g) / 2, _ = g);
      let m = De(i[0], d, f), y = De(i[1], g, _);
      if (o && t && r) {
        const p = 30 * r;
        m += -p * Math.log(1 + Math.max(0, d - i[0]) / p) + p * Math.log(1 + Math.max(0, i[0] - f) / p), y += -p * Math.log(1 + Math.max(0, g - i[1]) / p) + p * Math.log(1 + Math.max(0, i[1] - _) / p);
      }
      return [m, y];
    }
  );
}
function fv(n) {
  return n;
}
function em(n) {
  return Math.pow(n, 3);
}
function Ii(n) {
  return 1 - em(1 - n);
}
function Yc(n) {
  return 3 * n * n - 2 * n * n * n;
}
function tm(n) {
  return n;
}
function gv(n) {
  return n < 0.5 ? Yc(2 * n) : 1 - Yc(2 * (n - 0.5));
}
function Xh(n, e, t, i) {
  const r = Ee(e) / t[0], s = ut(e) / t[1];
  return i ? Math.min(n, Math.max(r, s)) : Math.min(n, Math.min(r, s));
}
function Hh(n, e, t) {
  let i = Math.min(n, e);
  const r = 50;
  return i *= Math.log(1 + r * Math.max(0, n / e - 1)) / r + 1, t && (i = Math.max(i, t), i /= Math.log(1 + r * Math.max(0, t / n - 1)) / r + 1), De(i, t / 2, e * 2);
}
function mv(n, e, t, i) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, s, o, a) {
    if (r !== void 0) {
      const l = n[0], c = n[n.length - 1], h = t ? Xh(
        l,
        t,
        o,
        i
      ) : l;
      if (a)
        return e ? Hh(
          r,
          h,
          c
        ) : De(r, c, h);
      const u = Math.min(h, r), d = Math.floor(ph(n, u, s));
      return n[d] > h && d < n.length - 1 ? n[d + 1] : n[d];
    }
  };
}
function _v(n, e, t, i, r, s) {
  return i = i !== void 0 ? i : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, a, l, c) {
    if (o !== void 0) {
      const h = r ? Xh(
        e,
        r,
        l,
        s
      ) : e;
      if (c)
        return i ? Hh(
          o,
          h,
          t
        ) : De(o, t, h);
      const u = 1e-9, d = Math.ceil(
        Math.log(e / h) / Math.log(n) - u
      ), f = -a * (0.5 - u) + 0.5, g = Math.min(h, o), _ = Math.floor(
        Math.log(e / g) / Math.log(n) + f
      ), m = Math.max(d, _), y = e / Math.pow(n, m);
      return De(y, t, h);
    }
  };
}
function Xd(n, e, t, i, r) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(s, o, a, l) {
    if (s !== void 0) {
      const c = i ? Xh(
        n,
        i,
        a,
        r
      ) : n;
      return !t || !l ? De(s, e, c) : Hh(
        s,
        c,
        e
      );
    }
  };
}
function Kh(n) {
  if (n !== void 0)
    return 0;
}
function Hd(n) {
  if (n !== void 0)
    return n;
}
function pv(n) {
  const e = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, i) {
      if (i)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function yv(n) {
  const e = wi(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, i) {
      return i || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
    }
  );
}
const xv = 42, Zh = 256, Zl = 0;
class xn extends Ft {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Rh(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && ug(), e.center && (e.center = Bn(e.center, this.projection_)), e.extent && (e.extent = yi(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const a in Qt)
      delete t[a];
    this.setProperties(t, !0);
    const i = Ev(e);
    this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = i.minZoom;
    const r = vv(e), s = i.constraint, o = Tv(e);
    this.constraints_ = {
      center: r,
      resolution: s,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const i = this.getCenterInternal();
    if (i) {
      const r = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const s = this.getResolution(), o = s / 2 * (r[3] - t[3] + t[1] - r[1]), a = s / 2 * (r[0] - t[0] + t[2] - r[2]);
      this.setCenterInternal([i[0] + o, i[1] - a]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let i = 0; i < t.length; ++i) {
      let r = arguments[i];
      r.center && (r = Object.assign({}, r), r.center = Bn(
        r.center,
        this.getProjection()
      )), r.anchor && (r = Object.assign({}, r), r.anchor = Bn(
        r.anchor,
        this.getProjection()
      )), t[i] = r;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, i;
    t > 1 && typeof arguments[t - 1] == "function" && (i = arguments[t - 1], --t);
    let r = 0;
    for (; r < t && !this.isDef(); ++r) {
      const h = arguments[r];
      h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
    }
    if (r === t) {
      i && Yo(i, !0);
      return;
    }
    let s = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, l = this.targetRotation_;
    const c = [];
    for (; r < t; ++r) {
      const h = (
        /** @type {AnimationOptions} */
        arguments[r]
      ), u = {
        start: s,
        complete: !1,
        anchor: h.anchor,
        duration: h.duration !== void 0 ? h.duration : 1e3,
        easing: h.easing || Yc,
        callback: i
      };
      if (h.center && (u.sourceCenter = o, u.targetCenter = h.center.slice(), o = u.targetCenter), h.zoom !== void 0 ? (u.sourceResolution = a, u.targetResolution = this.getResolutionForZoom(h.zoom), a = u.targetResolution) : h.resolution && (u.sourceResolution = a, u.targetResolution = h.resolution, a = u.targetResolution), h.rotation !== void 0) {
        u.sourceRotation = l;
        const d = Hi(h.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        u.targetRotation = l + d, l = u.targetRotation;
      }
      wv(u) ? u.complete = !0 : s += u.duration, c.push(u);
    }
    this.animations_.push(c), this.setHint(Qe.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[Qe.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[Qe.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(Qe.ANIMATING, -this.hints_[Qe.ANIMATING]);
    let e;
    for (let t = 0, i = this.animations_.length; t < i; ++t) {
      const r = this.animations_[t];
      if (r[0].callback && Yo(r[0].callback, !1), !e)
        for (let s = 0, o = r.length; s < o; ++s) {
          const a = r[s];
          if (!a.complete) {
            e = a.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const r = this.animations_[i];
      let s = !0;
      for (let o = 0, a = r.length; o < a; ++o) {
        const l = r[o];
        if (l.complete)
          continue;
        const c = e - l.start;
        let h = l.duration > 0 ? c / l.duration : 1;
        h >= 1 ? (l.complete = !0, h = 1) : s = !1;
        const u = l.easing(h);
        if (l.sourceCenter) {
          const d = l.sourceCenter[0], f = l.sourceCenter[1], g = l.targetCenter[0], _ = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = d + u * (g - d), y = f + u * (_ - f);
          this.targetCenter_ = [m, y];
        }
        if (l.sourceResolution && l.targetResolution) {
          const d = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              d,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const d = u === 1 ? Hi(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const f = this.constraints_.rotation(
              d,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = d;
        }
        if (this.applyTargetState_(!0), t = !0, !l.complete)
          break;
      }
      if (s) {
        this.animations_[i] = null, this.setHint(Qe.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = r[0].callback;
        o && Yo(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let i;
    const r = this.getCenterInternal();
    return r !== void 0 && (i = [r[0] - t[0], r[1] - t[1]], Eh(i, e - this.getRotation()), ig(i, t)), i;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let i;
    const r = this.getCenterInternal(), s = this.getResolution();
    if (r !== void 0 && s !== void 0) {
      const o = t[0] - e * (t[0] - r[0]) / s, a = t[1] - e * (t[1] - r[1]) / s;
      i = [o, a];
    }
    return i;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const i = t[0], r = t[1];
      return [
        Math.abs(i * Math.cos(e)) + Math.abs(r * Math.sin(e)),
        Math.abs(i * Math.sin(e)) + Math.abs(r * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && Dc(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Qt.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return dg(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    ge(t, "The view center is not defined");
    const i = (
      /** @type {!number} */
      this.getResolution()
    );
    ge(i !== void 0, "The view resolution is not defined");
    const r = (
      /** @type {!number} */
      this.getRotation()
    );
    return ge(r !== void 0, "The view rotation is not defined"), Ic(t, i, r, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Qt.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      yi(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const i = Ee(e) / t[0], r = ut(e) / t[1];
    return Math.max(i, r);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, r = Math.log(t / i) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(s) {
        return t / Math.pow(e, s * r);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Qt.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), i = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, s = Math.log(i / r) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(o) {
        return Math.log(i / o) / t / s;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const i = this.padding_;
    return i && (t = [
      t[0] - i[1] - i[3],
      t[1] - i[0] - i[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), i = this.getRotation();
    let r = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const s = this.padding_;
    if (s) {
      const o = this.getViewportSizeMinusPadding_();
      r = ql(
        r,
        this.getViewportSize_(),
        [o[0] / 2 + s[3], o[1] / 2 + s[0]],
        t,
        i
      );
    }
    return {
      center: r.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, i, r;
    if (this.resolutions_) {
      const s = ph(this.resolutions_, e, 1);
      t = s, i = this.resolutions_[s], s == this.resolutions_.length - 1 ? r = 2 : r = i / this.resolutions_[s + 1];
    } else
      i = this.maxResolution_, r = this.zoomFactor_;
    return t + Math.log(i / e) / Math.log(r);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    var t;
    if ((t = this.resolutions_) != null && t.length) {
      if (this.resolutions_.length === 1)
        return this.resolutions_[0];
      const i = De(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), r = this.resolutions_[i] / this.resolutions_[i + 1];
      return this.resolutions_[i] / Math.pow(r, De(e - i, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let i;
    if (ge(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      ge(
        !ao(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const r = yi(e, this.getProjection());
      i = pd(r);
    } else if (e.getType() === "Circle") {
      const r = yi(
        e.getExtent(),
        this.getProjection()
      );
      i = pd(r), i.rotate(this.getRotation(), nn(r));
    } else
      i = e;
    this.fitInternal(i, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), i = Math.cos(t), r = Math.sin(-t), s = e.getFlatCoordinates(), o = e.getStride();
    let a = 1 / 0, l = 1 / 0, c = -1 / 0, h = -1 / 0;
    for (let u = 0, d = s.length; u < d; u += o) {
      const f = s[u] * i - s[u + 1] * r, g = s[u] * r + s[u + 1] * i;
      a = Math.min(a, f), l = Math.min(l, g), c = Math.max(c, f), h = Math.max(h, g);
    }
    return [a, l, c, h];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let i = t.size;
    i || (i = this.getViewportSizeMinusPadding_());
    const r = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], s = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const a = this.rotatedExtentForGeometry(e);
    let l = this.getResolutionForExtentInternal(a, [
      i[0] - r[1] - r[3],
      i[1] - r[0] - r[2]
    ]);
    l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, s ? 0 : 1);
    const c = this.getRotation(), h = Math.sin(c), u = Math.cos(c), d = nn(a);
    d[0] += (r[1] - r[3]) / 2 * l, d[1] += (r[0] - r[2]) / 2 * l;
    const f = d[0] * u - d[1] * h, g = d[1] * u + d[0] * h, _ = this.getConstrainedCenter([f, g], l), m = t.callback ? t.callback : Gs;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: _,
        duration: t.duration,
        easing: t.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = _, this.applyTargetState_(!1, !0), Yo(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, i) {
    this.centerOnInternal(
      Bn(e, this.getProjection()),
      t,
      i
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, i) {
    this.setCenterInternal(
      ql(
        e,
        t,
        i,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, i, r) {
    let s;
    const o = this.padding_;
    if (o && e) {
      const a = this.getViewportSizeMinusPadding_(-i), l = ql(
        e,
        r,
        [a[0] / 2 + o[3], a[1] / 2 + o[0]],
        t,
        i
      );
      s = [
        e[0] - l[0],
        e[1] - l[1]
      ];
    }
    return s;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = Dc(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && Bn(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), s = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      r,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(s, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = Bn(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(
      this.targetRotation_ + e,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(r, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && Bn(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const i = this.getAnimating() || this.getInteracting() || t, r = this.constraints_.rotation(
      this.targetRotation_,
      i
    ), s = this.getViewportSize_(r), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      s,
      i
    ), a = this.constraints_.center(
      this.targetCenter_,
      o,
      s,
      i,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        r,
        s
      )
    );
    this.get(Qt.ROTATION) !== r && this.set(Qt.ROTATION, r), this.get(Qt.RESOLUTION) !== o && (this.set(Qt.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(Qt.CENTER) || !ca(this.get(Qt.CENTER), a)) && this.set(Qt.CENTER, a), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, i) {
    e = e !== void 0 ? e : 200;
    const r = t || 0, s = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(s), a = this.constraints_.resolution(
      this.targetResolution_,
      r,
      o
    ), l = this.constraints_.center(
      this.targetCenter_,
      a,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        s,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = a, this.targetRotation_ = s, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    i = i || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== s || !this.getCenterInternal() || !ca(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: s,
      center: l,
      resolution: a,
      duration: e,
      easing: Ii,
      anchor: i
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(Qe.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, i) {
    i = i && Bn(i, this.getProjection()), this.endInteractionInternal(e, t, i);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, i) {
    this.getInteracting() && (this.setHint(Qe.INTERACTING, -1), this.resolveConstraints(e, t, i));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      i
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const i = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(i, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, i);
  }
}
function Yo(n, e) {
  setTimeout(function() {
    n(e);
  }, 0);
}
function vv(n) {
  if (n.extent !== void 0) {
    const t = n.smoothExtentConstraint !== void 0 ? n.smoothExtentConstraint : !0;
    return Vd(n.extent, n.constrainOnlyCenter, t);
  }
  const e = Rh(n.projection, "EPSG:3857");
  if (n.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, Vd(t, !1, !1);
  }
  return fv;
}
function Ev(n) {
  let e, t, i, o = n.minZoom !== void 0 ? n.minZoom : Zl, a = n.maxZoom !== void 0 ? n.maxZoom : 28;
  const l = n.zoomFactor !== void 0 ? n.zoomFactor : 2, c = n.multiWorld !== void 0 ? n.multiWorld : !1, h = n.smoothResolutionConstraint !== void 0 ? n.smoothResolutionConstraint : !0, u = n.showFullExtent !== void 0 ? n.showFullExtent : !1, d = Rh(n.projection, "EPSG:3857"), f = d.getExtent();
  let g = n.constrainOnlyCenter, _ = n.extent;
  if (!c && !_ && d.isGlobal() && (g = !1, _ = f), n.resolutions !== void 0) {
    const m = n.resolutions;
    t = m[o], i = m[a] !== void 0 ? m[a] : m[m.length - 1], n.constrainResolution ? e = mv(
      m,
      h,
      !g && _,
      u
    ) : e = Xd(
      t,
      i,
      h,
      !g && _,
      u
    );
  } else {
    const y = (f ? Math.max(Ee(f), ut(f)) : (
      // use an extent that can fit the whole world if need be
      360 * Xr.degrees / d.getMetersPerUnit()
    )) / Zh / Math.pow(2, Zl), p = y / Math.pow(2, 28 - Zl);
    t = n.maxResolution, t !== void 0 ? o = 0 : t = y / Math.pow(l, o), i = n.minResolution, i === void 0 && (n.maxZoom !== void 0 ? n.maxResolution !== void 0 ? i = t / Math.pow(l, a) : i = y / Math.pow(l, a) : i = p), a = o + Math.floor(
      Math.log(t / i) / Math.log(l)
    ), i = t / Math.pow(l, a - o), n.constrainResolution ? e = _v(
      l,
      t,
      i,
      h,
      !g && _,
      u
    ) : e = Xd(
      t,
      i,
      h,
      !g && _,
      u
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: i,
    minZoom: o,
    zoomFactor: l
  };
}
function Tv(n) {
  if (n.enableRotation !== void 0 ? n.enableRotation : !0) {
    const t = n.constrainRotation;
    return t === void 0 || t === !0 ? yv() : t === !1 ? Hd : typeof t == "number" ? pv(t) : Hd;
  }
  return Kh;
}
function wv(n) {
  return !(n.sourceCenter && n.targetCenter && !ca(n.sourceCenter, n.targetCenter) || n.sourceResolution !== n.targetResolution || n.sourceRotation !== n.targetRotation);
}
function ql(n, e, t, i, r) {
  const s = Math.cos(-r);
  let o = Math.sin(-r), a = n[0] * s - n[1] * o, l = n[1] * s + n[0] * o;
  a += (e[0] / 2 - t[0]) * i, l += (t[1] - e[1] / 2) * i, o = -o;
  const c = a * s - l * o, h = l * s + a * o;
  return [c, h];
}
const ve = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class Ur extends Ft {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[ve.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, ge(
      typeof t[ve.OPACITY] == "number",
      "Layer opacity must be a number"
    ), t[ve.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[ve.Z_INDEX] = e.zIndex, t[ve.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[ve.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[ve.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[ve.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, i = this.getZIndex();
    return t.opacity = De(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = i === void 0 && !t.managed ? 1 / 0 : i, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return Q();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return Q();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(ve.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(ve.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(ve.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(ve.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(ve.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(ve.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Q();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(ve.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(ve.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(ve.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(ve.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(ve.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(ve.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(ve.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    ge(typeof e == "number", "Layer opacity must be a number"), this.set(ve.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(ve.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(ve.Z_INDEX, e);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
class ir extends Ur {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      ve.SOURCE,
      this.handleSourcePropertyChange_
    );
    const i = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(i);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(ve.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (Re(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = ce(
      e,
      ie.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let t;
    const i = this.getMapInternal();
    !e && i && (e = i.getView()), e instanceof xn ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e, !t.layerStatesArray && i && (t.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
    let r;
    if (t.layerStatesArray) {
      if (r = t.layerStatesArray.find(
        (o) => o.layer === this
      ), !r)
        return !1;
    } else
      r = this.getLayerState();
    const s = this.getExtent();
    return qh(r, t.viewState) && (!s || vt(s, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    var s;
    if (!this.isVisible(e))
      return [];
    const t = (s = this.getSource()) == null ? void 0 : s.getAttributions();
    if (!t)
      return [];
    const i = e instanceof xn ? e.getViewStateAndExtent() : e;
    let r = t(i);
    return Array.isArray(r) || (r = [r]), r;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, t) {
    const i = this.getRenderer();
    return i.prepareFrame(e) ? (this.rendered = !0, i.renderFrame(e, t)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const t = this.getRenderer();
    t && t.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(ve.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(ve.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (Re(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (Re(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = ce(
      e,
      et.PRECOMPOSE,
      this.handlePrecompose_,
      this
    ), this.mapRenderKey_ = ce(this, ie.CHANGE, e.render, e), this.changed());
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(e) {
    const t = (
      /** @type {import("../render/Event.js").default} */
      e.frameState.layerStatesArray
    ), i = this.getLayerState(!1);
    ge(
      !t.some(
        (r) => r.layer === i.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    ), t.push(i);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(ve.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */
  clearRenderer() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearRenderer(), this.setSource(null), super.disposeInternal();
  }
}
function qh(n, e) {
  if (!n.visible)
    return !1;
  const t = e.resolution;
  if (t < n.minResolution || t >= n.maxResolution)
    return !1;
  const i = e.zoom;
  return i > n.minZoom && i <= n.maxZoom;
}
const Kd = {
  RENDER_ORDER: "renderOrder"
};
class ol extends ir {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {import("../render.js").OrderFunction|null|undefined} Render order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Kd.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(e, t) {
    const i = this.getDeclutter();
    i in e.declutter || (e.declutter[i] = new Wg(9)), this.getRenderer().renderDeclutter(e, t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(Kd.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = e === void 0 ? $g : e;
    const t = Sv(e);
    this.styleFunction_ = e === null ? void 0 : cx(t), this.changed();
  }
  /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */
  setDeclutter(e) {
    this.declutter_ = e ? String(e) : void 0, this.changed();
  }
}
function Sv(n) {
  if (n === void 0)
    return $g;
  if (!n)
    return null;
  if (typeof n == "function" || n instanceof wt)
    return n;
  if (!Array.isArray(n))
    return Wd([n]);
  if (n.length === 0)
    return [];
  const e = n.length, t = n[0];
  if (t instanceof wt) {
    const r = new Array(e);
    for (let s = 0; s < e; ++s) {
      const o = n[s];
      if (!(o instanceof wt))
        throw new Error("Expected a list of style instances");
      r[s] = o;
    }
    return r;
  }
  if ("style" in t) {
    const r = new Array(e);
    for (let s = 0; s < e; ++s) {
      const o = n[s];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      r[s] = o;
    }
    return ev(r);
  }
  return Wd(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    n
  );
}
class Ks extends ol {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  /**
   * @override
   */
  createRenderer() {
    return new Ix(this);
  }
}
const Z = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class al extends Wa {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, i) {
    super(), i = i || {}, this.tileCoord = e, this.state = t, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(ie.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.setState(Z.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== Z.EMPTY) {
      if (this.state !== Z.ERROR && this.state > e)
        throw new Error("Tile load sequence violation");
      this.state = e, this.changed();
    }
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    Q();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let i = this.transitionStarts_[e];
    if (!i)
      i = t, this.transitionStarts_[e] = i;
    else if (i === -1)
      return 1;
    const r = t - i + 1e3 / 60;
    return r >= this.transition_ ? 1 : em(r / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release(), super.disposeInternal();
  }
}
class Jh extends al {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, r, s, o) {
    super(e, t, o), this.crossOrigin_ = r, this.src_ = i, this.key = i, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.unlisten_ = null, this.tileLoadFunction_ = s;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = Z.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = Z.ERROR, this.unlistenImage_(), this.image_ = bv(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = Z.LOADED : this.state = Z.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    this.state == Z.ERROR && (this.state = Z.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == Z.IDLE && (this.state = Z.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = P0(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_(), this.image_ = null, super.disposeInternal();
  }
}
function bv() {
  const n = je(1, 1);
  return n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1), n.canvas;
}
class Rv {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, i) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let i = t - 3;
    for (; i > 0 && this.points_[i + 2] > e; )
      i -= 3;
    const r = this.points_[t + 2] - this.points_[i + 2];
    if (r < 1e3 / 60)
      return !1;
    const s = this.points_[t] - this.points_[i], o = this.points_[t + 1] - this.points_[i + 1];
    return this.angle_ = Math.atan2(o, s), this.initialVelocity_ = Math.sqrt(s * s + o * o) / r, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
class Lr extends ai {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, i) {
    super(e), this.map = t, this.frameState = i !== void 0 ? i : null;
  }
}
class _i extends Lr {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, i, r, s, o) {
    super(e, t, s), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const ke = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: ie.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: ie.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, $c = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown"
};
class Cv extends Wa {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const i = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = ce(
      i,
      $c.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = ce(
      i,
      $c.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      ie.TOUCHMOVE,
      this.boundHandleTouchMove_,
      Pg ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new _i(
      ke.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new _i(
      ke.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const i = new _i(
        ke.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(i);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, i = t.pointerId;
    if (t.type == ke.POINTERUP || t.type == ke.POINTERCANCEL) {
      delete this.trackedTouches_[i];
      for (const r in this.trackedTouches_)
        if (this.trackedTouches_[r].target !== t.target) {
          delete this.trackedTouches_[r];
          break;
        }
    } else (t.type == ke.POINTERDOWN || t.type == ke.POINTERMOVE) && (this.trackedTouches_[i] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new _i(
      ke.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Re), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new _i(
      ke.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const i = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        ce(
          i,
          ke.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        ce(i, ke.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        ce(
          this.element_,
          ke.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(
        ce(
          this.element_.getRootNode(),
          ke.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new _i(
        ke.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new _i(
        ke.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.relayedListenerKey_ && (Re(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      ie.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (Re(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Re), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const Wn = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, lt = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, wa = 1 / 0;
class Pv {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Qr(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, i = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = /** @type {T} */
    e.pop(), t[0] = /** @type {number} */
    t.pop(), this.siftUp_(0));
    const r = this.keyFunction_(i);
    return delete this.queuedElements_[r], i;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    ge(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const t = this.priorityFunction_(e);
    return t != wa ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, i = this.priorities_, r = t.length, s = t[e], o = i[e], a = e;
    for (; e < r >> 1; ) {
      const l = this.getLeftChildIndex_(e), c = this.getRightChildIndex_(e), h = c < r && i[c] < i[l] ? c : l;
      t[e] = t[h], i[e] = i[h], e = h;
    }
    t[e] = s, i[e] = o, this.siftDown_(a, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const i = this.elements_, r = this.priorities_, s = i[t], o = r[t];
    for (; t > e; ) {
      const a = this.getParentIndex_(t);
      if (r[a] > o)
        i[t] = i[a], r[t] = r[a], t = a;
      else
        break;
    }
    i[t] = s, r[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, i = this.priorities_;
    let r = 0;
    const s = t.length;
    let o, a, l;
    for (a = 0; a < s; ++a)
      o = t[a], l = e(o), l == wa ? delete this.queuedElements_[this.keyFunction_(o)] : (i[r] = l, t[r++] = o);
    t.length = r, i.length = r, this.heapify_();
  }
}
class Iv extends Pv {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      (i) => e.apply(null, i),
      (i) => i[0].getKey()
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {TileQueueElement} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(ie.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), i = t.getState();
    if (i === Z.LOADED || i === Z.ERROR || i === Z.EMPTY) {
      i !== Z.ERROR && t.removeEventListener(ie.CHANGE, this.boundHandleTileChange_);
      const r = t.getKey();
      r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let i = 0;
    for (; this.tilesLoading_ < e && i < t && this.getCount() > 0; ) {
      const r = this.dequeue()[0], s = r.getKey();
      r.getState() === Z.IDLE && !(s in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[s] = !0, ++this.tilesLoading_, ++i, r.load());
    }
  }
}
function Av(n, e, t, i, r) {
  if (!n || !(t in n.wantedTiles) || !n.wantedTiles[t][e.getKey()])
    return wa;
  const s = n.viewState.center, o = i[0] - s[0], a = i[1] - s[1];
  return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r;
}
class hr extends Ft {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    var e;
    (e = this.element) == null || e.remove(), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    var t;
    this.map_ && ((t = this.element) == null || t.remove());
    for (let i = 0, r = this.listenerKeys.length; i < r; ++i)
      Re(this.listenerKeys[i]);
    if (this.listenerKeys.length = 0, this.map_ = e, e) {
      const i = this.target_ ?? e.getOverlayContainerStopEvent();
      this.element && i.appendChild(this.element), this.render !== Gs && this.listenerKeys.push(
        ce(e, Wn.POSTRENDER, this.render, this)
      ), e.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
class Lv extends hr {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = e.attributions;
    const t = e.className !== void 0 ? e.className : "ol-attribution", i = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", r = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", s = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s, this.collapseLabel_.className = o) : this.collapseLabel_ = s;
    const a = e.label !== void 0 ? e.label : "i";
    typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = r) : this.label_ = a;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      ie.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const c = t + " " + uo + " " + Yh + (this.collapsed_ && this.collapsible_ ? " " + vd : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element;
    h.className = c, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = this.getMap().getAllLayers(), i = new Set(
      t.flatMap((r) => r.getAttributions(e))
    );
    if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((r) => i.add(r)) : i.add(this.attributions_)), !this.overrideCollapsible_) {
      const r = !t.some(
        (s) => {
          var o;
          return ((o = s.getSource()) == null ? void 0 : o.getAttributionsCollapsible()) === !1;
        }
      );
      this.setCollapsible(r);
    }
    return Array.from(i);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = await Promise.all(
      this.collectSourceAttributions_(e).map(
        (r) => ty(() => r)
      )
    ), i = t.length > 0;
    if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !oi(t, this.renderedAttributions_)) {
      Ig(this.ulElement_);
      for (let r = 0, s = t.length; r < s; ++r) {
        const o = document.createElement("li");
        o.innerHTML = t[r], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(vd), this.collapsed_ ? yd(this.collapseLabel_, this.label_) : yd(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
class Ov extends hr {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", i = e.label !== void 0 ? e.label : "⇧", r = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(r));
    const s = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = s, o.appendChild(this.label_), o.addEventListener(
      ie.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = t + " " + uo + " " + Yh, l = this.element;
    l.className = a, l.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Go);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const i = t.getRotation();
    i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: Ii
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const i = t.viewState.rotation;
    if (i != this.rotation_) {
      const r = "rotate(" + i + "rad)";
      if (this.autoHide_) {
        const s = this.element.classList.contains(Go);
        !s && i === 0 ? this.element.classList.add(Go) : s && i !== 0 && this.element.classList.remove(Go);
      }
      this.label_.style.transform = r;
    }
    this.rotation_ = i;
  }
}
class Mv extends hr {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", i = e.delta !== void 0 ? e.delta : 1, r = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", s = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", l = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", c = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", h = document.createElement("button");
    h.className = r, h.setAttribute("type", "button"), h.title = l, h.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), h.addEventListener(
      ie.CLICK,
      this.handleClick_.bind(this, i),
      !1
    );
    const u = document.createElement("button");
    u.className = s, u.setAttribute("type", "button"), u.title = c, u.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), u.addEventListener(
      ie.CLICK,
      this.handleClick_.bind(this, -i),
      !1
    );
    const d = t + " " + uo + " " + Yh, f = this.element;
    f.className = d, f.appendChild(h), f.appendChild(u), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const i = this.getMap().getView();
    if (!i)
      return;
    const r = i.getZoom();
    if (r !== void 0) {
      const s = i.getConstrainedZoom(r + e);
      this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({
        zoom: s,
        duration: this.duration_,
        easing: Ii
      })) : i.setZoom(s);
    }
  }
}
function nm(n) {
  n = n || {};
  const e = new En();
  return (n.zoom !== void 0 ? n.zoom : !0) && e.push(new Mv(n.zoomOptions)), (n.rotate !== void 0 ? n.rotate : !0) && e.push(new Ov(n.rotateOptions)), (n.attribution !== void 0 ? n.attribution : !0) && e.push(new Lv(n.attributionOptions)), e;
}
const Zd = {
  ACTIVE: "active"
};
class po extends Ft {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Zd.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(Zd.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function Dv(n, e, t) {
  const i = n.getCenterInternal();
  if (i) {
    const r = [i[0] + e[0], i[1] + e[1]];
    n.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: tm,
      center: n.getConstrainedCenter(r)
    });
  }
}
function Qh(n, e, t, i) {
  const r = n.getZoom();
  if (r === void 0)
    return;
  const s = n.getConstrainedZoom(r + e), o = n.getResolutionForZoom(s);
  n.getAnimating() && n.cancelAnimations(), n.animate({
    resolution: o,
    anchor: t,
    duration: i !== void 0 ? i : 250,
    easing: Ii
  });
}
class Fv extends po {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == ke.DBLCLICK) {
      const i = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), r = e.map, s = e.coordinate, o = i.shiftKey ? -this.delta_ : this.delta_, a = r.getView();
      Qh(a, o, s, this.duration_), i.preventDefault(), t = !0;
    }
    return !t;
  }
}
function jc(n) {
  const e = arguments;
  return function(t) {
    let i = !0;
    for (let r = 0, s = e.length; r < s && (i = i && e[r](t), !!i); ++r)
      ;
    return i;
  };
}
const kv = function(n) {
  const e = n.originalEvent;
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, Nv = function(n) {
  const e = n.originalEvent;
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, Gv = function(n) {
  const e = n.map.getTargetElement(), t = e.getRootNode(), i = n.map.getOwnerDocument().activeElement;
  return t instanceof ShadowRoot ? t.host.contains(i) : e.contains(i);
}, im = function(n) {
  const e = n.map.getTargetElement(), t = e.getRootNode();
  return (t instanceof ShadowRoot ? t.host : e).hasAttribute("tabindex") ? Gv(n) : !0;
}, Uv = Ns, rm = function(n) {
  const e = n.originalEvent;
  return "pointerId" in e && e.button == 0 && !(m0 && Rg && e.ctrlKey);
}, sm = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, Bv = function(n) {
  const e = n.originalEvent;
  return Rg ? e.metaKey : e.ctrlKey;
}, zv = function(n) {
  const e = n.originalEvent;
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, om = function(n) {
  const e = n.originalEvent, t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, Jl = function(n) {
  const e = n.originalEvent;
  return "pointerId" in e && e.pointerType == "mouse";
}, Wv = function(n) {
  const e = n.originalEvent;
  return "pointerId" in e && e.isPrimary && e.button === 0;
};
class yo extends po {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == ke.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == ke.POINTERUP) {
        const i = this.handleUpEvent(e);
        this.handlingDownUpSequence = i && this.targetPointers.length > 0;
      }
    } else if (e.type == ke.POINTERDOWN) {
      const i = this.handleDownEvent(e);
      this.handlingDownUpSequence = i, t = this.stopDown(i);
    } else e.type == ke.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function eu(n) {
  const e = n.length;
  let t = 0, i = 0;
  for (let r = 0; r < e; r++)
    t += n[r].clientX, i += n[r].clientY;
  return { clientX: t / e, clientY: i / e };
}
class Yv extends yo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: za
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : jc(sm, Wv);
    this.condition_ = e.onFocusOnly ? jc(im, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const i = this.targetPointers, r = t.getEventPixel(eu(i));
    if (i.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(r[0], r[1]), this.lastCentroid) {
        const s = [
          this.lastCentroid[0] - r[0],
          r[1] - this.lastCentroid[1]
        ], a = e.map.getView();
        rg(s, a.getResolution()), Eh(s, a.getRotation()), a.adjustCenterInternal(s);
      }
    } else this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = r, this.lastPointersCount_ = i.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    const t = e.map, i = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const r = this.kinetic_.getDistance(), s = this.kinetic_.getAngle(), o = i.getCenterInternal(), a = t.getPixelFromCoordinateInternal(o), l = t.getCoordinateFromPixelInternal([
          a[0] - r * Math.cos(s),
          a[1] - r * Math.sin(s)
        ]);
        i.animateInternal({
          center: i.getConstrainedCenter(l),
          duration: 500,
          easing: Ii
        });
      }
      return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const i = e.map.getView();
      return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
class $v extends yo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: za
    }), this.condition_ = e.condition ? e.condition : Nv, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    if (!Jl(e))
      return;
    const t = e.map, i = t.getView();
    if (i.getConstraints().rotation === Kh)
      return;
    const r = t.getSize(), s = e.pixel, o = Math.atan2(r[1] / 2 - s[1], s[0] - r[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const a = o - this.lastAngle_;
      i.adjustRotationInternal(-a);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    return Jl(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    return Jl(e) && rm(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
class jv extends so {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, i = "px", r = this.element_.style;
    r.left = Math.min(e[0], t[0]) + i, r.top = Math.min(e[1], t[1]) + i, r.width = Math.abs(t[0] - e[0]) + i, r.height = Math.abs(t[1] - e[1]) + i;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const e = this.startPixel_, t = this.endPixel_, r = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new Ci([r]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const Er = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class xs extends ai {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, i) {
    super(e), this.coordinate = t, this.mapBrowserEvent = i;
  }
}
class Vv extends yo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e ?? {}, this.box_ = new jv(e.className || "ol-dragbox"), this.minArea_ = e.minArea ?? 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ?? rm, this.boxEndCondition_ = e.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, i) {
    const r = i[0] - t[0], s = i[1] - t[1];
    return r * r + s * s >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new xs(
        Er.BOXDRAG,
        e.coordinate,
        e
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    if (!this.startPixel_)
      return !1;
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new xs(
        t ? Er.BOXEND : Er.BOXCANCEL,
        e.coordinate,
        e
      )
    ), this.box_.setMap(null), this.startPixel_ = null, !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new xs(
        Er.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(e) {
    e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new xs(Er.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(e);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(e) {
    this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new xs(Er.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setMap(e);
  }
}
class Xv extends Vv {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : zv;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(e) {
    const i = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let r = this.getGeometry();
    if (this.out_) {
      const s = i.rotatedExtentForGeometry(r), o = i.getResolutionForExtentInternal(s), a = i.getResolution() / o;
      r = r.clone(), r.scale(a * a);
    }
    i.fitInternal(r, {
      duration: this.duration_,
      easing: Ii
    });
  }
}
const Fi = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class Hv extends po {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return sm(t) && om(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == ie.KEYDOWN) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), r = i.key;
      if (this.condition_(e) && (r == Fi.DOWN || r == Fi.LEFT || r == Fi.RIGHT || r == Fi.UP)) {
        const o = e.map.getView(), a = o.getResolution() * this.pixelDelta_;
        let l = 0, c = 0;
        r == Fi.DOWN ? c = -a : r == Fi.LEFT ? l = -a : r == Fi.RIGHT ? l = a : c = a;
        const h = [l, c];
        Eh(h, o.getRotation()), Dv(o, h, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
class Kv extends po {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(t) {
      return !Bv(t) && om(t);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == ie.KEYDOWN || e.type == ie.KEYPRESS) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), r = i.key;
      if (this.condition_(e) && (r === "+" || r === "-")) {
        const s = e.map, o = r === "+" ? this.delta_ : -this.delta_, a = s.getView();
        Qh(a, o, void 0, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const Zv = 40, qv = 300;
class Jv extends po {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : Uv;
    this.condition_ = e.onFocusOnly ? jc(im, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== ie.WHEEL)
      return !0;
    const i = e.map, r = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.pixel);
    let s = r.deltaY;
    switch (r.deltaMode) {
      case WheelEvent.DOM_DELTA_LINE:
        s *= Zv;
        break;
      case WheelEvent.DOM_DELTA_PAGE:
        s *= qv;
        break;
    }
    if (s === 0)
      return !1;
    this.lastDelta_ = s;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
    const a = i.getView();
    if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), a.adjustZoom(
        -s / this.deltaPerZoom_,
        this.lastAnchor_ ? i.getCoordinateFromPixel(this.lastAnchor_) : null
      ), this.startTime_ = o, !1;
    this.totalDelta_ += s;
    const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, i),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let i = -De(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), Qh(
      t,
      i,
      this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
class Qv extends yo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = za), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    let t = 0;
    const i = this.targetPointers[0], r = this.targetPointers[1], s = Math.atan2(
      r.clientY - i.clientY,
      r.clientX - i.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const l = s - this.lastAngle_;
      this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = l;
    }
    this.lastAngle_ = s;
    const o = e.map, a = o.getView();
    a.getConstraints().rotation !== Kh && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(eu(this.targetPointers))
    ), this.rotating_ && (o.render(), a.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
class eE extends yo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = za), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    let t = 1;
    const i = this.targetPointers[0], r = this.targetPointers[1], s = i.clientX - r.clientX, o = i.clientY - r.clientY, a = Math.sqrt(s * s + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / a), this.lastDistance_ = a;
    const l = e.map, c = l.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = l.getCoordinateFromPixelInternal(
      l.getEventPixel(eu(this.targetPointers))
    ), l.render(), c.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const i = e.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
      return i.endInteraction(this.duration_, r), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
function am(n) {
  n = n || {};
  const e = new En(), t = new Rv(-5e-3, 0.05, 100);
  return (n.altShiftDragRotate !== void 0 ? n.altShiftDragRotate : !0) && e.push(new $v()), (n.doubleClickZoom !== void 0 ? n.doubleClickZoom : !0) && e.push(
    new Fv({
      delta: n.zoomDelta,
      duration: n.zoomDuration
    })
  ), (n.dragPan !== void 0 ? n.dragPan : !0) && e.push(
    new Yv({
      onFocusOnly: n.onFocusOnly,
      kinetic: t
    })
  ), (n.pinchRotate !== void 0 ? n.pinchRotate : !0) && e.push(new Qv()), (n.pinchZoom !== void 0 ? n.pinchZoom : !0) && e.push(
    new eE({
      duration: n.zoomDuration
    })
  ), (n.keyboard !== void 0 ? n.keyboard : !0) && (e.push(new Hv()), e.push(
    new Kv({
      delta: n.zoomDelta,
      duration: n.zoomDuration
    })
  )), (n.mouseWheelZoom !== void 0 ? n.mouseWheelZoom : !0) && e.push(
    new Jv({
      onFocusOnly: n.onFocusOnly,
      duration: n.zoomDuration
    })
  ), (n.shiftDragZoom !== void 0 ? n.shiftDragZoom : !0) && e.push(
    new Xv({
      duration: n.zoomDuration
    })
  ), e;
}
class pi extends ai {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const Ql = {
  LAYERS: "layers"
};
class Xt extends Ur {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let i = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(Ql.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new En(i.slice(), { unique: !0 }) : ge(
      typeof /** @type {?} */
      i.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : i = new En(void 0, { unique: !0 }), this.setLayers(i);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(Re), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      ce(e, Pt.ADD, this.handleLayersAdd_, this),
      ce(
        e,
        Pt.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const i in this.listenerKeys_)
      this.listenerKeys_[i].forEach(Re);
    Qr(this.listenerKeys_);
    const t = e.getArray();
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.registerLayerListeners_(s), this.dispatchEvent(new pi("addlayer", s));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      ce(
        e,
        $r.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      ce(e, ie.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof Xt && t.push(
      ce(e, "addlayer", this.handleLayerGroupAdd_, this),
      ce(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[q(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new pi("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new pi("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new pi("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, i = q(t);
    this.listenerKeys_[i].forEach(Re), delete this.listenerKeys_[i], this.dispatchEvent(new pi("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Ql.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const i = t.getArray();
      for (let r = 0, s = i.length; r < s; ++r)
        this.dispatchEvent(new pi("removelayer", i[r]));
    }
    this.set(Ql.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], i = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const r = this.getLayerState();
    let s = r.zIndex;
    !e && r.zIndex === void 0 && (s = 0);
    for (let o = i, a = t.length; o < a; o++) {
      const l = t[o];
      l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(
        l.maxResolution,
        r.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        r.minResolution
      ), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = Vi(
        l.extent,
        r.extent
      ) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = s);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
}
class tE extends so {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    Q();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, i = e.coordinateToPixelTransform, r = e.pixelToCoordinateTransform;
    sn(
      i,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), Bs(r, i);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, i, r, s, o, a, l) {
    let c;
    const h = t.viewState;
    function u(x, v, S, w) {
      return s.call(o, v, x ? S : null, w);
    }
    const d = h.projection, f = sg(e.slice(), d), g = [[0, 0]];
    if (d.canWrapX() && r) {
      const x = d.getExtent(), v = Ee(x);
      g.push([-v, 0], [v, 0]);
    }
    const _ = t.layerStatesArray, m = _.length, y = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), p = [];
    for (let x = 0; x < g.length; x++)
      for (let v = m - 1; v >= 0; --v) {
        const S = _[v], w = S.layer;
        if (w.hasRenderer() && qh(S, h) && a.call(l, w)) {
          const b = w.getRenderer(), P = w.getSource();
          if (b && P) {
            const O = P.getWrapX() ? f : e, N = u.bind(
              null,
              S.managed
            );
            p[0] = O[0] + g[x][0], p[1] = O[1] + g[x][1], c = b.forEachFeatureAtCoordinate(
              p,
              t,
              i,
              N,
              y
            );
          }
          if (c)
            return c;
        }
      }
    if (y.length === 0)
      return;
    const E = 1 / y.length;
    return y.forEach((x, v) => x.distanceSq += v * E), y.sort((x, v) => x.distanceSq - v.distanceSq), y.some((x) => c = x.callback(x.feature, x.layer, x.geometry)), c;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, i, r, s, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      i,
      r,
      Ns,
      this,
      s,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    Q();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    $t.canExpireCache() && e.postRenderFunctions.push(nE);
  }
}
function nE(n, e) {
  $t.expire();
}
class iE extends tE {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = ce(
      Pr,
      $r.PROPERTYCHANGE,
      e.redrawText,
      e
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = uo + " ol-layers";
    const i = e.getViewport();
    i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(e, t) {
    const i = this.getMap();
    if (i.hasListener(e)) {
      const r = new Os(e, void 0, t);
      i.dispatchEvent(r);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    Re(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(et.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(
      (a, l) => a.zIndex - l.zIndex
    );
    t.some(
      (a) => a.layer instanceof ol && a.layer.getDeclutter()
    ) && (e.declutter = {});
    const r = e.viewState;
    this.children_.length = 0;
    const s = [];
    let o = null;
    for (let a = 0, l = t.length; a < l; ++a) {
      const c = t[a];
      e.layerIndex = a;
      const h = c.layer, u = h.getSourceState();
      if (!qh(c, r) || u != "ready" && u != "undefined") {
        h.unrender();
        continue;
      }
      const d = h.render(e, o);
      d && (d !== o && (this.children_.push(d), o = d), s.push(c));
    }
    this.declutter(e, s), x0(this.element_, this.children_), this.dispatchRenderEvent(et.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, t) {
    if (e.declutter) {
      for (let i = t.length - 1; i >= 0; --i) {
        const r = t[i], s = r.layer;
        s.getDeclutter() && s.renderDeclutter(e, r);
      }
      t.forEach(
        (i) => i.layer.renderDeferred(e)
      );
    }
  }
}
function lm(n) {
  if (n instanceof ir) {
    n.setMapInternal(null);
    return;
  }
  n instanceof Xt && n.getLayers().forEach(lm);
}
function cm(n, e) {
  if (n instanceof ir) {
    n.setMapInternal(e);
    return;
  }
  if (n instanceof Xt) {
    const t = n.getLayers().getArray();
    for (let i = 0, r = t.length; i < r; ++i)
      cm(t[i], e);
  }
}
let Zi = class extends Ft {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = rE(e);
    this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : _0, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = Ke(), this.pixelToCoordinateTransform_ = Ke(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || nm(), this.interactions = t.interactions || am({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Iv(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      lt.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(lt.VIEW, this.handleViewChanged_), this.addChangeListener(lt.SIZE, this.handleSizeChanged_), this.addChangeListener(lt.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const i = this;
    e.view && !(e.view instanceof xn) && e.view.then(function(r) {
      i.setView(new xn(r));
    }), this.controls.addEventListener(
      Pt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Pt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Pt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Pt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Pt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        this.addOverlayInternal_(r.element);
      }
    ), this.overlays_.addEventListener(
      Pt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        const s = r.element.getId();
        s !== void 0 && delete this.overlayIdIndex_[s.toString()], r.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    cm(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, i) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const r = this.getCoordinateFromPixelInternal(e);
    i = i !== void 0 ? i : {};
    const s = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.layerFilter !== void 0 ? i.layerFilter : Ns, a = i.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      r,
      this.frameState_,
      s,
      a,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const i = [];
    return this.forEachFeatureAtPixel(
      e,
      function(r) {
        i.push(r);
      },
      t
    ), i;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(i) {
      i.forEach(function(r) {
        r instanceof Xt ? t(r.getLayers()) : e.push(r);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const i = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const r = t.layerFilter !== void 0 ? t.layerFilter : Ns, s = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      i,
      this.frameState_,
      s,
      o,
      r,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const i = this.viewport_.getBoundingClientRect(), r = this.getSize(), s = i.width / r[0], o = i.height / r[1], a = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (a.clientX - i.left) / s,
      (a.clientY - i.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(lt.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return Dc(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? Ue(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(lt.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof En) {
      t.setLayers(e);
      return;
    }
    const i = t.getLayers();
    i.clear(), i.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, i = e.length; t < i; ++t) {
      const r = e[t];
      if (!r.visible)
        continue;
      const s = r.layer.getRenderer();
      if (s && !s.ready)
        return !0;
      const o = r.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = Bn(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? Ue(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(lt.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(lt.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, i, r) {
    return Av(
      this.frameState_,
      e,
      t,
      i,
      r
    );
  }
  /**
   * @param {PointerEvent|KeyboardEvent|WheelEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const i = new _i(t, this, e);
    this.handleMapBrowserEvent(i);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = e.originalEvent, i = t.type;
    if (i === $c.POINTERDOWN || i === ie.WHEEL || i === ie.KEYDOWN) {
      const r = this.getOwnerDocument(), s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, o = (
        /** @type {Node} */
        t.target
      ), a = s instanceof ShadowRoot ? s.host === o ? s.host.ownerDocument : s : s === r ? r.documentElement : s;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !a.contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const r = this.getInteractions().getArray().slice();
      for (let s = r.length - 1; s >= 0; s--) {
        const o = r[s];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let r = this.maxTilesLoading_, s = r;
      if (e) {
        const o = e.viewHints;
        if (o[Qe.ANIMATING] || o[Qe.INTERACTING]) {
          const a = Date.now() - e.time > 8;
          r = a ? 0 : 8, s = a ? 0 : 2;
        }
      }
      t.getTilesLoading() < r && (t.reprioritize(), t.loadMoreTiles(r, s));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ ? (this.hasListener(et.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      et.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new Lr(Wn.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new Lr(Wn.LOADSTART, this, e)
    )));
    const i = this.postRenderFunctions_;
    if (e)
      for (let r = 0, s = i.length; r < s; ++r)
        i[r](this, e);
    i.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, r = this.targetChangeHandlerKeys_.length; i < r; ++i)
        Re(this.targetChangeHandlerKeys_[i]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        ie.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        ie.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const i = this.targetElement_.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host), this.setSize(void 0);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new iE(this)), this.mapBrowserEventHandler_ = new Cv(
        this,
        this.moveTolerance_
      );
      for (const s in ke)
        this.mapBrowserEventHandler_.addEventListener(
          ke[s],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        ie.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        ie.WHEEL,
        this.boundHandleBrowserEvent_,
        Pg ? { passive: !1 } : !1
      );
      let i;
      if (this.keyboardEventTarget_)
        i = this.keyboardEventTarget_;
      else {
        const s = t.getRootNode();
        i = s instanceof ShadowRoot ? s.host : t;
      }
      this.targetChangeHandlerKeys_ = [
        ce(
          i,
          ie.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        ce(
          i,
          ie.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const r = t.getRootNode();
      r instanceof ShadowRoot && this.resizeObserver_.observe(r.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (Re(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Re(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = ce(
      e,
      $r.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = ce(
      e,
      ie.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Re), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new pi("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      ce(e, $r.PROPERTYCHANGE, this.render, this),
      ce(e, ie.CHANGE, this.render, this),
      ce(e, "addlayer", this.handleLayerAdd_, this),
      ce(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    if (!this.frameState_)
      return;
    const e = this.frameState_.layerStatesArray;
    for (let t = 0, i = e.length; t < i; ++t) {
      const r = e[t].layer;
      r.hasRenderer() && r.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    lm(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), i = this.getView(), r = this.frameState_;
    let s = null;
    if (t !== void 0 && Ld(t) && i && i.isDef()) {
      const o = i.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), a = i.getState();
      if (s = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: Ic(
          a.center,
          a.resolution,
          a.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: a,
        viewHints: o,
        wantedTiles: {},
        mapId: q(this),
        renderTargets: {}
      }, a.nextCenter && a.nextResolution) {
        const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
        s.nextExtent = Ic(
          a.nextCenter,
          a.nextResolution,
          l,
          t
        );
      }
    }
    this.frameState_ = s, this.renderer_.renderFrame(s), s && (s.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      s.postRenderFunctions
    ), r && (!this.previousExtent_ || !ao(this.previousExtent_) && !Vr(s.extent, this.previousExtent_)) && (this.dispatchEvent(
      new Lr(Wn.MOVESTART, this, r)
    ), this.previousExtent_ = es(this.previousExtent_)), this.previousExtent_ && !s.viewHints[Qe.ANIMATING] && !s.viewHints[Qe.INTERACTING] && !Vr(s.extent, this.previousExtent_) && (this.dispatchEvent(
      new Lr(Wn.MOVEEND, this, s)
    ), Xf(s.extent, this.previousExtent_))), this.dispatchEvent(new Lr(Wn.POSTRENDER, this, s)), this.renderComplete_ = (this.hasListener(Wn.LOADSTART) || this.hasListener(Wn.LOADEND) || this.hasListener(et.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new pi("removelayer", t)), this.set(lt.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(lt.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(lt.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>|null} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof xn) {
      this.set(lt.VIEW, e);
      return;
    }
    this.set(lt.VIEW, new xn());
    const t = this;
    e.then(function(i) {
      t.setView(new xn(i));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const r = getComputedStyle(e), s = e.offsetWidth - parseFloat(r.borderLeftWidth) - parseFloat(r.paddingLeft) - parseFloat(r.paddingRight) - parseFloat(r.borderRightWidth), o = e.offsetHeight - parseFloat(r.borderTopWidth) - parseFloat(r.paddingTop) - parseFloat(r.paddingBottom) - parseFloat(r.borderBottomWidth);
      !isNaN(s) && !isNaN(o) && (t = [Math.max(0, s), Math.max(0, o)], !Ld(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && tg(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const i = this.getSize();
    t && (!i || !oi(t, i)) && (this.setSize(t), this.updateViewportSize_(t));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const t = this.getView();
    t && t.setViewportSize(e);
  }
};
function rE(n) {
  let e = null;
  n.keyboardEventTarget !== void 0 && (e = typeof n.keyboardEventTarget == "string" ? document.getElementById(n.keyboardEventTarget) : n.keyboardEventTarget);
  const t = {}, i = n.layers && typeof /** @type {?} */
  n.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    n.layers
  ) : new Xt({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      n.layers
    )
  });
  t[lt.LAYERGROUP] = i, t[lt.TARGET] = n.target, t[lt.VIEW] = n.view instanceof xn ? n.view : new xn();
  let r;
  n.controls !== void 0 && (Array.isArray(n.controls) ? r = new En(n.controls.slice()) : (ge(
    typeof /** @type {?} */
    n.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), r = n.controls));
  let s;
  n.interactions !== void 0 && (Array.isArray(n.interactions) ? s = new En(n.interactions.slice()) : (ge(
    typeof /** @type {?} */
    n.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), s = n.interactions));
  let o;
  return n.overlays !== void 0 ? Array.isArray(n.overlays) ? o = new En(n.overlays.slice()) : (ge(
    typeof /** @type {?} */
    n.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = n.overlays) : o = new En(), {
    controls: r,
    interactions: s,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const at = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class sE extends Ft {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + M0, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(at.ELEMENT, this.handleElementChanged), this.addChangeListener(at.MAP, this.handleMapChanged), this.addChangeListener(at.OFFSET, this.handleOffsetChanged), this.addChangeListener(at.POSITION, this.handlePositionChanged), this.addChangeListener(at.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(at.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(at.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(at.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(at.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(at.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    Ig(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    var t;
    this.mapPostrenderListenerKey && ((t = this.element) == null || t.remove(), Re(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = ce(
        e,
        Wn.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const i = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? i.insertBefore(this.element, i.childNodes[0] || null) : i.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(at.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(at.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(at.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(at.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(at.POSITION))
      return;
    const i = this.getRect(t.getTargetElement(), t.getSize()), r = this.getElement(), s = this.getRect(r, [
      p0(r),
      y0(r)
    ]);
    e = e || {};
    const o = e.margin === void 0 ? 20 : e.margin;
    if (!Mr(i, s)) {
      const a = s[0] - i[0], l = i[2] - s[2], c = s[1] - i[1], h = i[3] - s[3], u = [0, 0];
      if (a < 0 ? u[0] = a - o : l < 0 && (u[0] = Math.abs(l) + o), c < 0 ? u[1] = c - o : h < 0 && (u[1] = Math.abs(h) + o), u[0] !== 0 || u[1] !== 0) {
        const d = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), f = t.getPixelFromCoordinateInternal(d);
        if (!f)
          return;
        const g = [f[0] + u[0], f[1] + u[1]], _ = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(g),
          duration: _.duration,
          easing: _.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const i = e.getBoundingClientRect(), r = i.left + window.pageXOffset, s = i.top + window.pageYOffset;
    return [r, s, r + t[0], s + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(at.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const i = e.getPixelFromCoordinate(t), r = e.getSize();
    this.updateRenderedPosition(i, r);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const i = this.element.style, r = this.getOffset(), s = this.getPositioning();
    this.setVisible(!0);
    const o = `${e[0] + r[0]}px`, a = `${e[1] + r[1]}px`;
    let l = "0%", c = "0%";
    s == "bottom-right" || s == "center-right" || s == "top-right" ? l = "-100%" : (s == "bottom-center" || s == "center-center" || s == "top-center") && (l = "-50%"), s == "bottom-left" || s == "bottom-center" || s == "bottom-right" ? c = "-100%" : (s == "center-left" || s == "center-center" || s == "center-right") && (c = "-50%");
    const h = `translate(${l}, ${c}) translate(${o}, ${a})`;
    this.rendered.transform_ != h && (this.rendered.transform_ = h, i.transform = h);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
class tu {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, i, r) {
    this.minX = e, this.maxX = t, this.minY = i, this.maxY = r;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Tr(n, e, t, i, r) {
  return r !== void 0 ? (r.minX = n, r.maxX = e, r.minY = t, r.maxY = i, r) : new tu(n, e, t, i);
}
const ec = "units", oE = [1, 2, 5], vs = 25.4 / 0.28;
class aE extends hr {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const i = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = i + "-inner", this.element.className = i + " " + uo, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(ec, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(ec);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(ec, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, i = e.projection, r = this.getUnits(), s = r == "degrees" ? "degrees" : "m";
    let o = da(
      i,
      e.resolution,
      t,
      s
    );
    const a = this.minWidth_ * (this.dpi_ || vs) / vs, l = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || vs) / vs : void 0;
    let c = a * o, h = "";
    if (r == "degrees") {
      const E = Xr.degrees;
      c *= E, c < E / 60 ? (h = "″", o *= 3600) : c < E ? (h = "′", o *= 60) : h = "°";
    } else if (r == "imperial")
      c < 0.9144 ? (h = "in", o /= 0.0254) : c < 1609.344 ? (h = "ft", o /= 0.3048) : (h = "mi", o /= 1609.344);
    else if (r == "nautical")
      o /= 1852, h = "NM";
    else if (r == "metric")
      c < 1e-6 ? (h = "nm", o *= 1e9) : c < 1e-3 ? (h = "μm", o *= 1e6) : c < 1 ? (h = "mm", o *= 1e3) : c < 1e3 ? h = "m" : (h = "km", o /= 1e3);
    else if (r == "us")
      c < 0.9144 ? (h = "in", o *= 39.37) : c < 1609.344 ? (h = "ft", o /= 0.30480061) : (h = "mi", o /= 1609.3472);
    else
      throw new Error("Invalid units");
    let u = 3 * Math.floor(Math.log(a * o) / Math.log(10)), d, f, g, _ = 0, m, y;
    for (; ; ) {
      g = Math.floor(u / 3);
      const E = Math.pow(10, g);
      if (d = oE[(u % 3 + 3) % 3] * E, f = Math.round(d / o), isNaN(f)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (l !== void 0 && f >= l) {
        d = _, f = m, g = y;
        break;
      } else if (f >= a)
        break;
      _ = d, m = f, y = g, ++u;
    }
    const p = this.scaleBar_ ? this.createScaleBar(f, d, h) : d.toFixed(g < 0 ? -g : 0) + " " + h;
    this.renderedHTML_ != p && (this.innerElement_.innerHTML = p, this.renderedHTML_ = p), this.renderedWidth_ != f && (this.innerElement_.style.width = f + "px", this.renderedWidth_ = f), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, i) {
    const r = this.getScaleForResolution(), s = r < 1 ? Math.round(1 / r).toLocaleString() + " : 1" : "1 : " + Math.round(r).toLocaleString(), o = this.scaleBarSteps_, a = e / o, l = [this.createMarker("absolute")];
    for (let h = 0; h < o; ++h) {
      const u = h % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      l.push(
        `<div><div class="ol-scale-singlebar ${u}" style="width: ${a}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (h % 2 === 0 || o === 2 ? this.createStepText(h, e, !1, t, i) : "") + "</div>"
      );
    }
    return l.push(this.createStepText(o, e, !0, t, i)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + s + "</div>" : "") + l.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, i, r, s) {
    const a = (e === 0 ? 0 : Math.round(r / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + s), l = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, c = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${l}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${c}px;left: ${i ? t + "px" : "unset"};">` + a + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = da(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || vs, i = 1e3 / 25.4;
    return e * i * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
}
var lE = function(n) {
  if (!n) return null;
  var e = n.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
  return e || (n.getViewport().querySelector(".ol-layers") ? (e = document.createElement("canvas"), e.className = "ol-fixedoverlay", n.getViewport().querySelector(".ol-layers").after(e), n.on("precompose", function(t) {
    e.width = n.getSize()[0] * t.frameState.pixelRatio, e.height = n.getSize()[1] * t.frameState.pixelRatio;
  })) : e = n.getViewport().querySelector("canvas")), e;
}, Vc = class extends hr {
  constructor(e) {
    e = e || {}, super(e), this.setStyle(e.style);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol_Map} map Map.
   * @api stable
   */
  setMap(e) {
    this.getCanvas(e);
    var t = this.getMap();
    if (this._listener && (Pi(this._listener), this._listener = null), super.setMap(e), t)
      try {
        t.renderSync();
      } catch {
      }
    e && (this._listener = e.on("postcompose", this._draw.bind(this)));
  }
  /** Get canvas overlay
   */
  getCanvas(e) {
    return lE(e);
  }
  /** Get map Canvas
   * @private
   */
  getContext(e) {
    var t = e.context;
    if (!t && this.getMap()) {
      var i = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
      t = i ? i.getContext("2d") : null;
    }
    return t;
  }
  /** Set Style
   * @api
   */
  setStyle(e) {
    this._style = e || new wt({});
  }
  /** Get style
   * @api
   */
  getStyle() {
    return this._style;
  }
  /** Get stroke
   * @api
   */
  getStroke() {
    var e = this._style.getStroke();
    return e || this._style.setStroke(new Gt({ color: "#000", width: 1.25 })), this._style.getStroke();
  }
  /** Get fill
   * @api
   */
  getFill() {
    var e = this._style.getFill();
    return e || this._style.setFill(new ri({ color: "#fff" })), this._style.getFill();
  }
  /** Get stroke
   * @api
   */
  getTextStroke() {
    var e = this._style.getText();
    return e || (e = new Ki({})), e.getStroke() || e.setStroke(new Gt({ color: "#fff", width: 3 })), e.getStroke();
  }
  /** Get text fill
   * @api
   */
  getTextFill() {
    var e = this._style.getText();
    return e || (e = new Ki({})), e.getFill() || e.setFill(new ri({ color: "#fff" })), e.getFill();
  }
  /** Get text font
   * @api
   */
  getTextFont() {
    var e = this._style.getText();
    return e || (e = new Ki({})), e.getFont() || e.setFont("12px sans-serif"), e.getFont();
  }
  /** Draw the control on canvas
   * @protected
   */
  _draw() {
    console.warn("[CanvasBase] draw function not implemented.");
  }
}, cE = class extends Ft {
  constructor(e) {
    e = e || {}, super();
    var t = this.input = e.input;
    t || (t = this.input = document.createElement("input"), e.type && t.setAttribute("type", e.type), e.min !== void 0 && t.setAttribute("min", e.min), e.max !== void 0 && t.setAttribute("max", e.max), e.step !== void 0 && t.setAttribute("step", e.step), e.parent && e.parent.appendChild(t)), e.disabled && (t.disabled = !0), e.checked !== void 0 && (t.checked = !!e.checked), e.val !== void 0 && (t.value = e.val), e.hidden && t.classList.add("ol-input-hidden"), t.addEventListener("focus", (function() {
      this.element && this.element.classList.add("ol-focus");
    }).bind(this));
    var i;
    t.addEventListener("focusout", (function() {
      this.element && (i && clearTimeout(i), i = setTimeout((function() {
        this.element.classList.remove("ol-focus");
      }).bind(this), 0));
    }).bind(this));
  }
  /** Listen to drag event
   * @param {Element} elt
   * @param {function} cback when draggin on the element
   * @private
   */
  _listenDrag(e, t) {
    var i = (function(r) {
      this.moving = !0, this.element.classList.add("ol-moving");
      var s = (function(o) {
        o.type === "pointerup" && (document.removeEventListener("pointermove", s), document.removeEventListener("pointerup", s), document.removeEventListener("pointercancel", s), setTimeout((function() {
          this.moving = !1, this.element.classList.remove("ol-moving");
        }).bind(this))), o.target === e && t(o), o.stopPropagation(), o.preventDefault();
      }).bind(this);
      document.addEventListener("pointermove", s, !1), document.addEventListener("pointerup", s, !1), document.addEventListener("pointercancel", s, !1), r.stopPropagation(), r.preventDefault();
    }).bind(this);
    e.addEventListener("mousedown", i, !1), e.addEventListener("touchstart", i, !1);
  }
  /** Set the current value
   */
  setValue(e) {
    e !== void 0 && (this.input.value = e), this.input.dispatchEvent(new Event("change"));
  }
  /** Get the current getValue
   * @returns {string}
   */
  getValue() {
    return this.input.value;
  }
  /** Get the input element
   * @returns {Element}
   */
  getInputElement() {
    return this.input;
  }
}, nu = class extends cE {
  constructor(e) {
    e = e || {}, super(e);
    var t = this.element = document.createElement("label");
    e.html instanceof Element ? t.appendChild(e.html) : e.html !== void 0 && (t.innerHTML = e.html), t.className = ("ol-ext-check ol-ext-checkbox " + (e.className || "")).trim(), this.input.parentNode && this.input.parentNode.insertBefore(t, this.input), t.appendChild(this.input), t.appendChild(document.createElement("span")), e.after && t.appendChild(document.createTextNode(e.after)), this.input.addEventListener("change", (function() {
      this.dispatchEvent({ type: "check", checked: this.input.checked, value: this.input.value });
    }).bind(this));
  }
  isChecked() {
    return this.input.checked;
  }
}, hE = class extends nu {
  constructor(e) {
    e = e || {}, super(e), this.element.className = ("ol-ext-toggle-switch " + (e.className || "")).trim();
  }
}, uE = class extends nu {
  constructor(e) {
    e = e || {}, super(e), this.element.className = ("ol-ext-check ol-ext-radio " + (e.className || "")).trim();
  }
}, ee = {};
ee.create = function(n, e) {
  e = e || {};
  var t;
  if (n === "TEXT")
    t = document.createTextNode(e.html || ""), e.parent && e.parent.appendChild(t);
  else {
    t = document.createElement(n.toLowerCase()), /button/i.test(n) && t.setAttribute("type", "button");
    for (var i in e)
      switch (i) {
        case "className": {
          e.className && e.className.trim && t.setAttribute("class", e.className.trim());
          break;
        }
        case "text": {
          t.innerText = e.text;
          break;
        }
        case "html": {
          e.html instanceof Element ? t.appendChild(e.html) : e.html !== void 0 && (t.innerHTML = e.html);
          break;
        }
        case "parent": {
          e.parent && e.parent.appendChild(t);
          break;
        }
        case "options": {
          if (/select/i.test(n))
            for (var r in e.options)
              ee.create("OPTION", {
                html: r,
                value: e.options[r],
                parent: t
              });
          break;
        }
        case "style": {
          ee.setStyle(t, e.style);
          break;
        }
        case "change":
        case "click": {
          ee.addListener(t, i, e[i]);
          break;
        }
        case "on": {
          for (var s in e.on)
            ee.addListener(t, s, e.on[s]);
          break;
        }
        case "checked": {
          t.checked = !!e.checked;
          break;
        }
        default: {
          t.setAttribute(i, e[i]);
          break;
        }
      }
  }
  return t;
};
ee.createSwitch = function(n) {
  var e = ee.create("INPUT", {
    type: "checkbox",
    on: n.on,
    click: n.click,
    change: n.change,
    parent: n.parent
  }), t = Object.assign({ input: e }, n || {});
  return new hE(t), e;
};
ee.createCheck = function(n) {
  var e = ee.create("INPUT", {
    name: n.name,
    type: n.type === "radio" ? "radio" : "checkbox",
    on: n.on,
    parent: n.parent
  }), t = Object.assign({ input: e }, n || {});
  return n.type === "radio" ? new uE(t) : new nu(t), e;
};
ee.setHTML = function(n, e) {
  e instanceof Element ? n.appendChild(e) : e !== void 0 && (n.innerHTML = e);
};
ee.appendText = function(n, e) {
  n.appendChild(document.createTextNode(e || ""));
};
ee.addListener = function(n, e, t, i) {
  typeof e == "string" && (e = e.split(" ")), e.forEach(function(r) {
    n.addEventListener(r, t, i);
  });
};
ee.removeListener = function(n, e, t) {
  typeof e == "string" && (e = e.split(" ")), e.forEach(function(i) {
    n.removeEventListener(i, t);
  });
};
ee.show = function(n) {
  n.style.display = "";
};
ee.hide = function(n) {
  n.style.display = "none";
};
ee.hidden = function(n) {
  return ee.getStyle(n, "display") === "none";
};
ee.toggle = function(n) {
  n.style.display = n.style.display === "none" ? "" : "none";
};
ee.setStyle = function(n, e) {
  for (var t in e)
    switch (t) {
      case "top":
      case "left":
      case "bottom":
      case "right":
      case "minWidth":
      case "maxWidth":
      case "width":
      case "height": {
        typeof e[t] == "number" ? n.style[t] = e[t] + "px" : n.style[t] = e[t];
        break;
      }
      default:
        n.style[t] = e[t];
    }
};
ee.getStyle = function(n, e) {
  var t, i = (n.ownerDocument || document).defaultView;
  if (i && i.getComputedStyle)
    e = e.replace(/([A-Z])/g, "-$1").toLowerCase(), t = i.getComputedStyle(n, null).getPropertyValue(e);
  else if (n.currentStyle && (e = e.replace(/-(\w)/g, function(r, s) {
    return s.toUpperCase();
  }), t = n.currentStyle[e], /^\d+(em|pt|%|ex)?$/i.test(t)))
    return function(r) {
      var s = n.style.left, o = n.runtimeStyle.left;
      return n.runtimeStyle.left = n.currentStyle.left, n.style.left = r || 0, r = n.style.pixelLeft + "px", n.style.left = s, n.runtimeStyle.left = o, r;
    }(t);
  return /px$/.test(t) ? parseInt(t) : t;
};
ee.outerHeight = function(n) {
  return n.offsetHeight + ee.getStyle(n, "marginBottom");
};
ee.outerWidth = function(n) {
  return n.offsetWidth + ee.getStyle(n, "marginLeft");
};
ee.offsetRect = function(n) {
  var e = n.getBoundingClientRect();
  return {
    top: e.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
    left: e.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
    height: e.height || e.bottom - e.top,
    width: e.width || e.right - e.left
  };
};
ee.getFixedOffset = function(n) {
  var e = {
    left: 0,
    top: 0
  }, t = function(i) {
    if (!i) return e;
    if (ee.getStyle(i, "position") === "absolute" && ee.getStyle(i, "transform") !== "none") {
      var r = i.getBoundingClientRect();
      return e.left += r.left, e.top += r.top, e;
    }
    return t(i.offsetParent);
  };
  return t(n.offsetParent);
};
ee.positionRect = function(n, e) {
  var t = 0, i = 0, r = function(s) {
    if (s)
      return t += s.offsetLeft, i += s.offsetTop, r(s.offsetParent);
    var o = {
      top: n.offsetTop + i,
      left: n.offsetLeft + t
    };
    return e && (o.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, o.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0), o.bottom = o.top + n.offsetHeight, o.right = o.top + n.offsetWidth, o;
  };
  return r(n.offsetParent);
};
ee.scrollDiv = function(n, e) {
  e = e || {};
  var t = !1, i = 0, r, s = 0, o = typeof e.onmove == "function" ? e.onmove : function() {
  }, a = e.vertical ? "screenY" : "screenX", l = e.vertical ? "scrollTop" : "scrollLeft", c = !1, h, u, d = 0, f = function() {
    E && (d++, setTimeout(g));
  }, g = function() {
    if (E) {
      if (d--, d) return;
      var w = n.clientHeight, b = n.scrollHeight;
      h = w / b, E.style.height = h * 100 + "%", E.style.top = n.scrollTop / b * 100 + "%", p.style.height = w + "px", w > b - 0.5 ? p.classList.add("ol-100pc") : p.classList.remove("ol-100pc");
    }
  }, _ = function(w) {
    w.target.classList.contains("ol-noscroll") || (c = !1, t = w[a], s = /* @__PURE__ */ new Date(), n.classList.add("ol-move"), w.preventDefault(), window.addEventListener("pointermove", m), ee.addListener(window, ["pointerup", "pointercancel"], v));
  }, m = function(w) {
    if (t !== !1) {
      var b = (u ? -1 / h : 1) * (t - w[a]);
      c = c || Math.round(b), n[l] += b, r = /* @__PURE__ */ new Date(), r - s && (i = (i + b / (r - s)) / 2), t = w[a], s = r, b && o(!0);
    } else
      c = !0;
  }, y = function(w) {
    var b = w > 0 ? Math.min(100, w / 2) : Math.max(-100, w / 2);
    w -= b, n[l] += b, -1 < w && w < 1 ? (c ? setTimeout(function() {
      n.classList.remove("ol-move");
    }) : n.classList.remove("ol-move"), c = !1, o(!1)) : setTimeout(function() {
      y(w);
    }, 40);
  }, p, E;
  if (e.vertical && e.minibar) {
    var x = function(w) {
      n.removeEventListener("pointermove", x), n.parentNode.classList.add("ol-miniscroll"), E = ee.create("DIV"), p = ee.create("DIV", {
        className: "ol-scroll",
        html: E
      }), n.parentNode.insertBefore(p, n), E.addEventListener("pointerdown", function(b) {
        u = !0, _(b);
      }), e.mousewheel && (ee.addListener(
        p,
        ["mousewheel", "DOMMouseScroll", "onmousewheel"],
        function(b) {
          S(b);
        }
      ), ee.addListener(
        E,
        ["mousewheel", "DOMMouseScroll", "onmousewheel"],
        function(b) {
          S(b);
        }
      )), n.parentNode.addEventListener("pointerenter", f), window.addEventListener("resize", f), w !== !1 && f();
    };
    n.parentNode ? x(!1) : n.addEventListener("pointermove", x), n.addEventListener("scroll", function() {
      f();
    });
  }
  n.style["touch-action"] = "none", n.style.overflow = "hidden", n.classList.add("ol-scrolldiv"), ee.addListener(n, ["pointerdown"], function(w) {
    u = !1, _(w);
  }), n.addEventListener("click", function(w) {
    n.classList.contains("ol-move") && (w.preventDefault(), w.stopPropagation());
  }, !0);
  var v = function(w) {
    s = /* @__PURE__ */ new Date() - s, s > 100 || u ? i = 0 : s > 0 && (i = ((i || 0) + (t - w[a]) / s) / 2), y(e.animate === !1 ? 0 : i * 200), t = !1, i = 0, s = 0, n.classList.contains("ol-move") ? n.classList.remove("ol-hasClick") : (n.classList.add("ol-hasClick"), setTimeout(function() {
      n.classList.remove("ol-hasClick");
    }, 500)), u = !1, window.removeEventListener("pointermove", m), ee.removeListener(window, ["pointerup", "pointercancel"], v);
  }, S = function(w) {
    var b = Math.max(-1, Math.min(1, w.wheelDelta || -w.detail));
    return n.classList.add("ol-move"), n[l] -= b * 30, n.classList.remove("ol-move"), !1;
  };
  return e.mousewheel && ee.addListener(
    n,
    ["mousewheel", "DOMMouseScroll", "onmousewheel"],
    S
  ), {
    refresh: f
  };
};
ee.dispatchEvent = function(n, e) {
  var t;
  try {
    t = new CustomEvent(n);
  } catch {
    t = document.createEvent("CustomEvent"), t.initCustomEvent(n, !0, !0, {});
  }
  e.dispatchEvent(t);
};
ee.setCursor = function(n, e) {
  n instanceof Zi && (n = n.getTargetElement()), !("ontouchstart" in window) && n instanceof Element && (n.style.cursor = e);
};
var dE = class extends aE {
  constructor(e) {
    e = e || {}, e.bar = !1, super(e), this.element.classList.add("ol-canvas-control"), this.scaleHeight_ = 6, e || (e = {}), e.style || (e.style = new wt()), this.setStyle(e.style);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol_Map} map Map.
   * @api stable
   */
  setMap(e) {
    Vc.prototype.getCanvas.call(this, e);
    var t = this.getMap();
    if (this._listener && Pi(this._listener), this._listener = null, super.setMap(e), t)
      try {
        t.renderSync();
      } catch {
      }
    e && (this._listener = e.on("postcompose", this.drawScale_.bind(this))), this.element.style.visibility = "hidden", this.olscale = this.element.querySelector(".ol-scale-line-inner");
  }
  /**
   * Change the control style
   * @param {ol_style_Style} style
   */
  setStyle(e) {
    var t = e.getStroke();
    this.strokeStyle_ = t ? Vn(t.getColor()) : "#000", this.strokeWidth_ = t ? t.getWidth() : 2;
    var i = e.getFill();
    this.fillStyle_ = i ? Vn(i.getColor()) : "#fff";
    var r = e.getText();
    this.font_ = r ? r.getFont() : "10px Arial", t = r ? r.getStroke() : null, i = r ? r.getFill() : null, this.fontStrokeStyle_ = t ? Vn(t.getColor()) : this.fillStyle_, this.fontStrokeWidth_ = t ? t.getWidth() : 3, this.fontFillStyle_ = i ? Vn(i.getColor()) : this.strokeStyle_, this.getMap() && this.getMap().render();
  }
  /**
   * Draw attribution in the final canvas
   * @param {ol_render_Event} e
   * @private
   */
  drawScale_(e) {
    if (!(this.element.style.visibility !== "hidden" || ee.getStyle(this.element, "display") === "none")) {
      var t = this.getContext(e);
      if (t) {
        var i = parseInt(this.olscale.style.width);
        if (i) {
          var r = this.olscale.textContent, s = { left: this.element.offsetLeft, top: this.element.offsetTop }, o = e.frameState.pixelRatio;
          t.save(), t.scale(o, o), s.top += this.element.clientHeight - this.scaleHeight_, t.beginPath(), t.strokeStyle = this.fontStrokeStyle_, t.fillStyle = this.fontFillStyle_, t.lineWidth = this.fontStrokeWidth_, t.textAlign = "center", t.textBaseline = "bottom", t.font = this.font_, t.lineJoin = "round", t.strokeText(r, s.left + i / 2, s.top), t.fillText(r, s.left + i / 2, s.top), t.closePath(), s.top += 2, t.lineWidth = this.strokeWidth_, t.strokeStyle = this.strokeStyle_;
          for (var a = 4, l = parseInt(r); l % 10 === 0; ) l /= 10;
          l % 5 === 0 && (a = 5);
          for (var c = 0; c < a; c++)
            t.beginPath(), t.fillStyle = c % 2 ? this.fillStyle_ : this.strokeStyle_, t.rect(s.left + c * i / a, s.top, i / a, this.scaleHeight_), t.stroke(), t.fill(), t.closePath();
          t.restore();
        }
      }
    }
  }
  /** Get map Canvas
   * @private
   */
  getContext(e) {
    return Vc.prototype.getContext.call(this, e);
  }
}, fE = class extends Vc {
  constructor(e) {
    e = e || {};
    var t = document.createElement("div");
    t.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (e.className ? " " + e.className : ""), t.style.position = "absolute", t.style.visibility = "hidden";
    var i = e.style instanceof Gt ? new wt({ stroke: e.style }) : e.style;
    e.style || (i = new wt({ stroke: new Gt({ width: 0 }) })), super({
      element: t,
      style: i
    }), this.set("rotateVithView", e.rotateWithView !== !1), this.setVisible(e.visible !== !1), this.setImage(e.image || e.src);
  }
  /** Set compass image
   * @param {Image|string} [img=default] the image or an url or 'compact' or 'default'
   */
  setImage(e) {
    if (e instanceof Image)
      this.img_ = e, this.img_.onload = (function() {
        if (this.getMap())
          try {
            this.getMap().renderSync();
          } catch {
          }
      }).bind(this);
    else if (typeof e == "string")
      switch (e) {
        case "compact": {
          this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        case "default": {
          this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        default: {
          this.img_ = new Image(), this.img_.onload = (function() {
            if (this.getMap())
              try {
                this.getMap().renderSync();
              } catch {
              }
          }).bind(this), this.img_.src = e;
          break;
        }
      }
    else
      this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  compactCompass_(e, t) {
    var i = document.createElement("canvas"), r = i.getContext("2d");
    e = i.width = i.height = e || 150;
    var s = e / 2;
    return r.translate(s, s), r.fillStyle = t || "#963", r.lineWidth = 5, r.lineJoin = r.lineCap = "round", r.font = "bold " + s * 0.4 + "px sans-serif", r.textBaseline = "bottom", r.textAlign = "center", r.strokeStyle = "#fff", r.globalAlpha = 0.75, r.strokeText("N", 0, -s / 2), r.globalAlpha = 1, r.fillText("N", 0, -s / 2), r.beginPath(), r.moveTo(0, s / 4), r.lineTo(s / 3, s / 2), r.lineTo(0, -s / 2), r.lineTo(-s / 3, s / 2), r.lineTo(0, s / 4), r.lineWidth = 12, r.fillStyle = "#fff", r.globalAlpha = 0.75, r.fill(), r.stroke(), r.globalAlpha = 1, r.fillStyle = r.strokeStyle = t || "#963", r.lineWidth = 5, r.beginPath(), r.moveTo(0, s / 4), r.lineTo(0, -s / 2), r.lineTo(s / 3, s / 2), r.lineTo(0, s / 4), r.fill(), r.stroke(), r.beginPath(), r.moveTo(0, s / 4), r.lineTo(0, -s / 2), r.lineTo(-s / 3, s / 2), r.lineTo(0, s / 4), r.stroke(), i;
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  defaultCompass_(e, t) {
    var i = document.createElement("canvas"), r = i.getContext("2d");
    e = i.width = i.height = e || 150;
    var s = e / 2, o = 0.22 * s;
    function a(c, h) {
      r.fillStyle = t || "#963", r.beginPath(), r.moveTo(0, 0), r.lineTo(c, 0), r.lineTo(h, h), r.moveTo(0, 0), r.lineTo(-c, 0), r.lineTo(-h, -h), r.moveTo(0, 0), r.lineTo(0, c), r.lineTo(-h, h), r.moveTo(0, 0), r.lineTo(0, -c), r.lineTo(h, -h), r.moveTo(0, 0), r.fill(), r.stroke();
    }
    function l(c, h) {
      r.globalCompositeOperation = "destination-out", r.fillStyle = "#fff", r.beginPath(), r.moveTo(0, 0), r.lineTo(c, 0), r.lineTo(h, -h), r.moveTo(0, 0), r.lineTo(-c, 0), r.lineTo(-h, h), r.moveTo(0, 0), r.lineTo(0, c), r.lineTo(h, h), r.moveTo(0, 0), r.lineTo(0, -c), r.lineTo(-h, -h), r.moveTo(0, 0), r.fill(), r.globalCompositeOperation = "source-over", r.beginPath(), r.moveTo(0, 0), r.lineTo(c, 0), r.lineTo(h, -h), r.moveTo(0, 0), r.lineTo(-c, 0), r.lineTo(-h, h), r.moveTo(0, 0), r.lineTo(0, c), r.lineTo(h, h), r.moveTo(0, 0), r.lineTo(0, -c), r.lineTo(-h, -h), r.moveTo(0, 0), r.stroke();
    }
    return r.translate(s, s), r.strokeStyle = t || "#963", r.lineWidth = 1.5, r.beginPath(), r.arc(0, 0, e * 0.41, 0, 2 * Math.PI), r.arc(0, 0, e * 0.44, 0, 2 * Math.PI), r.stroke(), r.rotate(Math.PI / 4), a(s * 0.9, o * 0.8), l(s * 0.9, o * 0.8), r.rotate(-Math.PI / 4), a(s, o), l(s, o), i;
  }
  /** Get control visibility
   * @return {boolean}
   */
  getVisible() {
    return ee.getStyle(this.element, "display") === "block";
  }
  /** Set visibility
   * @param {boolean} b
   */
  setVisible(e) {
    e ? this.element.classList.add("ol-visible") : this.element.classList.remove("ol-visible"), this.getMap() && this.getMap().render();
  }
  /** Draw compass
  * @param {ol.event} e postcompose event
  * @private
  */
  _draw(e) {
    var t = this.getContext(e);
    if (!(!t || !this.getVisible())) {
      var i = t.canvas, r, s = [];
      for (r = 0; r < 8; r++)
        s[r] = [Math.cos(Math.PI * r / 8), Math.sin(Math.PI * r / 8)];
      var o = e.frameState.pixelRatio;
      t.save(), t.scale(o, o);
      var a = this.element.clientWidth, l = this.element.clientHeight, c = { left: this.element.offsetLeft, top: this.element.offsetTop }, h = this.img_, u = e.frameState.viewState.rotation;
      if (t.beginPath(), t.translate(c.left + a / 2, c.top + l / 2), this.get("rotateVithView") && t.rotate(u), this.getStroke().getWidth()) {
        t.beginPath(), t.strokeStyle = this.getStroke().getColor(), t.lineWidth = this.getStroke().getWidth();
        var d = Math.max(i.width, i.height);
        for (r = 0; r < 8; r++)
          t.moveTo(-s[r][0] * d, -s[r][1] * d), t.lineTo(s[r][0] * d, s[r][1] * d);
        t.stroke();
      }
      h.width && t.drawImage(h, -a / 2, -l / 2, a, l), t.closePath(), t.restore();
    }
  }
}, gE = class extends hr {
  constructor(e) {
    e = e || {};
    var t = ee.create("DIV", {
      className: ((e.className || "") + " ol-progress-bar ol-unselectable ol-control").trim()
    });
    super({
      element: t,
      target: e.target
    }), this._waiting = ee.create("DIV", {
      html: e.label || "",
      className: "ol-waiting",
      parent: t
    }), this._bar = ee.create("DIV", {
      className: "ol-bar",
      parent: t
    }), this._layerlistener = [], this.setLayers(e.layers);
  }
  /** Set the control visibility
   * @param {Number} [n] progress percentage, a number beetween 0,1, default hide progress bar
   */
  setPercent(e) {
    this._bar.style.width = (Number(e) || 0) * 100 + "%", e === void 0 ? ee.hide(this.element) : ee.show(this.element);
  }
  /** Set waiting text
   * @param {string} label
   */
  setLabel(e) {
    this._waiting.innerHTML = e;
  }
  /** Use a list of tile layer to shown tile load
   * @param {ol_layer_Layer|Array<ol_layer_Layer>} layers a layer or a list of layer
   */
  setLayers(e) {
    this._layerlistener.forEach(function(s) {
      Pi(s);
    }), this._layerlistener = [], this.setPercent();
    var t = 0, i = 0;
    if (e instanceof ir && (e = [e]), !(!e || !e.forEach)) {
      var r;
      e.forEach((function(s) {
        s instanceof ir && (this._layerlistener.push(s.getSource().on("tileloadstart", (function() {
          t++, this.setPercent(i / t), clearTimeout(r);
        }).bind(this))), this._layerlistener.push(s.getSource().on(["tileloadend", "tileloaderror"], (function() {
          i++, i === t ? (t = i = 0, this.setPercent(1), r = setTimeout(this.setPercent.bind(this), 300)) : this.setPercent(i / t);
        }).bind(this))));
      }).bind(this));
    }
  }
}, mE = function(n, e) {
  var t = n.getView(), i = t.getProjection(), r = t.getCenter(), s = n.getPixelFromCoordinate(r);
  s[1] += 1;
  var o = n.getCoordinateFromPixel(s), a = la(
    rn(r, i, "EPSG:4326"),
    rn(o, i, "EPSG:4326")
  );
  return a *= (e || 96) / 0.0254, a;
}, _E = function(n, e, t) {
  if (n && e) {
    var i = e;
    if (typeof e == "string" && (e = e.replace(":", "/").split("/"), i = e[1], i || (i = e[0] || ""), i = i.replace(/[^\d]/g, ""), i = parseInt(i), e[1])) {
      var r = parseInt(e[0]);
      r && (i /= r);
    }
    if (!i) return;
    var s = n.getView(), o = s.getProjection(), a = s.getCenter(), l = n.getPixelFromCoordinate(a);
    l[1] += 1;
    var c = n.getCoordinateFromPixel(l), h = la(
      rn(a, o, "EPSG:4326"),
      rn(c, o, "EPSG:4326")
    );
    return h *= (t || 96) / 0.0254, s.setResolution(s.getResolution() * i / h), i;
  }
}, pE = class extends hr {
  constructor(e) {
    e = e || {}, e.typing === void 0 && (e.typing = 300);
    var t = document.createElement("DIV"), i = (e.className || "") + " ol-scale";
    e.target || (i += " ol-unselectable ol-control"), super({
      element: t,
      target: e.target
    }), this._input = document.createElement("INPUT"), this._input.value = "-", t.setAttribute("class", i), e.editable === !1 && (this._input.readOnly = !0), t.appendChild(this._input), this._input.addEventListener("change", this.setScale.bind(this)), this.set("ppi", e.ppi || 96);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    this._listener && Pi(this._listener), this._listener = null, super.setMap(e), e && (this._listener = e.on("moveend", this.getScale.bind(this)));
  }
  /** Display the scale
   */
  getScale() {
    var e = this.getMap();
    if (e) {
      var t = mE(e, this.get("ppi"));
      return this._input.value = this.formatScale(t), t;
    }
  }
  /** Format the scale 1/d
   * @param {Number} d
   * @return {string} formated string
   */
  formatScale(e) {
    return e > 100 ? e = Math.round(e / 100) * 100 : e = Math.round(e), "1 / " + e.toLocaleString();
  }
  /** Set the current scale (will change the scale of the map)
   * @param {Number} value the scale factor
   */
  setScale(e) {
    var t = this.getMap();
    t && e && (e.target && (e = e.target.value), _E(t, e, this.get("ppi"))), this.getScale();
  }
};
function iu(n) {
  const e = n.frameState, t = Ch(n.inversePixelTransform.slice(), e.coordinateToPixelTransform);
  return new kg(
    n.context,
    e.pixelRatio,
    e.extent,
    t,
    e.viewState.rotation
  );
}
var Ms = iy.split(".");
Ms = parseInt(Ms[0]) * 100 + parseInt(Ms[1]);
var Xc = function(n, e) {
  var t = n.frameState.pixelRatio;
  if (Ms > 605 && Ms < 700 && t !== 1 && e.getImage() instanceof mo) {
    e = e.clone();
    var i = e.getImage();
    i.setScale(i.getScale() * t);
    var r = i.getAnchor();
    if (r && i.setDisplacement) {
      var s = i.getDisplacement();
      s && (s[0] -= r[0] / t, s[1] += r[1] / t, i.setAnchor([0, 0]));
    } else
      r && (r[0] /= t, r[1] /= t);
  }
  return e;
}, ru = class extends Ft {
  constructor(e) {
    e = e || {}, super(), this.duration_ = typeof e.duration == "number" ? e.duration >= 0 ? e.duration : 0 : 1e3, this.fade_ = typeof e.fade == "function" ? e.fade : null, this.repeat_ = Number(e.repeat);
    var t = typeof e.easing == "function" ? e.easing : tm;
    e.revers ? this.easing_ = function(i) {
      return 1 - t(i);
    } : this.easing_ = t, this.hiddenStyle = e.hiddenStyle;
  }
  /** Draw a geometry
  * @param {olx.animateFeatureEvent} e
  * @param {ol.geom} geom geometry for shadow
  * @param {ol.geom} shadow geometry for shadow (ie. style with zIndex = -1)
  * @private
  */
  drawGeom_(e, t, i) {
    var r = {
      type: "drawing",
      time: e.time,
      feature: e.feature,
      start: e.start,
      stop: e.stop,
      rotation: e.rotation,
      style: e.style,
      extra: e.extra
    };
    this.dispatchEvent(r);
    var s = r.style instanceof Array ? r.style : [r.style];
    this.fade_ && (e.context.globalAlpha = this.fade_(1 - e.elapsed));
    for (var o = 0; o < s.length; o++)
      try {
        var a = e.vectorContext || iu(e), l = Xc(e, s[o]);
        a.setStyle(l), l.getZIndex() < 0 ? a.drawGeometry(i || t) : a.drawGeometry(t);
      } catch {
      }
  }
  /** Function to perform manipulations onpostcompose.
   * This function is called with an ol_featureAnimationEvent argument.
   * The function will be overridden by the child implementation.
   * Return true to keep this function for the next frame, false to remove it.
   * @param {ol_featureAnimationEvent} e
   * @return {bool} true to continue animation.
   * @api
   */
  animate() {
    return !1;
  }
};
ru.hiddenStyle = new wt({
  image: new nr({}),
  stroke: new Gt({
    color: "transparent"
  })
});
Zi.prototype.animateFeature = function(n, e) {
  var t = this._featureAnimationLayer;
  t || (t = this._featureAnimationLayer = new Ks({ source: new fo() }), t.setMap(this)), t.getSource().addFeature(n);
  var i = e.on("animationend", function(r) {
    r.feature === n && (t.getSource().removeFeature(n), Pi(i));
  });
  return t.animateFeature(n, e);
};
Ur.prototype.animateFeature = function(n, e, t) {
  var i = this, r, s = n.getStyle(), o = s || (this.getStyleFunction ? this.getStyleFunction()(n) : null);
  o || (o = []), o instanceof Array || (o = [o]);
  var a = {
    // Frame context
    vectorContext: null,
    frameState: null,
    start: 0,
    time: 0,
    elapsed: 0,
    extent: !1,
    // Feature information
    feature: n,
    geom: n.getGeometry(),
    typeGeom: n.getGeometry().getType(),
    bbox: n.getGeometry().getExtent(),
    coord: nn(n.getGeometry().getExtent()),
    style: o
  };
  e instanceof Array || (e = [e]);
  for (var l = e.length - 1; l >= 0; l--)
    e[l].duration_ === 0 && e.splice(l, 1);
  var c = 0, h = 0, u = t && this.getFilters ? this.getFilters() : [];
  function d(_) {
    a.type = _.type;
    try {
      a.vectorContext = _.vectorContext || iu(_);
    } catch {
    }
    if (a.frameState = _.frameState, a.inversePixelTransform = _.inversePixelTransform, a.extent || (a.extent = _.frameState.extent, a.start = _.frameState.time, a.context = _.context), a.time = _.frameState.time - a.start, a.elapsed = a.time / e[h].duration_, a.elapsed > 1 && (a.elapsed = 1), _.context.save(), u.forEach(function(y) {
      y.get("active") && y.precompose(_);
    }), this.getOpacity && (_.context.globalAlpha = this.getOpacity()), !e[h].animate(a))
      c++, c < e[h].repeat_ ? (a.extent = !1, e[h].dispatchEvent({ type: "animationrepeat", feature: n })) : h < e.length - 1 ? (e[h].dispatchEvent({ type: "animationend", feature: n }), h++, c = 0, a.extent = !1) : f();
    else {
      var m = {
        type: "animating",
        step: h,
        start: a.start,
        time: a.time,
        elapsed: a.elapsed,
        rotation: a.rotation || 0,
        geom: a.geom,
        coordinate: a.coord,
        feature: n,
        extra: a.extra || {},
        style: o
      };
      e[h].dispatchEvent(m), i.dispatchEvent(m);
    }
    u.forEach(function(y) {
      y.get("active") && y.postcompose(_);
    }), _.context.restore(), _.frameState.animate = !0;
  }
  function f(_) {
    Pi(r), r = null, n.setStyle(s), a.stop = (/* @__PURE__ */ new Date()).getTime();
    var m = { type: "animationend", feature: n };
    if (_)
      for (var y in _) _.hasOwnProperty(y) && (m[y] = _[y]);
    e[h].dispatchEvent(m), i.dispatchEvent(m);
  }
  function g(_) {
    if (e.length && !r) {
      if (a.stop && (a.start = (/* @__PURE__ */ new Date()).getTime() - a.stop + a.start, a.stop = 0), r = i.on(["postcompose", "postrender"], d.bind(i)), i.renderSync)
        try {
          i.renderSync();
        } catch {
        }
      else
        i.changed();
      n.setStyle(e[h].hiddenStyle || ru.hiddenStyle);
      var m = { type: "animationstart", feature: n };
      if (_)
        for (var y in _) _.hasOwnProperty(y) && (m[y] = _[y]);
      e[h].dispatchEvent(m), i.dispatchEvent(m);
    }
  }
  return g(), {
    start: g,
    stop: f,
    isPlaying: function() {
      return !!r;
    }
  };
};
var yE = class extends ru {
  constructor(e) {
    e = e || {}, super(e), this.set("zoomout", e.zoomOut);
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    var t = this.easing_(e.elapsed);
    if (t) {
      this.get("zoomout") && (t = 1 / t);
      var i = e.style, r, s, o = [];
      for (r = 0; r < i.length; r++)
        s = i[r].getImage(), s && (o[r] = s.getScale(), e.type === "postrender" ? s.setScale(o[r] * t / e.frameState.pixelRatio) : s.setScale(o[r] * t));
      for (this.drawGeom_(e, e.geom), r = 0; r < i.length; r++)
        s = i[r].getImage(), s && s.setScale(o[r]);
    }
    return e.time <= this.duration_;
  }
}, xE = class extends Ks {
  constructor(e) {
    var t = e || {};
    super(t), this.oldcluster = new fo(), this.clusters = [], this.animation = { start: !1 }, this.set("animationDuration", typeof t.animationDuration == "number" ? t.animationDuration : 700), this.set("animationMethod", t.animationMethod || Ii), this.on(["precompose", "prerender"], this.animate.bind(this)), this.on(["postcompose", "postrender"], this.postanimate.bind(this));
  }
  /** Set the cluster source
   * @param {ol_source_Vector} source
   */
  setSource(e) {
    this._saveClusterFn || (this._saveClusterFn = this.saveCluster.bind(this)), this.getSource() && this.getSource().un("change", this._saveClusterFn), Ks.prototype.setSource.call(this, e), this.getSource() && this.getSource().on("change", this._saveClusterFn);
  }
  /** save cluster features before change
   * @private
   */
  saveCluster() {
    if (this.oldcluster) {
      if (this.oldcluster.clear(), !this.get("animationDuration"))
        return;
      var e = this.getSource().getFeatures();
      e.length && e[0].get("features") && (this.oldcluster.addFeatures(this.clusters), this.clusters = e.slice(0), this.sourceChanged = !0);
    }
  }
  /**
   * Get the cluster that contains a feature
   * @private
  */
  getClusterForFeature(e, t) {
    for (var i = 0, r; r = t[i]; i++) {
      var s = r.get("features");
      if (s && s.length) {
        for (var o = 0, a; a = s[o]; o++)
          if (e === a)
            return r;
      }
    }
    return !1;
  }
  /**
   * Stop animation
   * @private
   */
  stopAnimation() {
    this.animation.start = !1, this.animation.cA = [], this.animation.cB = [];
  }
  /**
   * animate the cluster
   * @private
   */
  animate(e) {
    var t = this.get("animationDuration");
    if (t) {
      var i = e.frameState.viewState.resolution, r, s, o = this.animation, a = e.frameState.time;
      if (o.resolution != i && this.sourceChanged) {
        var l = e.frameState.extent;
        for (o.resolution < i ? (l = ni(l, 100 * i), o.cA = this.oldcluster.getFeaturesInExtent(l), o.cB = this.getSource().getFeaturesInExtent(l), o.revers = !1) : (l = ni(l, 100 * i), o.cA = this.getSource().getFeaturesInExtent(l), o.cB = this.oldcluster.getFeaturesInExtent(l), o.revers = !0), o.clusters = [], r = 0, s; s = o.cA[r]; r++) {
          var c = s.get("features");
          if (c && c.length) {
            var h = this.getClusterForFeature(c[0], o.cB);
            h && o.clusters.push({ f: s, pt: h.getGeometry().getCoordinates() });
          }
        }
        if (o.resolution = i, this.sourceChanged = !1, !o.clusters.length || o.clusters.length > 1e3) {
          this.stopAnimation();
          return;
        }
        a = o.start = (/* @__PURE__ */ new Date()).getTime();
      }
      if (o.start) {
        var u = e.vectorContext || iu(e), d = (a - o.start) / t;
        d > 1 && (this.stopAnimation(), d = 1), d = this.get("animationMethod")(d);
        var f = this.getStyle(), g = typeof f == "function" ? f : f.length ? function() {
          return f;
        } : function() {
          return [f];
        };
        for (e.context.save(), e.context.globalAlpha = this.getOpacity(), r = 0, h; h = o.clusters[r]; r++) {
          var _ = h.f.getGeometry().getCoordinates(), m = _[0] - h.pt[0], y = _[1] - h.pt[1];
          o.revers ? (_[0] = h.pt[0] + d * m, _[1] = h.pt[1] + d * y) : (_[0] = _[0] - d * m, _[1] = _[1] - d * y);
          var p = g(h.f, i, !0);
          if (Array.isArray(p) || (p = [p]), h.f.get("features").length === 1 && !m && !y)
            c = h.f.get("features")[0];
          else {
            var E = new on(_);
            c = new Ri(E);
          }
          for (var x = 0, v; v = p[x]; x++)
            if (v.getText() && /\n/.test(v.getText().getText())) {
              var S = v.getText().getOffsetX(), w = v.getText().getOffsetY(), b = v.getText().getRotation() || 0, P = Number((v.getText().getFont() || "10px").match(/\d+/)) * 1.2, O = v.getText().getText().split(`
`), N, k = O.length - 1, D = v.clone();
              O.forEach(function(U, X) {
                switch (X == 1 && (D.setImage(), D.setFill(), D.setStroke()), v.getText().getTextBaseline()) {
                  case "alphabetic":
                  case "ideographic":
                  case "bottom": {
                    N = k;
                    break;
                  }
                  case "hanging":
                  case "top": {
                    N = 0;
                    break;
                  }
                  default: {
                    N = k / 2;
                    break;
                  }
                }
                D.getText().setOffsetX(S - Math.sin(b) * P * (X - N)), D.getText().setOffsetY(w + Math.cos(b) * P * (X - N)), D.getText().setText(U), u.drawFeature(c, Xc(e, D));
              });
            } else
              u.drawFeature(c, Xc(e, v));
        }
        e.context.restore(), e.frameState.animate = !0, e.context.save(), e.context.beginPath(), e.context.rect(0, 0, 0, 0), e.context.clip(), this.clip_ = !0;
      }
    }
  }
  /**
   * remove clipping after the layer is drawn
   * @private
   */
  postanimate(e) {
    this.clip_ && (e.context.restore(), this.clip_ = !1);
  }
};
class vE {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  deleteOldest() {
    const e = this.pop();
    e instanceof so && e.dispose();
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.deleteOldest();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    for (; this.oldest_; )
      this.deleteOldest();
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const i = this.entries_[e];
    return ge(
      i !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return ge(
      t !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    var t;
    return (t = this.entries_[e]) == null ? void 0 : t.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    ge(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const i = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[e] = i, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
function Zs(n, e, t, i) {
  return i !== void 0 ? (i[0] = n, i[1] = e, i[2] = t, i) : [n, e, t];
}
function EE(n, e, t) {
  return n + "/" + e + "/" + t;
}
function hm(n) {
  return TE(n[0], n[1], n[2]);
}
function TE(n, e, t) {
  return (e << n) + t;
}
function wE(n, e) {
  const t = n[0], i = n[1], r = n[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const s = e.getFullTileRange(t);
  return s ? s.containsXY(i, r) : !0;
}
const wr = [0, 0, 0], mi = 5;
class um {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, ge(
      ey(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (r, s) => s - r
      ),
      "`resolutions` must be sorted in descending order"
    );
    let t;
    if (!e.origins) {
      for (let r = 0, s = this.resolutions_.length - 1; r < s; ++r)
        if (!t)
          t = this.resolutions_[r] / this.resolutions_[r + 1];
        else if (this.resolutions_[r] / this.resolutions_[r + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, ge(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const i = e.extent;
    i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = or(i)), ge(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, ge(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Zh, ge(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((r, s) => {
      const o = new tu(
        Math.min(0, r[0]),
        Math.max(r[0] - 1, -1),
        Math.min(0, r[1]),
        Math.max(r[1] - 1, -1)
      );
      if (i) {
        const a = this.getTileRangeForExtentAndZ(i, s);
        o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
      }
      return o;
    }) : i && this.calculateTileRanges_(i);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, i) {
    const r = this.getTileRangeForExtentAndZ(e, t);
    for (let s = r.minX, o = r.maxX; s <= o; ++s)
      for (let a = r.minY, l = r.maxY; a <= l; ++a)
        i([t, s, a]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, i, r) {
    let s, o, a, l = null, c = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], a = e[2]) : l = this.getTileCoordExtent(e, r); c >= this.minZoom; ) {
      if (o !== void 0 && a !== void 0 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), s = Tr(o, o, a, a, i)) : s = this.getTileRangeForExtentAndZ(
        l,
        c,
        i
      ), t(c, s))
        return !0;
      --c;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, i) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const s = e[1] * 2, o = e[2] * 2;
        return Tr(
          s,
          s + 1,
          o,
          o + 1,
          t
        );
      }
      const r = this.getTileCoordExtent(
        e,
        i || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        r,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, i) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const r = e[0], s = e[1], o = e[2];
    if (t === r)
      return Tr(
        s,
        o,
        s,
        o,
        i
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, t - r), c = Math.floor(s * l), h = Math.floor(o * l);
      if (t < r)
        return Tr(c, c, h, h, i);
      const u = Math.floor(l * (s + 1)) - 1, d = Math.floor(l * (o + 1)) - 1;
      return Tr(c, u, h, d, i);
    }
    const a = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(a, t, i);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, i) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, wr);
    const r = wr[1], s = wr[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, wr);
    const o = wr[1], a = wr[2];
    return Tr(r, o, s, a, i);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), i = this.getResolution(e[0]), r = Tt(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * r[0] * i,
      t[1] - (e[2] + 0.5) * r[1] * i
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const i = this.getOrigin(e[0]), r = this.getResolution(e[0]), s = Tt(this.getTileSize(e[0]), this.tmpSize_), o = i[0] + e[1] * s[0] * r, a = i[1] - (e[2] + 1) * s[1] * r, l = o + s[0] * r, c = a + s[1] * r;
    return ii(o, a, l, c, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, i) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, i, r, s) {
    const o = this.getZForResolution(i), a = i / this.getResolution(o), l = this.getOrigin(o), c = Tt(this.getTileSize(o), this.tmpSize_);
    let h = a * (e - l[0]) / i / c[0], u = a * (l[1] - t) / i / c[1];
    return r ? (h = Fo(h, mi) - 1, u = Fo(u, mi) - 1) : (h = Do(h, mi), u = Do(u, mi)), Zs(o, h, u, s);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, i, r, s) {
    const o = this.getOrigin(i), a = this.getResolution(i), l = Tt(this.getTileSize(i), this.tmpSize_);
    let c = (e - o[0]) / a / l[0], h = (o[1] - t) / a / l[1];
    return r ? (c = Fo(c, mi) - 1, h = Fo(h, mi) - 1) : (c = Do(c, mi), h = Do(h, mi)), Zs(i, c, h, s);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, i) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const i = ph(
      this.resolutions_,
      e,
      t || 0
    );
    return De(i, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return Tg(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, i = new Array(t);
    for (let r = this.minZoom; r < t; ++r)
      i[r] = this.getTileRangeForExtentAndZ(e, r);
    this.fullTileRanges_ = i;
  }
}
function dm(n) {
  let e = n.getDefaultTileGrid();
  return e || (e = RE(n), n.setDefaultTileGrid(e)), e;
}
function SE(n, e, t) {
  const i = e[0], r = n.getTileCoordCenter(e), s = ll(t);
  if (!jr(s, r)) {
    const o = Ee(s), a = Math.ceil(
      (s[0] - r[0]) / o
    );
    return r[0] += o * a, n.getTileCoordForCoordAndZ(r, i);
  }
  return e;
}
function bE(n, e, t, i) {
  i = i !== void 0 ? i : "top-left";
  const r = gm(n, e, t);
  return new um({
    extent: n,
    origin: ay(n, i),
    resolutions: r,
    tileSize: t
  });
}
function fm(n) {
  const e = n || {}, t = e.extent || Ie("EPSG:3857").getExtent(), i = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: gm(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new um(i);
}
function gm(n, e, t, i) {
  e = e !== void 0 ? e : xv, t = Tt(t !== void 0 ? t : Zh);
  const r = ut(n), s = Ee(n);
  i = i > 0 ? i : Math.max(s / t[0], r / t[1]);
  const o = e + 1, a = new Array(o);
  for (let l = 0; l < o; ++l)
    a[l] = i / Math.pow(2, l);
  return a;
}
function RE(n, e, t, i) {
  const r = ll(n);
  return bE(r, e, t, i);
}
function ll(n) {
  n = Ie(n);
  let e = n.getExtent();
  if (!e) {
    const t = 180 * Xr.degrees / n.getMetersPerUnit();
    e = ii(-t, -t, t, t);
  }
  return e;
}
function mm(n, e) {
  const t = [];
  Object.keys(e).forEach(function(r) {
    e[r] !== null && e[r] !== void 0 && t.push(r + "=" + encodeURIComponent(e[r]));
  });
  const i = t.join("&");
  return n = n.replace(/[?&]$/, ""), n += n.includes("?") ? "&" : "?", n + i;
}
const CE = /\{z\}/g, PE = /\{x\}/g, IE = /\{y\}/g, AE = /\{-y\}/g;
function LE(n, e, t, i, r) {
  return n.replace(CE, e.toString()).replace(PE, t.toString()).replace(IE, i.toString()).replace(AE, function() {
    if (r === void 0)
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    return (r - i).toString();
  });
}
function OE(n) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(n);
  if (t) {
    const i = t[1].charCodeAt(0), r = t[2].charCodeAt(0);
    let s;
    for (s = i; s <= r; ++s)
      e.push(n.replace(t[0], String.fromCharCode(s)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(n), t) {
    const i = parseInt(t[2], 10);
    for (let r = parseInt(t[1], 10); r <= i; r++)
      e.push(n.replace(t[0], r.toString()));
    return e;
  }
  return e.push(n), e;
}
function ME(n, e) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(t, i, r) {
      if (!t)
        return;
      let s;
      const o = t[0];
      if (e) {
        const a = e.getFullTileRange(o);
        a && (s = a.getHeight() - 1);
      }
      return LE(n, o, t[1], t[2], s);
    }
  );
}
function DE(n, e) {
  const t = n.length, i = new Array(t);
  for (let r = 0; r < t; ++r)
    i[r] = ME(n[r], e);
  return _m(i);
}
function _m(n) {
  return n.length === 1 ? n[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, i) {
      if (!e)
        return;
      const r = hm(e), s = Hi(r, n.length);
      return n[s](e, t, i);
    }
  );
}
let tc;
const Br = [];
function qd(n, e, t, i, r) {
  n.beginPath(), n.moveTo(0, 0), n.lineTo(e, t), n.lineTo(i, r), n.closePath(), n.save(), n.clip(), n.fillRect(0, 0, Math.max(e, i) + 1, Math.max(t, r)), n.restore();
}
function nc(n, e) {
  return Math.abs(n[e * 4] - 210) > 2 || Math.abs(n[e * 4 + 3] - 0.75 * 255) > 2;
}
function FE() {
  if (tc === void 0) {
    const n = je(6, 6, Br);
    n.globalCompositeOperation = "lighter", n.fillStyle = "rgba(210, 0, 0, 0.75)", qd(n, 4, 5, 4, 0), qd(n, 4, 5, 0, 5);
    const e = n.getImageData(0, 0, 3, 3).data;
    tc = nc(e, 0) || nc(e, 4) || nc(e, 8), Ja(n), Br.push(n.canvas);
  }
  return tc;
}
function Hc(n, e, t, i) {
  const r = rn(t, e, n);
  let s = da(
    e,
    i,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (s *= o);
  const a = n.getMetersPerUnit();
  a !== void 0 && (s /= a);
  const l = n.getExtent();
  if (!l || jr(l, r)) {
    const c = da(n, s, r) / s;
    isFinite(c) && c > 0 && (s /= c);
  }
  return s;
}
function kE(n, e, t, i) {
  const r = nn(t);
  let s = Hc(
    n,
    e,
    r,
    i
  );
  return (!isFinite(s) || s <= 0) && Zf(t, function(o) {
    return s = Hc(
      n,
      e,
      o,
      i
    ), isFinite(s) && s > 0;
  }), s;
}
function NE(n, e, t, i, r, s, o, a, l, c, h, u, d, f) {
  const g = je(
    Math.round(t * n),
    Math.round(t * e),
    Br
  );
  if (u || (g.imageSmoothingEnabled = !1), l.length === 0)
    return g.canvas;
  g.scale(t, t);
  function _(v) {
    return Math.round(v * t) / t;
  }
  g.globalCompositeOperation = "lighter";
  const m = St();
  l.forEach(function(v, S, w) {
    Hf(m, v.extent);
  });
  let y;
  const p = t / i, E = (u ? 1 : 1 + Math.pow(2, -24)) / p;
  y = je(
    Math.round(Ee(m) * p),
    Math.round(ut(m) * p),
    Br
  ), u || (y.imageSmoothingEnabled = !1), l.forEach(function(v, S, w) {
    if (v.image.width > 0 && v.image.height > 0) {
      if (v.clipExtent) {
        y.save();
        const k = (v.clipExtent[0] - m[0]) * p, D = -(v.clipExtent[3] - m[3]) * p, U = Ee(v.clipExtent) * p, X = ut(v.clipExtent) * p;
        y.rect(
          u ? k : Math.round(k),
          u ? D : Math.round(D),
          u ? U : Math.round(k + U) - Math.round(k),
          u ? X : Math.round(D + X) - Math.round(D)
        ), y.clip();
      }
      const b = (v.extent[0] - m[0]) * p, P = -(v.extent[3] - m[3]) * p, O = Ee(v.extent) * p, N = ut(v.extent) * p;
      y.drawImage(
        v.image,
        c,
        c,
        v.image.width - 2 * c,
        v.image.height - 2 * c,
        u ? b : Math.round(b),
        u ? P : Math.round(P),
        u ? O : Math.round(b + O) - Math.round(b),
        u ? N : Math.round(P + N) - Math.round(P)
      ), v.clipExtent && y.restore();
    }
  });
  const x = or(o);
  return a.getTriangles().forEach(function(v, S, w) {
    const b = v.source, P = v.target;
    let O = b[0][0], N = b[0][1], k = b[1][0], D = b[1][1], U = b[2][0], X = b[2][1];
    const I = _((P[0][0] - x[0]) / s), F = _(
      -(P[0][1] - x[1]) / s
    ), B = _((P[1][0] - x[0]) / s), $ = _(
      -(P[1][1] - x[1]) / s
    ), H = _((P[2][0] - x[0]) / s), re = _(
      -(P[2][1] - x[1]) / s
    ), A = O, Fe = N;
    O = 0, N = 0, k -= A, D -= Fe, U -= A, X -= Fe;
    const ze = [
      [k, D, 0, 0, B - I],
      [U, X, 0, 0, H - I],
      [0, 0, k, D, $ - F],
      [0, 0, U, X, re - F]
    ], Ce = uy(ze);
    if (!Ce)
      return;
    if (g.save(), g.beginPath(), FE() || !u) {
      g.moveTo(B, $);
      const We = 4, ft = I - B, gt = F - $;
      for (let qe = 0; qe < We; qe++)
        g.lineTo(
          B + _((qe + 1) * ft / We),
          $ + _(qe * gt / (We - 1))
        ), qe != We - 1 && g.lineTo(
          B + _((qe + 1) * ft / We),
          $ + _((qe + 1) * gt / (We - 1))
        );
      g.lineTo(H, re);
    } else
      g.moveTo(B, $), g.lineTo(I, F), g.lineTo(H, re);
    g.clip(), g.transform(
      Ce[0],
      Ce[2],
      Ce[1],
      Ce[3],
      I,
      F
    ), g.translate(
      m[0] - A,
      m[3] - Fe
    );
    let nt;
    if (y)
      nt = y.canvas, g.scale(E, -E);
    else {
      const We = l[0], ft = We.extent;
      nt = We.image, g.scale(
        Ee(ft) / nt.width,
        -ut(ft) / nt.height
      );
    }
    g.drawImage(nt, 0, 0), g.restore();
  }), y && (Ja(y), Br.push(y.canvas)), h && (g.save(), g.globalCompositeOperation = "source-over", g.strokeStyle = "black", g.lineWidth = 1, a.getTriangles().forEach(function(v, S, w) {
    const b = v.target, P = (b[0][0] - x[0]) / s, O = -(b[0][1] - x[1]) / s, N = (b[1][0] - x[0]) / s, k = -(b[1][1] - x[1]) / s, D = (b[2][0] - x[0]) / s, U = -(b[2][1] - x[1]) / s;
    g.beginPath(), g.moveTo(N, k), g.lineTo(P, O), g.lineTo(D, U), g.closePath(), g.stroke();
  }), g.restore()), g.canvas;
}
const GE = 10, Jd = 0.25;
class UE {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
   */
  constructor(e, t, i, r, s, o, a) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let l = {};
    const c = a ? By(
      (E) => Ue(
        a,
        rn(E, this.targetProj_, this.sourceProj_)
      )
    ) : Kr(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(E) {
      const x = E[0] + "/" + E[1];
      return l[x] || (l[x] = c(E)), l[x];
    }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = s * s, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && Ee(r) >= Ee(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Ee(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Ee(this.targetProj_.getExtent()) : null;
    const h = or(i), u = ja(i), d = $a(i), f = Ya(i), g = this.transformInv_(h), _ = this.transformInv_(u), m = this.transformInv_(d), y = this.transformInv_(f), p = GE + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          Pc(i) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      h,
      u,
      d,
      f,
      g,
      _,
      m,
      y,
      p
    ), this.wrapsXInSource_) {
      let E = 1 / 0;
      this.triangles_.forEach(function(x, v, S) {
        E = Math.min(
          E,
          x.source[0][0],
          x.source[1][0],
          x.source[2][0]
        );
      }), this.triangles_.forEach((x) => {
        if (Math.max(
          x.source[0][0],
          x.source[1][0],
          x.source[2][0]
        ) - E > this.sourceWorldWidth_ / 2) {
          const v = [
            [x.source[0][0], x.source[0][1]],
            [x.source[1][0], x.source[1][1]],
            [x.source[2][0], x.source[2][1]]
          ];
          v[0][0] - E > this.sourceWorldWidth_ / 2 && (v[0][0] -= this.sourceWorldWidth_), v[1][0] - E > this.sourceWorldWidth_ / 2 && (v[1][0] -= this.sourceWorldWidth_), v[2][0] - E > this.sourceWorldWidth_ / 2 && (v[2][0] -= this.sourceWorldWidth_);
          const S = Math.min(
            v[0][0],
            v[1][0],
            v[2][0]
          );
          Math.max(
            v[0][0],
            v[1][0],
            v[2][0]
          ) - S < this.sourceWorldWidth_ / 2 && (x.source = v);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, i, r, s, o) {
    this.triangles_.push({
      source: [r, s, o],
      target: [e, t, i]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, i, r, s, o, a, l, c) {
    const h = nd([s, o, a, l]), u = this.sourceWorldWidth_ ? Ee(h) / this.sourceWorldWidth_ : null, d = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
    let g = !1;
    if (c > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = nd([e, t, i, r]);
        g = Ee(m) / this.targetWorldWidth_ > Jd || g;
      }
      !f && this.sourceProj_.isGlobal() && u && (g = u > Jd || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !vt(h, this.maxSourceExtent_))
      return;
    let _ = 0;
    if (!g && (!isFinite(s[0]) || !isFinite(s[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (c > 0)
        g = !0;
      else if (_ = (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), _ != 1 && _ != 2 && _ != 4 && _ != 8)
        return;
    }
    if (c > 0) {
      if (!g) {
        const m = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], y = this.transformInv_(m);
        let p;
        f ? p = (Hi(s[0], d) + Hi(a[0], d)) / 2 - Hi(y[0], d) : p = (s[0] + a[0]) / 2 - y[0];
        const E = (s[1] + a[1]) / 2 - y[1];
        g = p * p + E * E > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(e[0] - i[0]) <= Math.abs(e[1] - i[1])) {
          const m = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], y = this.transformInv_(m), p = [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2], E = this.transformInv_(p);
          this.addQuad_(
            e,
            t,
            m,
            p,
            s,
            o,
            y,
            E,
            c - 1
          ), this.addQuad_(
            p,
            m,
            i,
            r,
            E,
            y,
            a,
            l,
            c - 1
          );
        } else {
          const m = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], y = this.transformInv_(m), p = [(i[0] + r[0]) / 2, (i[1] + r[1]) / 2], E = this.transformInv_(p);
          this.addQuad_(
            e,
            m,
            p,
            r,
            s,
            y,
            E,
            l,
            c - 1
          ), this.addQuad_(
            m,
            t,
            i,
            p,
            y,
            o,
            a,
            E,
            c - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    _ & 11 || this.addTriangle_(e, i, r, s, a, l), _ & 14 || this.addTriangle_(e, i, t, s, a, o), _ && (_ & 13 || this.addTriangle_(t, r, e, o, l, s), _ & 7 || this.addTriangle_(t, r, i, o, l, a));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = St();
    return this.triangles_.forEach(function(t, i, r) {
      const s = t.source;
      As(e, s[0]), As(e, s[1]), As(e, s[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const BE = 0.5;
class pm extends al {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, r, s, o, a, l, c, h, u, d) {
    super(s, Z.IDLE, d), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = a, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = r, this.wrappedTileCoord_ = o || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
    const f = r.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let _ = this.sourceTileGrid_.getExtent();
    const m = g ? Vi(f, g) : f;
    if (Pc(m) === 0) {
      this.state = Z.EMPTY;
      return;
    }
    const y = e.getExtent();
    y && (_ ? _ = Vi(_, y) : _ = y);
    const p = r.getResolution(
      this.wrappedTileCoord_[0]
    ), E = kE(
      e,
      i,
      m,
      p
    );
    if (!isFinite(E) || E <= 0) {
      this.state = Z.EMPTY;
      return;
    }
    const x = h !== void 0 ? h : BE;
    if (this.triangulation_ = new UE(
      e,
      i,
      m,
      _,
      E * x,
      p
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = Z.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(E);
    let v = this.triangulation_.calculateSourceExtent();
    if (_ && (e.canWrapX() ? (v[1] = De(
      v[1],
      _[1],
      _[3]
    ), v[3] = De(
      v[3],
      _[1],
      _[3]
    )) : v = Vi(v, _)), !Pc(v))
      this.state = Z.EMPTY;
    else {
      let S = 0, w = 0;
      e.canWrapX() && (S = Ee(y), w = Math.floor(
        (v[0] - y[0]) / S
      )), eg(
        v.slice(),
        e,
        !0
      ).forEach((P) => {
        const O = t.getTileRangeForExtentAndZ(
          P,
          this.sourceZ_
        );
        for (let N = O.minX; N <= O.maxX; N++)
          for (let k = O.minY; k <= O.maxY; k++) {
            const D = c(this.sourceZ_, N, k, a);
            if (D) {
              const U = w * S;
              this.sourceTiles_.push({ tile: D, offset: U });
            }
          }
        ++w;
      }), this.sourceTiles_.length === 0 && (this.state = Z.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      var r;
      const i = t.tile;
      if (i && i.getState() == Z.LOADED) {
        const s = this.sourceTileGrid_.getTileCoordExtent(i.tileCoord);
        s[0] += t.offset, s[2] += t.offset;
        const o = (r = this.clipExtent_) == null ? void 0 : r.slice();
        o && (o[0] += t.offset, o[2] += t.offset), e.push({
          extent: s,
          clipExtent: o,
          image: i.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = Z.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(t), r = typeof i == "number" ? i : i[0], s = typeof i == "number" ? i : i[1], o = this.targetTileGrid_.getResolution(t), a = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = NE(
        r,
        s,
        this.pixelRatio_,
        a,
        this.sourceTileGrid_.getExtent(),
        o,
        l,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = Z.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == Z.IDLE) {
      this.state = Z.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: t }) => {
        const i = t.getState();
        if (i == Z.IDLE || i == Z.LOADING) {
          e++;
          const r = ce(t, ie.CHANGE, (s) => {
            const o = t.getState();
            (o == Z.LOADED || o == Z.ERROR || o == Z.EMPTY) && (Re(r), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
          });
          this.sourcesListenerKeys_.push(r);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: t }, i, r) {
        t.getState() == Z.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(Re), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    this.canvas_ && (Ja(this.canvas_.getContext("2d")), Br.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
class zE extends Yg {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && Tt(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tmpSize = [0, 0], this.key_ = e.key || q(this), this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {TileType|null} Tile.
   */
  getTile(e, t, i, r, s) {
    return Q();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : dm(e);
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, i) {
    const r = this.getTileGridForProjection(i), s = this.getTilePixelRatio(t), o = Tt(r.getTileSize(e), this.tmpSize);
    return s == 1 ? o : lx(o, s, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    const i = t !== void 0 ? t : this.getProjection(), r = t !== void 0 ? this.getTileGridForProjection(i) : this.tileGrid || this.getTileGridForProjection(i);
    return this.getWrapX() && i.isGlobal() && (e = SE(r, e, i)), wE(e, r) ? e : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear(), super.refresh();
  }
}
class WE extends ai {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const ic = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class su extends zE {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === su.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), i = q(t), r = t.getState();
    let s;
    r == Z.LOADING ? (this.tileLoadingKeys_[i] = !0, s = ic.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], s = r == Z.ERROR ? ic.TILELOADERROR : r == Z.LOADED ? ic.TILELOADEND : void 0), s != null && this.dispatchEvent(new WE(s, t));
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileLoadFunction = e, this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = OE(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(DE(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, i) {
  }
}
class ou extends su {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : YE,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : Jh, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !Qo(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || Qo(t, e)))
      return this.tileGrid;
    const i = q(e);
    return i in this.tileGridForProjection || (this.tileGridForProjection[i] = dm(e)), this.tileGridForProjection[i];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, i, r, s, o) {
    const a = [e, t, i], l = this.getTileCoordForTileUrlFunction(
      a,
      s
    ), c = l ? this.tileUrlFunction(l, r, s) : void 0, h = new this.tileClass(
      a,
      c !== void 0 ? Z.IDLE : Z.EMPTY,
      c !== void 0 ? c : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return h.key = o, h.addEventListener(ie.CHANGE, this.handleTileChange.bind(this)), h;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(e, t, i, r, s) {
    const o = this.getProjection();
    if (!o || !s || Qo(o, s))
      return this.getTileInternal(
        e,
        t,
        i,
        r,
        o || s
      );
    const a = [e, t, i], l = this.getKey(), c = this.getTileGridForProjection(o), h = this.getTileGridForProjection(s), u = this.getTileCoordForTileUrlFunction(
      a,
      s
    ), d = new pm(
      o,
      c,
      s,
      h,
      a,
      u,
      this.getTilePixelRatio(r),
      this.getGutter(),
      (f, g, _, m) => this.getTileInternal(f, g, _, m, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return d.key = l, d;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, i, r, s) {
    const o = this.getKey();
    return this.createTile_(e, t, i, r, s, o);
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    this.renderReprojectionEdges_ != e && (this.renderReprojectionEdges_ = e, this.changed());
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const i = Ie(e);
    if (i) {
      const r = q(i);
      r in this.tileGridForProjection || (this.tileGridForProjection[r] = t);
    }
  }
}
function YE(n, e) {
  n.getImage().src = e;
}
function $E(n) {
  const e = n[0], t = new Array(e);
  let i = 1 << e - 1, r, s;
  for (r = 0; r < e; ++r)
    s = 48, n[1] & i && (s += 1), n[2] & i && (s += 2), t[r] = String.fromCharCode(s), i >>= 1;
  return t.join("");
}
const jE = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
class VE extends ou {
  /**
   * @param {Options} options Bing Maps options.
   */
  constructor(e) {
    const t = e.hidpi !== void 0 ? e.hidpi : !1;
    super({
      cacheSize: e.cacheSize,
      crossOrigin: "anonymous",
      interpolate: e.interpolate,
      projection: Ie("EPSG:3857"),
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: t ? 2 : 1,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.hidpi_ = t, this.culture_ = e.culture !== void 0 ? e.culture : "en-us", this.maxZoom_ = e.maxZoom !== void 0 ? e.maxZoom : -1, this.apiKey_ = e.key, this.imagerySet_ = e.imagerySet, this.placeholderTiles_ = e.placeholderTiles;
    const i = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
    fetch(i).then((r) => r.json()).then((r) => this.handleImageryMetadataResponse(r));
  }
  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */
  getApiKey() {
    return this.apiKey_;
  }
  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */
  getImagerySet() {
    return this.imagerySet_;
  }
  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */
  handleImageryMetadataResponse(e) {
    if (e.statusCode != 200 || e.statusDescription != "OK" || e.authenticationResultCode != "ValidCredentials" || e.resourceSets.length != 1 || e.resourceSets[0].resources.length != 1) {
      this.setState("error");
      return;
    }
    const t = e.resourceSets[0].resources[0], i = this.maxZoom_ == -1 ? t.zoomMax : this.maxZoom_, r = this.getProjection(), s = ll(r), o = this.hidpi_ ? 2 : 1, a = t.imageWidth == t.imageHeight ? t.imageWidth / o : [t.imageWidth / o, t.imageHeight / o], l = fm({
      extent: s,
      minZoom: t.zoomMin,
      maxZoom: i,
      tileSize: a
    });
    this.tileGrid = l;
    const c = this.culture_, h = this.hidpi_, u = this.placeholderTiles_;
    if (this.tileUrlFunction = _m(
      t.imageUrlSubdomains.map(function(d) {
        const f = [0, 0, 0], g = t.imageUrl.replace("{subdomain}", d).replace("{culture}", c);
        return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          function(_, m, y) {
            if (!_)
              return;
            Zs(
              _[0],
              _[1],
              _[2],
              f
            );
            const p = new URL(
              g.replace("{quadkey}", $E(f))
            ), E = p.searchParams;
            return h && (E.set("dpi", "d1"), E.set("device", "mobile")), u === !0 ? E.delete("n") : u === !1 && E.set("n", "z"), p.toString();
          }
        );
      })
    ), t.imageryProviders) {
      const d = Ha(
        Ie("EPSG:4326"),
        this.getProjection()
      );
      this.setAttributions((f) => {
        const g = [], _ = f.viewState, m = this.getTileGrid(), y = m.getZForResolution(
          _.resolution,
          this.zDirection
        ), E = m.getTileCoordForCoordAndZ(
          _.center,
          y
        )[0];
        return t.imageryProviders.map(function(x) {
          let v = !1;
          const S = x.coverageAreas;
          for (let w = 0, b = S.length; w < b; ++w) {
            const P = S[w];
            if (E >= P.zoomMin && E <= P.zoomMax) {
              const O = P.bbox, N = [O[1], O[0], O[3], O[2]], k = Jf(N, d);
              if (vt(k, f.extent)) {
                v = !0;
                break;
              }
            }
          }
          v && g.push(x.attribution);
        }), g.push(jE), g;
      });
    }
    this.setState("ready");
  }
}
class Qd extends ou {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", i = e.tileGrid !== void 0 ? e.tileGrid : fm({
      extent: ll(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
}
class XE extends fo {
  /**
   * @param {Options<FeatureType>} [options] Cluster options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const i = (
        /** @type {Point} */
        t.getGeometry()
      );
      return ge(
        !i || i.getType() === "Point",
        "The default `geometryFunction` can only handle `Point` or null geometries"
      ), i;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   * @override
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource<FeatureType>|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @override
   */
  loadFeatures(e, t, i) {
    var r;
    (r = this.source) == null || r.loadFeatures(e, t, i), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource<FeatureType>|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(ie.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(ie.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   * @override
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const i = e === 0 ? 0 : Math.min(t, e) / e, r = e !== this.distance || this.interpolationRatio !== i;
    this.distance = e, this.minDistance = t, this.interpolationRatio = i, r && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = St(), t = this.distance * this.resolution, i = this.source.getFeatures(), r = {};
    for (let s = 0, o = i.length; s < o; s++) {
      const a = i[s];
      if (!(q(a) in r)) {
        const l = this.geometryFunction(a);
        if (l) {
          const c = l.getCoordinates();
          xh(c, e), ni(e, t, e);
          const h = this.source.getFeaturesInExtent(e).filter(function(u) {
            const d = q(u);
            return d in r ? !1 : (r[d] = !0, !0);
          });
          this.features.push(this.createCluster(h, e));
        }
      }
    }
  }
  /**
   * @param {Array<FeatureType>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const i = [0, 0];
    for (let a = e.length - 1; a >= 0; --a) {
      const l = this.geometryFunction(e[a]);
      l ? ig(i, l.getCoordinates()) : e.splice(a, 1);
    }
    rg(i, 1 / e.length);
    const r = nn(t), s = this.interpolationRatio, o = new on([
      i[0] * (1 - s) + r[0] * s,
      i[1] * (1 - s) + r[1] * s
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new Ri({
      geometry: o,
      features: e
    });
  }
}
function Kc(n) {
  return n instanceof Image || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageBitmap ? n : null;
}
const HE = new Error("disposed"), KE = [256, 256];
class ef extends al {
  /**
   * @param {Options} options Tile options.
   */
  constructor(e) {
    const t = Z.IDLE;
    super(e.tileCoord, t, {
      transition: e.transition,
      interpolate: e.interpolate
    }), this.loader_ = e.loader, this.data_ = null, this.error_ = null, this.size_ = e.size || null, this.controller_ = e.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_)
      return this.size_;
    const e = Kc(this.data_);
    return e ? [e.width, e.height] : KE;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== Z.IDLE && this.state !== Z.ERROR)
      return;
    this.state = Z.LOADING, this.changed();
    const e = this;
    this.loader_().then(function(t) {
      e.data_ = t, e.state = Z.LOADED, e.changed();
    }).catch(function(t) {
      e.error_ = t, e.state = Z.ERROR, e.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controller_ && (this.controller_.abort(HE), this.controller_ = null), super.disposeInternal();
  }
}
function ym() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Zc(n, e) {
  return n[0] = e[0], n[1] = e[1], n[4] = e[2], n[5] = e[3], n[12] = e[4], n[13] = e[5], n;
}
const tf = 4, qc = "1.3.0";
function ZE(n, e, t, i, r) {
  r.WIDTH = t[0], r.HEIGHT = t[1];
  const s = i.getAxisOrientation(), o = ng(r.VERSION, "1.3") >= 0;
  r[o ? "CRS" : "SRS"] = i.getCode();
  const a = o && s.startsWith("ne") ? [e[1], e[0], e[3], e[2]] : e;
  return r.BBOX = a.join(","), mm(n, r);
}
function qE(n, e, t, i, r, s, o) {
  s = Object.assign({ REQUEST: "GetMap" }, s);
  const a = e / t, l = [
    rd(Ee(n) / a, tf),
    rd(ut(n) / a, tf)
  ];
  if (t != 1)
    switch (o) {
      case "geoserver":
        const h = 90 * t + 0.5 | 0;
        "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + h : s.FORMAT_OPTIONS = "dpi:" + h;
        break;
      case "mapserver":
        s.MAP_RESOLUTION = 90 * t;
        break;
      case "carmentaserver":
      case "qgis":
        s.DPI = 90 * t;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return ZE(r, n, l, i, s);
}
function nf(n, e) {
  return Object.assign(
    {
      REQUEST: e,
      SERVICE: "WMS",
      VERSION: qc,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: "TRUE"
    },
    n
  );
}
function rc(n, e, t, i, r) {
  return `${q(n)},${e},${EE(t, i, r)}`;
}
function sc(n, e, t) {
  if (!(t in n))
    return n[t] = /* @__PURE__ */ new Set([e]), !0;
  const i = n[t], r = i.has(e);
  return r || i.add(e), !r;
}
function JE(n, e, t) {
  const i = n[t];
  return i ? i.delete(e) : !1;
}
function rf(n, e) {
  const t = n.layerStatesArray[n.layerIndex];
  t.extent && (e = Vi(
    e,
    yi(t.extent, n.viewState.projection)
  ));
  const i = (
    /** @type {import("../../source/Tile.js").default} */
    t.layer.getRenderSource()
  );
  if (!i.getWrapX()) {
    const r = i.getTileGridForProjection(n.viewState.projection).getExtent();
    r && (e = Vi(e, r));
  }
  return e;
}
class QE extends Hg {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = St(), this.tempTileRange_ = new tu(0, 0, 0, 0), this.tempTileCoord_ = Zs(0, 0, 0);
    const i = t.cacheSize !== void 0 ? t.cacheSize : 512;
    this.tileCache_ = new vE(i), this.maxStaleKeys = i * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(e, t, i, r) {
    const s = this.tileCache_, a = this.getLayer().getSource(), l = rc(a, a.getKey(), e, t, i);
    let c;
    if (s.containsKey(l))
      c = s.get(l);
    else {
      if (c = a.getTile(
        e,
        t,
        i,
        r.pixelRatio,
        r.viewState.projection
      ), !c)
        return null;
      s.set(l, c);
    }
    return c;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(e, t, i, r) {
    const s = this.getOrCreateTile(e, t, i, r);
    return s || null;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const i = this.getLayer(), r = Ue(
      t.pixelToCoordinateTransform,
      e.slice()
    ), s = i.getExtent();
    if (s && !jr(s, r))
      return null;
    const o = t.viewState, a = i.getRenderSource(), l = a.getTileGridForProjection(o.projection), c = a.getTilePixelRatio(t.pixelRatio);
    for (let h = l.getZForResolution(o.resolution); h >= l.getMinZoom(); --h) {
      const u = l.getTileCoordForCoordAndZ(r, h), d = this.getTile(h, u[1], u[2], t);
      if (!d || d.getState() !== Z.LOADED)
        continue;
      const f = l.getOrigin(h), g = Tt(l.getTileSize(h)), _ = l.getResolution(h);
      let m;
      if (d instanceof Jh || d instanceof pm)
        m = d.getImage();
      else if (d instanceof ef) {
        if (m = Kc(d.getData()), !m)
          continue;
      } else
        continue;
      const y = Math.floor(
        c * ((r[0] - f[0]) / _ - u[1] * g[0])
      ), p = Math.floor(
        c * ((f[1] - r[1]) / _ - u[2] * g[1])
      ), E = Math.round(
        c * a.getGutterForProjection(o.projection)
      );
      return this.getImageData(m, y + E, p + E);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    this.renderedProjection ? e.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = e.viewState.projection) : this.renderedProjection = e.viewState.projection;
    const t = this.getLayer().getSource();
    if (!t)
      return !1;
    const i = t.getRevision();
    return this.renderedSourceRevision_ ? this.renderedSourceRevision_ !== i && (this.renderedSourceRevision_ = i, this.renderedSourceKey_ === t.getKey() && this.tileCache_.clear()) : this.renderedSourceRevision_ = i, !0;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(e, t, i, r, s) {
    const o = e.viewState, a = this.getLayer(), l = a.getRenderSource(), c = l.getTileGridForProjection(o.projection), h = q(l);
    h in e.wantedTiles || (e.wantedTiles[h] = {});
    const u = e.wantedTiles[h], d = a.getMapInternal(), f = Math.max(
      i - s,
      c.getMinZoom(),
      c.getZForResolution(
        Math.min(
          a.getMaxResolution(),
          d ? d.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : c.getResolution(0)
        ),
        l.zDirection
      )
    ), g = o.rotation, _ = g ? qf(
      o.center,
      o.resolution,
      g,
      e.size
    ) : void 0;
    for (let m = i; m >= f; --m) {
      const y = c.getTileRangeForExtentAndZ(
        t,
        m,
        this.tempTileRange_
      ), p = c.getResolution(m);
      for (let E = y.minX; E <= y.maxX; ++E)
        for (let x = y.minY; x <= y.maxY; ++x) {
          if (g && !c.tileCoordIntersectsViewport([m, E, x], _))
            continue;
          const v = this.getTile(m, E, x, e);
          if (!v || !sc(r, v, m))
            continue;
          const w = v.getKey();
          if (u[w] = !0, v.getState() === Z.IDLE && !e.tileQueue.isKeyQueued(w)) {
            const b = Zs(m, E, x, this.tempTileCoord_);
            e.tileQueue.enqueue([
              v,
              h,
              c.getTileCoordCenter(b),
              p
            ]);
          }
        }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(e, t) {
    const i = this.tileCache_, r = e[0], s = e[1], o = e[2], a = this.getStaleKeys();
    for (let l = 0; l < a.length; ++l) {
      const c = rc(
        this.getLayer().getSource(),
        a[l],
        r,
        s,
        o
      );
      if (i.containsKey(c)) {
        const h = i.peek(c);
        if (h.getState() === Z.LOADED)
          return h.endTransition(q(this)), sc(t, h, r), !0;
      }
    }
    return !1;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(e, t, i, r) {
    const s = e.getTileRangeForTileCoordAndZ(
      t,
      i,
      this.tempTileRange_
    );
    if (!s)
      return !1;
    let o = !0;
    const a = this.tileCache_, l = this.getLayer().getRenderSource(), c = l.getKey();
    for (let h = s.minX; h <= s.maxX; ++h)
      for (let u = s.minY; u <= s.maxY; ++u) {
        const d = rc(l, c, i, h, u);
        let f = !1;
        if (a.containsKey(d)) {
          const g = a.peek(d);
          g.getState() === Z.LOADED && (sc(r, g, i), f = !0);
        }
        f || (o = !1);
      }
    return o;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e, t) {
    this.renderComplete = !0;
    const i = e.layerStatesArray[e.layerIndex], r = e.viewState, s = r.projection, o = r.resolution, a = r.center, l = e.pixelRatio, c = this.getLayer(), h = c.getSource(), u = h.getTileGridForProjection(s), d = u.getZForResolution(o, h.zDirection), f = u.getResolution(d), g = h.getKey();
    this.renderedSourceKey_ ? this.renderedSourceKey_ !== g && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = g) : this.renderedSourceKey_ = g;
    let _ = e.extent;
    const m = h.getTilePixelRatio(l);
    this.prepareContainer(e, t);
    const y = this.context.canvas.width, p = this.context.canvas.height, E = i.extent && yi(i.extent);
    E && (_ = Vi(
      _,
      yi(i.extent)
    ));
    const x = f * y / 2 / m, v = f * p / 2 / m, S = [
      a[0] - x,
      a[1] - v,
      a[0] + x,
      a[1] + v
    ], w = {};
    this.renderedTiles.length = 0;
    const b = c.getPreload();
    if (e.nextExtent) {
      const B = u.getZForResolution(
        r.nextResolution,
        h.zDirection
      ), $ = rf(e, e.nextExtent);
      this.enqueueTiles(e, $, B, w, b);
    }
    const P = rf(e, _);
    if (this.enqueueTiles(e, P, d, w, 0), b > 0 && setTimeout(() => {
      this.enqueueTiles(
        e,
        P,
        d - 1,
        w,
        b - 1
      );
    }, 0), !(d in w))
      return this.container;
    const O = q(this), N = e.time;
    for (const B of w[d]) {
      const $ = B.getState();
      if ($ === Z.EMPTY)
        continue;
      const H = B.tileCoord;
      if ($ === Z.LOADED && B.getAlpha(O, N) === 1) {
        B.endTransition(O);
        continue;
      }
      if ($ !== Z.ERROR && (this.renderComplete = !1), this.findStaleTile_(H, w)) {
        JE(w, B, d), e.animate = !0;
        continue;
      }
      if (this.findAltTiles_(
        u,
        H,
        d + 1,
        w
      ))
        continue;
      const Fe = u.getMinZoom();
      for (let ze = d - 1; ze >= Fe && !this.findAltTiles_(
        u,
        H,
        ze,
        w
      ); --ze)
        ;
    }
    const k = f / o * l / m, D = this.getRenderContext(e);
    sn(
      this.tempTransform,
      y / 2,
      p / 2,
      k,
      k,
      0,
      -y / 2,
      -p / 2
    ), i.extent && this.clipUnrotated(D, e, E), h.getInterpolate() || (D.imageSmoothingEnabled = !1), this.preRender(D, e);
    const U = Object.keys(w).map(Number);
    U.sort(Kn);
    let X;
    const I = [], F = [];
    for (let B = U.length - 1; B >= 0; --B) {
      const $ = U[B], H = h.getTilePixelSize(
        $,
        l,
        s
      ), A = u.getResolution($) / f, Fe = H[0] * A * k, ze = H[1] * A * k, Ce = u.getTileCoordForCoordAndZ(
        or(S),
        $
      ), nt = u.getTileCoordExtent(Ce), We = Ue(this.tempTransform, [
        m * (nt[0] - S[0]) / f,
        m * (S[3] - nt[3]) / f
      ]), ft = m * h.getGutterForProjection(s);
      for (const gt of w[$]) {
        if (gt.getState() !== Z.LOADED)
          continue;
        const qe = gt.tileCoord, dr = Ce[1] - qe[1], fr = Math.round(We[0] - (dr - 1) * Fe), Ai = Ce[2] - qe[2], In = Math.round(We[1] - (Ai - 1) * ze), it = Math.round(We[0] - dr * Fe), ot = Math.round(We[1] - Ai * ze), An = fr - it, Ln = In - ot, fn = U.length === 1;
        let On = !1;
        X = [it, ot, it + An, ot, it + An, ot + Ln, it, ot + Ln];
        for (let hi = 0, gn = I.length; hi < gn; ++hi)
          if (!fn && $ < F[hi]) {
            const Ye = I[hi];
            vt(
              [it, ot, it + An, ot + Ln],
              [Ye[0], Ye[3], Ye[4], Ye[7]]
            ) && (On || (D.save(), On = !0), D.beginPath(), D.moveTo(X[0], X[1]), D.lineTo(X[2], X[3]), D.lineTo(X[4], X[5]), D.lineTo(X[6], X[7]), D.moveTo(Ye[6], Ye[7]), D.lineTo(Ye[4], Ye[5]), D.lineTo(Ye[2], Ye[3]), D.lineTo(Ye[0], Ye[1]), D.clip());
          }
        I.push(X), F.push($), this.drawTile(gt, e, it, ot, An, Ln, ft, fn), On && D.restore(), this.renderedTiles.unshift(gt), this.updateUsedTiles(e.usedTiles, h, gt);
      }
    }
    if (this.renderedResolution = f, this.extentChanged = !this.renderedExtent_ || !Vr(this.renderedExtent_, S), this.renderedExtent_ = S, this.renderedPixelRatio = l, this.postRender(this.context, e), i.extent && D.restore(), D.imageSmoothingEnabled = !0, this.renderComplete) {
      const B = ($, H) => {
        const re = q(h), A = H.wantedTiles[re], Fe = A ? Object.keys(A).length : 0;
        this.updateCacheSize(Fe), this.tileCache_.expireCache();
      };
      e.postRenderFunctions.push(B);
    }
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(e) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      e * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(e, t, i, r, s, o, a, l) {
    let c;
    if (e instanceof ef) {
      if (c = Kc(e.getData()), !c)
        throw new Error("Rendering array data is not yet supported");
    } else
      c = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        e
      );
    if (!c)
      return;
    const h = this.getRenderContext(t), u = q(this), d = t.layerStatesArray[t.layerIndex], f = d.opacity * (l ? e.getAlpha(u, t.time) : 1), g = f !== h.globalAlpha;
    g && (h.save(), h.globalAlpha = f), h.drawImage(
      c,
      a,
      a,
      c.width - 2 * a,
      c.height - 2 * a,
      i,
      r,
      s,
      o
    ), g && h.restore(), f !== d.opacity ? t.animate = !0 : l && e.endTransition(u);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, i) {
    const r = q(t);
    r in e || (e[r] = {}), e[r][i.getKey()] = !0;
  }
}
const $o = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class e1 extends ir {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e), i = e.cacheSize;
    delete e.cacheSize, delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.cacheSize_ = i, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get($o.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set($o.PRELOAD, e);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get($o.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set($o.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(e) {
    return super.getData(e);
  }
}
class jo extends e1 {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  /**
   * @override
   */
  createRenderer() {
    return new QE(this, {
      cacheSize: this.getCacheSize()
    });
  }
}
class xm extends ou {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params);
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = St(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, i, r) {
    const s = Ie(i), o = this.getProjection() || s;
    let a = this.getTileGrid();
    a || (a = this.getTileGridForProjection(o));
    const l = rn(
      e,
      s,
      o
    ), c = Hc(
      o,
      s,
      e,
      t
    ), h = a.getZForResolution(c, this.zDirection), u = a.getResolution(h), d = a.getTileCoordForCoordAndZ(l, h);
    if (a.getResolutions().length <= d[0])
      return;
    let f = a.getTileCoordExtent(d, this.tmpExtent_);
    const g = this.gutter_;
    g !== 0 && (f = ni(f, u * g, f));
    const _ = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      _,
      nf(this.params_, "GetFeatureInfo"),
      r
    );
    const m = Math.floor((l[0] - f[0]) / u), y = Math.floor((f[3] - l[1]) / u);
    return _[this.v13_ ? "I" : "X"] = m, _[this.v13_ ? "J" : "Y"] = y, this.getRequestUrl_(
      d,
      f,
      1,
      o || s,
      _
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const i = {
      SERVICE: "WMS",
      VERSION: qc,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      i.LAYER = r;
    }
    if (e !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
      i.SCALE = e * r / s;
    }
    return Object.assign(i, t), mm(
      /** @type {string} */
      this.urls[0],
      i
    );
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, i, r, s) {
    const o = this.urls;
    if (!o)
      return;
    let a;
    if (o.length == 1)
      a = o[0];
    else {
      const l = Hi(hm(e), o.length);
      a = o[l];
    }
    return qE(
      t,
      (this.tileGrid || this.getTileGridForProjection(r)).getResolution(e[0]),
      i,
      r,
      a,
      s,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const i in this.params_)
      t[e++] = i + "-" + this.params_[i];
    return t.join("/");
  }
  /**
   * @param {Object} params New URL paremeters.
   * @private
   */
  setParams_(e) {
    this.params_ = e, this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Set the URL parameters passed to the WMS source.
   * @param {Object} params New URL paremeters.
   * @api
   */
  setParams(e) {
    this.setParams_(Object.assign({}, e));
  }
  /**
   * Update the URL parameters. This method can be used to update a subset of the WMS
   * parameters. Call `setParams` to set all of the parameters.
   * @param {Object} params Updated URL parameters.
   * @api
   */
  updateParams(e) {
    this.setParams_(Object.assign(this.params_, e));
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || qc;
    this.v13_ = ng(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, i) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(i)), r.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const s = r.getResolution(e[0]);
    let o = r.getTileCoordExtent(e, this.tmpExtent_);
    const a = this.gutter_;
    a !== 0 && (o = ni(o, s * a, o));
    const l = Object.assign(
      {},
      nf(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      e,
      o,
      t,
      i,
      l
    );
  }
}
const t1 = "_map_ck8zd_1", n1 = "_latLon_ck8zd_7", i1 = "_layersLegend_ck8zd_18", au = {
  map: t1,
  latLon: n1,
  layersLegend: i1
}, r1 = "_map_11did_1", s1 = {
  map: r1
}, lu = 34962, cu = 34963, o1 = 35044, sf = 35048, a1 = 5121, l1 = 5123, c1 = 5125, vm = 5126, of = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function h1(n, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !g0
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = of.length;
  for (let i = 0; i < t; ++i)
    try {
      const r = n.getContext(of[i], e);
      if (r)
        return (
          /** @type {!WebGLRenderingContext} */
          r
        );
    } catch {
    }
  return null;
}
const u1 = {
  STATIC_DRAW: o1
};
class af {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `STATIC_DRAW`.
   */
  constructor(e, t) {
    this.array_ = null, this.type_ = e, ge(
      e === lu || e === cu,
      "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
    ), this.usage_ = t !== void 0 ? t : u1.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  ofSize(e) {
    return this.array_ = new (Vo(this.type_))(e), this;
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */
  fromArray(e) {
    return this.array_ = Vo(this.type_).from(e), this;
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */
  fromArrayBuffer(e) {
    return this.array_ = new (Vo(this.type_))(e), this;
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type_;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array|null} Array.
   */
  getArray() {
    return this.array_;
  }
  /**
   * @param {Float32Array|Uint32Array} array Array.
   */
  setArray(e) {
    const t = Vo(this.type_);
    if (!(e instanceof t))
      throw new Error(`Expected ${t}`);
    this.array_ = e;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage_;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array_ ? this.array_.length : 0;
  }
}
function Vo(n) {
  switch (n) {
    case lu:
      return Float32Array;
    case cu:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const Xo = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, d1 = `
  precision mediump float;

  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;

  uniform vec2 u_screenSize;

  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, f1 = `
  precision mediump float;

  uniform sampler2D u_image;
  uniform float u_opacity;

  varying vec2 v_texCoord;

  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class lf {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer(), this.depthBuffer_ = t.createRenderbuffer();
    const i = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      i,
      e.vertexShader || d1
    ), t.compileShader(i);
    const r = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      r,
      e.fragmentShader || f1
    ), t.compileShader(r), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, i), t.attachShader(this.renderTargetProgram_, r), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const s = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(s),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
      this.uniforms_.push({
        value: e.uniforms[o],
        location: t.getUniformLocation(this.renderTargetProgram_, o)
      });
    });
  }
  getRenderTargetTexture() {
    return this.renderTargetTexture_;
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   */
  init(e) {
    const t = this.getGL(), i = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.bindRenderbuffer(t.RENDERBUFFER, this.getDepthBuffer()), t.viewport(0, 0, i[0], i[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i[0] || this.renderTargetTextureSize_[1] !== i[1]) {
      this.renderTargetTextureSize_ = i;
      const r = 0, s = t.RGBA, o = 0, a = t.RGBA, l = t.UNSIGNED_BYTE, c = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        r,
        s,
        i[0],
        i[1],
        o,
        a,
        l,
        c
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      ), t.renderbufferStorage(
        t.RENDERBUFFER,
        t.DEPTH_COMPONENT16,
        i[0],
        i[1]
      ), t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        this.depthBuffer_
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  apply(e, t, i, r) {
    const s = this.getGL(), o = e.size;
    if (s.bindFramebuffer(
      s.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const l = q(s.canvas);
      if (!e.renderTargets[l]) {
        const c = s.getContextAttributes();
        c && c.preserveDrawingBuffer && (s.clearColor(0, 0, 0, 0), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT)), e.renderTargets[l] = !0;
      }
    }
    s.disable(s.DEPTH_TEST), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.viewport(0, 0, s.drawingBufferWidth, s.drawingBufferHeight), s.bindBuffer(s.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), s.useProgram(this.renderTargetProgram_), s.enableVertexAttribArray(this.renderTargetAttribLocation_), s.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      s.FLOAT,
      !1,
      0,
      0
    ), s.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), s.uniform1i(this.renderTargetTextureLocation_, 0);
    const a = e.layerStatesArray[e.layerIndex].opacity;
    s.uniform1f(this.renderTargetOpacityLocation_, a), this.applyUniforms(e), i && i(s, e), s.drawArrays(s.TRIANGLES, 0, 6), r && r(s, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer
   */
  getDepthBuffer() {
    return this.depthBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let i, r = 1;
    this.uniforms_.forEach(function(s) {
      if (i = typeof s.value == "function" ? s.value(e) : s.value, i instanceof HTMLCanvasElement || i instanceof ImageData)
        s.texture || (s.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${r}`]), t.bindTexture(t.TEXTURE_2D, s.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), i instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          i.width,
          i.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(i.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          i
        ), t.uniform1i(s.location, r++);
      else if (Array.isArray(i))
        switch (i.length) {
          case 2:
            t.uniform2f(s.location, i[0], i[1]);
            return;
          case 3:
            t.uniform3f(s.location, i[0], i[1], i[2]);
            return;
          case 4:
            t.uniform4f(
              s.location,
              i[0],
              i[1],
              i[2],
              i[3]
            );
            return;
          default:
            return;
        }
      else typeof i == "number" && t.uniform1f(s.location, i);
    });
  }
}
const zn = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  ROTATION: "u_rotation",
  VIEWPORT_SIZE_PX: "u_viewportSizePx",
  PIXEL_RATIO: "u_pixelRatio",
  HIT_DETECTION: "u_hitDetection"
}, yt = {
  UNSIGNED_BYTE: a1,
  UNSIGNED_SHORT: l1,
  UNSIGNED_INT: c1,
  FLOAT: vm
}, Sa = {};
function cf(n) {
  return "shared/" + n;
}
let hf = 0;
function g1() {
  const n = "unique/" + hf;
  return hf += 1, n;
}
function m1(n) {
  let e = Sa[n];
  if (!e) {
    const t = document.createElement("canvas");
    t.width = 1, t.height = 1, t.style.position = "absolute", t.style.left = "0", e = { users: 0, context: h1(t) }, Sa[n] = e;
  }
  return e.users += 1, e.context;
}
function _1(n) {
  const e = Sa[n];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.context, i = t.getExtension("WEBGL_lose_context");
  i && i.loseContext();
  const r = t.canvas;
  r.width = 1, r.height = 1, delete Sa[n];
}
class p1 extends so {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? cf(e.canvasCacheKey) : g1(), this.gl_ = m1(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = !1;
    const t = this.gl_.canvas;
    t.addEventListener(
      Xo.LOST,
      this.boundHandleWebGLContextLost_
    ), t.addEventListener(
      Xo.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = Ke(), this.offsetScaleMatrix_ = Ke(), this.tmpMat4_ = ym(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms), this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(
      (i) => new lf({
        webGlContext: this.gl_,
        scaleRatio: i.scaleRatio,
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        uniforms: i.uniforms
      })
    ) : [new lf({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now(), this.maxAttributeCount_ = this.gl_.getParameter(
      this.gl_.MAX_VERTEX_ATTRIBS
    );
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [], this.addUniforms(e);
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  addUniforms(e) {
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === cf(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.gl_, i = q(e);
    let r = this.bufferCache_[i];
    if (!r) {
      const s = t.createBuffer();
      r = {
        buffer: e,
        webGlBuffer: s
      }, this.bufferCache_[i] = r;
    }
    t.bindBuffer(e.getType(), r.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.gl_;
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = q(e);
    delete this.bufferCache_[t];
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    const e = this.gl_.canvas;
    e.removeEventListener(
      Xo.LOST,
      this.boundHandleWebGLContextLost_
    ), e.removeEventListener(
      Xo.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), _1(this.canvasCacheKey_), delete this.gl_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDraw(e, t, i) {
    const r = this.gl_, s = this.getCanvas(), o = e.size, a = e.pixelRatio;
    (s.width !== o[0] * a || s.height !== o[1] * a) && (s.width = o[0] * a, s.height = o[1] * a, s.style.width = o[0] + "px", s.style.height = o[1] + "px");
    for (let l = this.postProcessPasses_.length - 1; l >= 0; l--)
      this.postProcessPasses_[l].init(e);
    r.bindTexture(r.TEXTURE_2D, null), r.clearColor(0, 0, 0, 0), r.depthRange(0, 1), r.clearDepth(1), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.enable(r.BLEND), r.blendFunc(r.ONE, t ? r.ZERO : r.ONE_MINUS_SRC_ALPHA), i ? (r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL)) : r.disable(r.DEPTH_TEST);
  }
  /**
   * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.
   * @param {WebGLTexture} [texture] The texture.
   */
  bindFrameBuffer(e, t) {
    const i = this.getGL();
    i.bindFramebuffer(i.FRAMEBUFFER, e), t && i.framebufferTexture2D(
      i.FRAMEBUFFER,
      i.COLOR_ATTACHMENT0,
      i.TEXTURE_2D,
      t,
      0
    );
  }
  /**
   * Bind the frame buffer from the initial render.
   */
  bindInitialFrameBuffer() {
    const e = this.getGL(), t = this.postProcessPasses_[0].getFrameBuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, t);
    const i = this.postProcessPasses_[0].getRenderTargetTexture();
    e.framebufferTexture2D(
      e.FRAMEBUFFER,
      e.COLOR_ATTACHMENT0,
      e.TEXTURE_2D,
      i,
      0
    );
  }
  /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */
  bindTexture(e, t, i) {
    const r = this.gl_;
    r.activeTexture(r.TEXTURE0 + t), r.bindTexture(r.TEXTURE_2D, e), r.uniform1i(this.getUniformLocation(i), t);
  }
  /**
   * Set up an attribute array buffer for use in the vertex shader.
   * @param {import("./Buffer").default} buffer The buffer.
   * @param {string} attributeName The attribute name.
   * @param {number} size The number of components per attribute vertex.
   */
  bindAttribute(e, t, i) {
    const r = this.getGL();
    this.bindBuffer(e);
    const s = this.getAttributeLocation(t);
    r.enableVertexAttribArray(s), r.vertexAttribPointer(s, i, r.FLOAT, !1, 0, 0);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDrawToRenderTarget(e, t, i, r) {
    const s = this.gl_, o = t.getSize();
    s.bindFramebuffer(s.FRAMEBUFFER, t.getFramebuffer()), s.bindRenderbuffer(s.RENDERBUFFER, t.getDepthbuffer()), s.viewport(0, 0, o[0], o[1]), s.bindTexture(s.TEXTURE_2D, t.getTexture()), s.clearColor(0, 0, 0, 0), s.depthRange(0, 1), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.enable(s.BLEND), s.blendFunc(s.ONE, i ? s.ZERO : s.ONE_MINUS_SRC_ALPHA), r ? (s.enable(s.DEPTH_TEST), s.depthFunc(s.LEQUAL)) : s.disable(s.DEPTH_TEST);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const i = this.gl_;
    this.getExtension("OES_element_index_uint");
    const r = i.UNSIGNED_INT, s = 4, o = t - e, a = e * s;
    i.drawElements(i.TRIANGLES, o, r, a);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, i) {
    for (let r = 0, s = this.postProcessPasses_.length; r < s; r++)
      r === s - 1 ? this.postProcessPasses_[r].apply(
        e,
        null,
        t,
        i
      ) : this.postProcessPasses_[r].apply(
        e,
        this.postProcessPasses_[r + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return (
      /** @type {HTMLCanvasElement} */
      this.gl_.canvas
    );
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, i = e.viewState.rotation, r = e.pixelRatio;
    this.setUniformFloatValue(
      zn.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(zn.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      zn.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(zn.PIXEL_RATIO, r), this.setUniformFloatVec2(zn.VIEWPORT_SIZE_PX, [
      t[0],
      t[1]
    ]), this.setUniformFloatValue(zn.ROTATION, i);
  }
  /**
   * Sets the `u_hitDetection` uniform.
   * @param {boolean} enabled Whether to enable the hit detection code path
   */
  applyHitDetectionUniform(e) {
    const t = this.getUniformLocation(zn.HIT_DETECTION);
    this.getGL().uniform1i(t, e ? 1 : 0), e && this.setUniformFloatValue(zn.PIXEL_RATIO, 0.5);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.gl_;
    let i, r = 0;
    this.uniforms_.forEach((s) => {
      if (i = typeof s.value == "function" ? s.value(e) : s.value, i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof ImageData || i instanceof WebGLTexture) {
        i instanceof WebGLTexture && !s.texture ? (s.prevValue = void 0, s.texture = i) : s.texture || (s.prevValue = void 0, s.texture = t.createTexture()), this.bindTexture(s.texture, r, s.name), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
        const o = !(i instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        i.complete;
        !(i instanceof WebGLTexture) && o && s.prevValue !== i && (s.prevValue = i, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          i
        )), r++;
      } else if (Array.isArray(i) && i.length === 6)
        this.setUniformMatrixValue(
          s.name,
          Zc(this.tmpMat4_, i)
        );
      else if (Array.isArray(i) && i.length <= 4)
        switch (i.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(s.name),
              i[0],
              i[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(s.name),
              i[0],
              i[1],
              i[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(s.name),
              i[0],
              i[1],
              i[2],
              i[3]
            );
            return;
          default:
            return;
        }
      else typeof i == "number" && t.uniform1f(this.getUniformLocation(s.name), i);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   */
  useProgram(e, t) {
    this.disableAllAttributes_(), this.gl_.useProgram(e), this.currentProgram_ = e, t && (this.applyFrameState(t), this.applyUniforms(t));
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const i = this.gl_, r = i.createShader(t);
    return i.shaderSource(r, e), i.compileShader(r), r;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const i = this.gl_, r = this.compileShader(
      e,
      i.FRAGMENT_SHADER
    ), s = this.compileShader(
      t,
      i.VERTEX_SHADER
    ), o = i.createProgram();
    if (i.attachShader(o, r), i.attachShader(o, s), i.linkProgram(o), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
      const a = `Fragment shader compilation failed: ${i.getShaderInfoLog(
        r
      )}`;
      throw new Error(a);
    }
    if (i.deleteShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) {
      const a = `Vertex shader compilation failed: ${i.getShaderInfoLog(
        s
      )}`;
      throw new Error(a);
    }
    if (i.deleteShader(s), !i.getProgramParameter(o, i.LINK_STATUS)) {
      const a = `GL program linking failed: ${i.getProgramInfoLog(
        o
      )}`;
      throw new Error(a);
    }
    return o;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    const t = q(this.currentProgram_);
    return this.uniformLocationsByProgram_[t] === void 0 && (this.uniformLocationsByProgram_[t] = {}), this.uniformLocationsByProgram_[t][e] === void 0 && (this.uniformLocationsByProgram_[t][e] = this.gl_.getUniformLocation(this.currentProgram_, e)), this.uniformLocationsByProgram_[t][e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    const t = q(this.currentProgram_);
    return this.attribLocationsByProgram_[t] === void 0 && (this.attribLocationsByProgram_[t] = {}), this.attribLocationsByProgram_[t][e] === void 0 && (this.attribLocationsByProgram_[t][e] = this.gl_.getAttribLocation(this.currentProgram_, e)), this.attribLocationsByProgram_[t][e];
  }
  /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const i = e.size, r = e.viewState.rotation, s = e.viewState.resolution, o = e.viewState.center;
    return sn(
      t,
      0,
      0,
      2 / (s * i[0]),
      2 / (s * i[1]),
      -r,
      -o[0],
      -o[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.gl_.uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.gl_.uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.gl_.uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.gl_.uniformMatrix4fv(this.getUniformLocation(e), !1, t);
  }
  /**
   * Disable all vertex attributes.
   * @private
   */
  disableAllAttributes_() {
    for (let e = 0; e < this.maxAttributeCount_; e++)
      this.gl_.disableVertexAttribArray(e);
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(e, t, i, r, s) {
    const o = this.getAttributeLocation(e);
    o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, t, i, !1, r, s));
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    const t = y1(e);
    let i = 0;
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      this.enableAttributeArray_(
        s.name,
        s.size,
        s.type || vm,
        t,
        i
      ), i += s.size * Em(s.type);
    }
  }
  /**
   * WebGL context was lost
   * @param {WebGLContextEvent} event The context loss event.
   * @private
   */
  handleWebGLContextLost(e) {
    Qr(this.bufferCache_), this.currentProgram_ = null, e.preventDefault();
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    this.needsToBeRecreated_ = !0;
  }
  /**
   * Returns whether this helper needs to be recreated, as the context was lost and then restored.
   * @return {boolean} Whether this helper needs to be recreated.
   */
  needsToBeRecreated() {
    return this.needsToBeRecreated_;
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, i, r) {
    const s = this.gl_;
    i = i || s.createTexture();
    const o = r ? s.NEAREST : s.LINEAR;
    s.bindTexture(s.TEXTURE_2D, i), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
    const a = 0, l = s.RGBA, c = 0, h = s.RGBA, u = s.UNSIGNED_BYTE;
    return t instanceof Uint8Array ? s.texImage2D(
      s.TEXTURE_2D,
      a,
      l,
      e[0],
      e[1],
      c,
      h,
      u,
      t
    ) : t ? s.texImage2D(s.TEXTURE_2D, a, l, h, u, t) : s.texImage2D(
      s.TEXTURE_2D,
      a,
      l,
      e[0],
      e[1],
      c,
      h,
      u,
      null
    ), i;
  }
}
function y1(n) {
  let e = 0;
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    e += i.size * Em(i.type);
  }
  return e;
}
function Em(n) {
  switch (n) {
    case yt.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case yt.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case yt.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case yt.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class hu extends Xg {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = Ke(), this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, this.onMapChanged_ = () => {
      this.clearCache(), this.removeHelper();
    }, e.addChangeListener(ve.MAP, this.onMapChanged_), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const i = this.getLayer();
    if (i.hasListener(et.PRECOMPOSE)) {
      const r = new Os(
        et.PRECOMPOSE,
        void 0,
        t,
        e
      );
      i.dispatchEvent(r);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const i = this.getLayer();
    if (i.hasListener(et.POSTCOMPOSE)) {
      const r = new Os(
        et.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      i.dispatchEvent(r);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, i = -1, r;
      for (let o = 0, a = e.layerStatesArray.length; o < a; o++) {
        const l = e.layerStatesArray[o].layer, c = l.getRenderer();
        if (!(c instanceof hu)) {
          t = !0;
          continue;
        }
        const h = l.getClassName();
        if ((t || h !== r) && (i += 1, t = !1), r = h, c === this)
          break;
      }
      const s = "map/" + e.mapId + "/group/" + i;
      (!this.helper || !this.helper.canvasCacheKeyMatches(s) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new p1({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: s
      }), r && (this.helper.getCanvas().className = r), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * @protected
   */
  clearCache() {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    var e;
    this.clearCache(), this.removeHelper(), (e = this.getLayer()) == null || e.removeChangeListener(
      ve.MAP,
      this.onMapChanged_
    ), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, i) {
    const r = this.getLayer();
    if (r.hasListener(e)) {
      sn(
        this.inversePixelTransform_,
        0,
        0,
        i.pixelRatio,
        -i.pixelRatio,
        0,
        0,
        -i.size[1]
      );
      const s = new Os(
        e,
        this.inversePixelTransform_,
        i,
        t
      );
      r.dispatchEvent(s);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(et.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(et.POSTRENDER, e, t);
  }
}
const oc = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight"
};
class x1 {
  /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */
  constructor(e, t) {
    this.name = e, this.data = t, this.texture_ = null;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */
  getTexture(e) {
    if (!this.texture_) {
      const t = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, t), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texImage2D(
        e.TEXTURE_2D,
        0,
        e.RGBA,
        this.data.length / 4,
        1,
        0,
        e.RGBA,
        e.UNSIGNED_BYTE,
        this.data
      ), this.texture_ = t;
    }
    return this.texture_;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   */
  delete(e) {
    this.texture_ && e.deleteTexture(this.texture_), this.texture_ = null;
  }
}
function v1(n, e) {
  return `operator_${n}_${Object.keys(e.functions).length}`;
}
function Si(n) {
  const e = n.toString();
  return e.includes(".") ? e : e + ".0";
}
function uu(n) {
  if (n.length < 2 || n.length > 4)
    throw new Error(
      "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
    );
  return `vec${n.length}(${n.map(Si).join(", ")})`;
}
function ea(n) {
  const e = an(n), t = e.length > 3 ? e[3] : 1;
  return uu([e[0] / 255, e[1] / 255, e[2] / 255, t]);
}
function E1(n) {
  const e = Tt(n);
  return uu(e);
}
const ac = {};
let T1 = 0;
function qs(n) {
  return n in ac || (ac[n] = T1++), ac[n];
}
function jn(n) {
  return Si(qs(n));
}
function du(n) {
  return "u_var_" + n;
}
function Tm() {
  return {
    variables: {},
    properties: {},
    functions: {},
    bandCount: 0,
    featureId: !1,
    geometryType: !1
  };
}
const lc = "getBandValue", w1 = "u_paletteTextures", wm = "featureId", Sm = "geometryType", Jc = -9999999;
function S1(n, e, t, i) {
  const r = tt(n, e, t);
  return fu(r, e, i);
}
function _e(n) {
  return (e, t, i) => {
    const r = t.args.length, s = new Array(r);
    for (let o = 0; o < r; ++o)
      s[o] = fu(t.args[o], i, e);
    return n(s, e);
  };
}
const b1 = {
  [R.Get]: (n, e) => {
    const i = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    return i in n.properties || (n.properties[i] = {
      name: i,
      type: e.type
    }), "a_prop_" + i;
  },
  [R.Id]: (n) => (n.featureId = !0, "a_" + wm),
  [R.GeometryType]: (n) => (n.geometryType = !0, "a_" + Sm),
  [R.LineMetric]: () => "currentLineMetric",
  // this variable is assumed to always be present in shaders, default is 0.
  [R.Var]: (n, e) => {
    const i = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    return i in n.variables || (n.variables[i] = {
      name: i,
      type: e.type
    }), du(i);
  },
  [R.Has]: (n, e) => {
    const i = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    return i in n.properties || (n.properties[i] = {
      name: i,
      type: e.type
    }), `(a_prop_${i} != ${Si(Jc)})`;
  },
  [R.Resolution]: () => "u_resolution",
  [R.Zoom]: () => "u_zoom",
  [R.Time]: () => "u_time",
  [R.Any]: _e((n) => `(${n.join(" || ")})`),
  [R.All]: _e((n) => `(${n.join(" && ")})`),
  [R.Not]: _e(([n]) => `(!${n})`),
  [R.Equal]: _e(
    ([n, e]) => `(${n} == ${e})`
  ),
  [R.NotEqual]: _e(
    ([n, e]) => `(${n} != ${e})`
  ),
  [R.GreaterThan]: _e(
    ([n, e]) => `(${n} > ${e})`
  ),
  [R.GreaterThanOrEqualTo]: _e(
    ([n, e]) => `(${n} >= ${e})`
  ),
  [R.LessThan]: _e(
    ([n, e]) => `(${n} < ${e})`
  ),
  [R.LessThanOrEqualTo]: _e(
    ([n, e]) => `(${n} <= ${e})`
  ),
  [R.Multiply]: _e(
    (n) => `(${n.join(" * ")})`
  ),
  [R.Divide]: _e(
    ([n, e]) => `(${n} / ${e})`
  ),
  [R.Add]: _e((n) => `(${n.join(" + ")})`),
  [R.Subtract]: _e(
    ([n, e]) => `(${n} - ${e})`
  ),
  [R.Clamp]: _e(
    ([n, e, t]) => `clamp(${n}, ${e}, ${t})`
  ),
  [R.Mod]: _e(([n, e]) => `mod(${n}, ${e})`),
  [R.Pow]: _e(([n, e]) => `pow(${n}, ${e})`),
  [R.Abs]: _e(([n]) => `abs(${n})`),
  [R.Floor]: _e(([n]) => `floor(${n})`),
  [R.Ceil]: _e(([n]) => `ceil(${n})`),
  [R.Round]: _e(([n]) => `floor(${n} + 0.5)`),
  [R.Sin]: _e(([n]) => `sin(${n})`),
  [R.Cos]: _e(([n]) => `cos(${n})`),
  [R.Atan]: _e(([n, e]) => e !== void 0 ? `atan(${n}, ${e})` : `atan(${n})`),
  [R.Sqrt]: _e(([n]) => `sqrt(${n})`),
  [R.Match]: _e((n) => {
    const e = n[0], t = n[n.length - 1];
    let i = null;
    for (let r = n.length - 3; r >= 1; r -= 2) {
      const s = n[r], o = n[r + 1];
      i = `(${e} == ${s} ? ${o} : ${i || t})`;
    }
    return i;
  }),
  [R.Between]: _e(
    ([n, e, t]) => `(${n} >= ${e} && ${n} <= ${t})`
  ),
  [R.Interpolate]: _e(([n, e, ...t]) => {
    let i = "";
    for (let r = 0; r < t.length - 2; r += 2) {
      const s = t[r], o = i || t[r + 1], a = t[r + 2], l = t[r + 3];
      let c;
      n === Si(1) ? c = `(${e} - ${s}) / (${a} - ${s})` : c = `(pow(${n}, (${e} - ${s})) - 1.0) / (pow(${n}, (${a} - ${s})) - 1.0)`, i = `mix(${o}, ${l}, clamp(${c}, 0.0, 1.0))`;
    }
    return i;
  }),
  [R.Case]: _e((n) => {
    const e = n[n.length - 1];
    let t = null;
    for (let i = n.length - 3; i >= 0; i -= 2) {
      const r = n[i], s = n[i + 1];
      t = `(${r} ? ${s} : ${t || e})`;
    }
    return t;
  }),
  [R.In]: _e(([n, ...e], t) => {
    const i = v1("in", t), r = [];
    for (let s = 0; s < e.length; s += 1)
      r.push(`  if (inputValue == ${e[s]}) { return true; }`);
    return t.functions[i] = `bool ${i}(float inputValue) {
${r.join(`
`)}
  return false;
}`, `${i}(${n})`;
  }),
  [R.Array]: _e(
    (n) => `vec${n.length}(${n.join(", ")})`
  ),
  [R.Color]: _e((n) => {
    if (n.length === 1)
      return `vec4(vec3(${n[0]} / 255.0), 1.0)`;
    if (n.length === 2)
      return `vec4(vec3(${n[0]} / 255.0), ${n[1]})`;
    const e = n.slice(0, 3).map((i) => `${i} / 255.0`);
    if (n.length === 3)
      return `vec4(${e.join(", ")}, 1.0)`;
    const t = n[3];
    return `vec4(${e.join(", ")}, ${t})`;
  }),
  [R.Band]: _e(([n, e, t], i) => {
    if (!(lc in i.functions)) {
      let r = "";
      const s = i.bandCount || 1;
      for (let o = 0; o < s; o++) {
        const a = Math.floor(o / 4);
        let l = o % 4;
        o === s - 1 && l === 1 && (l = 3);
        const c = `${oc.TILE_TEXTURE_ARRAY}[${a}]`;
        r += `  if (band == ${o + 1}.0) {
    return texture2D(${c}, v_textureCoord + vec2(dx, dy))[${l}];
  }
`;
      }
      i.functions[lc] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${oc.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${oc.TEXTURE_PIXEL_HEIGHT};
${r}
}`;
    }
    return `${lc}(${n}, ${e ?? "0.0"}, ${t ?? "0.0"})`;
  }),
  [R.Palette]: (n, e) => {
    const [t, ...i] = e.args, r = i.length, s = new Uint8Array(r * 4);
    for (let c = 0; c < i.length; c++) {
      const h = (
        /** @type {string | Array<number>} */
        /** @type {LiteralExpression} */
        i[c].value
      ), u = an(h), d = c * 4;
      s[d] = u[0], s[d + 1] = u[1], s[d + 2] = u[2], s[d + 3] = u[3] * 255;
    }
    n.paletteTextures || (n.paletteTextures = []);
    const o = `${w1}[${n.paletteTextures.length}]`, a = new x1(o, s);
    n.paletteTextures.push(a);
    const l = fu(t, Y, n);
    return `texture2D(${o}, vec2((${l} + 0.5) / ${r}.0, 0.5))`;
  }
  // TODO: unimplemented
  // Ops.Number
  // Ops.String
  // Ops.Coalesce
  // Ops.Concat
  // Ops.ToString
};
function fu(n, e, t) {
  if (n instanceof Kg) {
    const i = b1[n.operator];
    if (i === void 0)
      throw new Error(
        `No compiler defined for this operator: ${JSON.stringify(
          n.operator
        )}`
      );
    return i(t, n, e);
  }
  if ((n.type & Y) > 0)
    return Si(
      /** @type {number} */
      n.value
    );
  if ((n.type & Xe) > 0)
    return n.value.toString();
  if ((n.type & He) > 0)
    return jn(n.value.toString());
  if ((n.type & Me) > 0)
    return ea(
      /** @type {Array<number> | string} */
      n.value
    );
  if ((n.type & Dt) > 0)
    return uu(
      /** @type {Array<number>} */
      n.value
    );
  if ((n.type & jt) > 0)
    return E1(
      /** @type {number|import('../size.js').Size} */
      n.value
    );
  throw new Error(
    `Unexpected expression ${n.value} (expected type ${Fr(
      e
    )})`
  );
}
function R1() {
  return {
    "fill-color": "rgba(255,255,255,0.4)",
    "stroke-color": "#3399CC",
    "stroke-width": 1.25,
    "circle-radius": 5,
    "circle-fill-color": "rgba(255,255,255,0.4)",
    "circle-stroke-width": 1.25,
    "circle-stroke-color": "#3399CC"
  };
}
const uf = 0.985, Sr = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.; // an actual value will be used in the stroke shaders
`, br = R1();
class bm {
  constructor() {
    this.uniforms_ = [], this.attributes_ = [], this.hasSymbol_ = !1, this.symbolSizeExpression_ = `vec2(${Si(
      br["circle-radius"]
    )} + ${Si(br["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = ea(
      /** @type {string} */
      br["circle-fill-color"]
    ), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = !1, this.hasStroke_ = !1, this.strokeWidthExpression_ = Si(br["stroke-width"]), this.strokeColorExpression_ = ea(
      /** @type {string} */
      br["stroke-color"]
    ), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = jn("round"), this.strokeJoinExpression_ = jn("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = !1, this.fillColorExpression_ = ea(
      /** @type {string} */
      br["fill-color"]
    ), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name, including the `u_` prefix
   * @param {'float'|'vec2'|'vec3'|'vec4'|'sampler2D'} type GLSL type
   * @return {ShaderBuilder} the builder object
   */
  addUniform(e, t) {
    return this.uniforms_.push({
      name: e,
      type: t
    }), this;
  }
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * Attributes will also be made available under the same name in fragment shaders.
   * @param {string} name Attribute name, including the `a_` prefix
   * @param {'float'|'vec2'|'vec3'|'vec4'} type GLSL type
   * @param {string} [varyingExpression] Expression which will be assigned to the varying in the vertex shader, and
   * passed on to the fragment shader.
   * @param {'float'|'vec2'|'vec3'|'vec4'} [varyingType] Type of the attribute after transformation;
   * e.g. `vec4` after unpacking color components
   * @return {ShaderBuilder} the builder object
   */
  addAttribute(e, t, i, r) {
    return this.attributes_.push({
      name: e,
      type: t,
      varyingName: e.replace(/^a_/, "v_"),
      varyingType: r ?? t,
      varyingExpression: i ?? e
    }), this;
  }
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolSizeExpression(e) {
    return this.hasSymbol_ = !0, this.symbolSizeExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol size expression
   */
  getSymbolSizeExpression() {
    return this.symbolSizeExpression_;
  }
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotationExpression(e) {
    return this.symbolRotationExpression_ = e, this;
  }
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolOffsetExpression(e) {
    return this.symbolOffsetExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol offset expression
   */
  getSymbolOffsetExpression() {
    return this.symbolOffsetExpression_;
  }
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolColorExpression(e) {
    return this.hasSymbol_ = !0, this.symbolColorExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol color expression
   */
  getSymbolColorExpression() {
    return this.symbolColorExpression_;
  }
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */
  setTextureCoordinateExpression(e) {
    return this.texCoordExpression_ = e, this;
  }
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */
  setFragmentDiscardExpression(e) {
    return this.discardExpression_ = e, this;
  }
  /**
   * @return {string} The current fragment discard expression
   */
  getFragmentDiscardExpression() {
    return this.discardExpression_;
  }
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotateWithView(e) {
    return this.symbolRotateWithView_ = e, this;
  }
  /**
   * @param {string} expression Stroke width expression, returning value in pixels
   * @return {ShaderBuilder} the builder object
   */
  setStrokeWidthExpression(e) {
    return this.hasStroke_ = !0, this.strokeWidthExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeColorExpression(e) {
    return this.hasStroke_ = !0, this.strokeColorExpression_ = e, this;
  }
  /**
   * @return {string} The current stroke color expression
   */
  getStrokeColorExpression() {
    return this.strokeColorExpression_;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeOffsetExpression(e) {
    return this.strokeOffsetExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line cap expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeCapExpression(e) {
    return this.strokeCapExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line join expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeJoinExpression(e) {
    return this.strokeJoinExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke miter limit expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeMiterLimitExpression(e) {
    return this.strokeMiterLimitExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke distance field expression, evaluate to `float`
   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeDistanceFieldExpression(e) {
    return this.strokeDistanceFieldExpression_ = e, this;
  }
  /**
   * @param {string} expression Fill color expression, evaluate to `vec4`
   * @return {ShaderBuilder} the builder object
   */
  setFillColorExpression(e) {
    return this.hasFill_ = !0, this.fillColorExpression_ = e, this;
  }
  /**
   * @return {string} The current fill color expression
   */
  getFillColorExpression() {
    return this.fillColorExpression_;
  }
  addVertexShaderFunction(e) {
    return this.vertexShaderFunctions_.includes(e) ? this : (this.vertexShaderFunctions_.push(e), this);
  }
  addFragmentShaderFunction(e) {
    return this.fragmentShaderFunctions_.includes(e) ? this : (this.fragmentShaderFunctions_.push(e), this);
  }
  /**
   * Generates a symbol vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolVertexShader() {
    return this.hasSymbol_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_hitColor;

varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_}${this.symbolRotateWithView_ ? " + u_rotation" : ""};
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_hitColor = a_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y);
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a symbol fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolFragmentShader() {
    return this.hasSymbol_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
  /**
   * Generates a stroke vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeVertexShader() {
    return this.hasStroke_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_hitColor;

varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  currentLineMetric = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);

  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${uf} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_hitColor = a_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
  v_measureStart = a_measureStart;
  v_measureEnd = a_measureEnd;
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a stroke fragment shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeFragmentShader() {
    return this.hasStroke_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${uf}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${jn("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${jn("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${jn("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${jn("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

float distanceFromSegment(vec2 point, vec2 start, vec2 end) {
  vec2 tangent = end - start;
  vec2 startToPoint = point - start;
  // inspire by capsule fn in https://iquilezles.org/articles/distfunctions/
  float h = clamp(dot(startToPoint, tangent) / dot(tangent, tangent), 0.0, 1.0);
  return length(startToPoint - tangent * h);
}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}

  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));
  float currentLengthPx = lengthToPoint + v_distanceOffsetPx;
  float currentRadiusPx = distanceFromSegment(currentPoint, v_segmentStart, v_segmentEnd);
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  currentLineMetric = mix(
    v_measureStart,
    v_measureEnd,
    lengthToPoint / max(segmentLength, 1.17549429e-38)
  );

  if (${this.discardExpression_}) { discard; }

  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distanceField = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distanceField = max(distanceField, ${this.strokeDistanceFieldExpression_});

  vec4 color = ${this.strokeColorExpression_};
  color.a *= smoothstep(0.5, -0.5, distanceField);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
  /**
   * Generates a fill vertex shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillVertexShader() {
    return this.hasFill_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_hitColor;

varying vec4 v_hitColor;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_hitColor = a_hitColor;
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a fill fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillFragmentShader() {
    return this.hasFill_ ? `${Sr}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec4 v_hitColor;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_};
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
}
function ne(n, e, t) {
  const i = nl();
  return S1(
    e,
    t,
    i,
    n
  );
}
function C1(n) {
  const e = an(n), t = e[0] * 256, i = e[1], r = e[2] * 256, s = Math.round(e[3] * 255);
  return [t + i, r + s];
}
const P1 = `vec4 unpackColor(vec2 packedColor) {
  return vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    fract(packedColor[1] / 256.0)
  );
}`;
function gu(n) {
  return n === Me || n === jt ? 2 : n === Dt ? 4 : 1;
}
function Qc(n) {
  const e = gu(n);
  return e > 1 ? (
    /** @type {'vec2'|'vec3'|'vec4'} */
    `vec${e}`
  ) : "float";
}
function Rm(n, e) {
  for (const t in e.variables) {
    const i = e.variables[t], r = du(i.name);
    let s = Qc(i.type);
    i.type === Me && (s = "vec4"), n.addUniform(r, s);
  }
  for (const t in e.properties) {
    const i = e.properties[t], r = Qc(i.type), s = `a_prop_${i.name}`;
    i.type === Me ? (n.addAttribute(
      s,
      r,
      `unpackColor(${s})`,
      "vec4"
    ), n.addVertexShaderFunction(P1)) : n.addAttribute(s, r);
  }
  for (const t in e.functions)
    n.addVertexShaderFunction(e.functions[t]), n.addFragmentShaderFunction(e.functions[t]);
}
function Cm(n, e) {
  const t = {};
  for (const i in n.variables) {
    const r = n.variables[i], s = du(r.name);
    t[s] = () => {
      const o = e[r.name];
      if (typeof o == "number")
        return o;
      if (typeof o == "boolean")
        return o ? 1 : 0;
      if (r.type === Me) {
        const a = [...an(o || "#eee")];
        return a[0] /= 255, a[1] /= 255, a[2] /= 255, a[3] ?? (a[3] = 1), a;
      }
      return typeof o == "string" ? qs(o) : o;
    };
  }
  return t;
}
function Pm(n) {
  const e = {};
  for (const t in n.properties) {
    const i = n.properties[t], r = (s) => {
      const o = s.get(i.name);
      return i.type === Me ? C1([...an(o || "#eee")]) : typeof o == "string" ? qs(o) : typeof o == "boolean" ? o ? 1 : 0 : o;
    };
    e[`prop_${i.name}`] = {
      size: gu(i.type),
      callback: r
    };
  }
  return e;
}
class ba {
  constructor() {
    this.globalCounter_ = 0, this.refToFeature_ = /* @__PURE__ */ new Map(), this.uidToRef_ = /* @__PURE__ */ new Map(), this.freeGlobalRef_ = [], this.polygonBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0,
      ringsCount: 0
    }, this.pointBatch = {
      entries: {},
      geometriesCount: 0
    }, this.lineStringBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0
    };
  }
  /**
   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeatures(e, t) {
    for (let i = 0; i < e.length; i++)
      this.addFeature(e[i], t);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeature(e, t) {
    let i = e.getGeometry();
    i && (t && (i = i.clone(), i.applyTransform(t)), this.addGeometry_(i, e));
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPointBatch_(e) {
    const t = q(e), i = this.pointBatch.entries[t];
    if (i)
      return this.pointBatch.geometriesCount -= i.flatCoordss.length, delete this.pointBatch.entries[t], i;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInLineStringBatch_(e) {
    const t = q(e), i = this.lineStringBatch.entries[t];
    if (i)
      return this.lineStringBatch.verticesCount -= i.verticesCount, this.lineStringBatch.geometriesCount -= i.flatCoordss.length, delete this.lineStringBatch.entries[t], i;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPolygonBatch_(e) {
    const t = q(e), i = this.polygonBatch.entries[t];
    if (i)
      return this.polygonBatch.verticesCount -= i.verticesCount, this.polygonBatch.ringsCount -= i.ringsCount, this.polygonBatch.geometriesCount -= i.flatCoordss.length, delete this.polygonBatch.entries[t], i;
  }
  /**
   * @param {import("../../geom.js").Geometry|RenderFeature} geometry Geometry
   * @param {Feature|RenderFeature} feature Feature
   * @private
   */
  addGeometry_(e, t) {
    var r;
    const i = e.getType();
    switch (i) {
      case "GeometryCollection": {
        const s = (
          /** @type {import("../../geom.js").GeometryCollection} */
          e.getGeometriesArray()
        );
        for (const o of s)
          this.addGeometry_(o, t);
        break;
      }
      case "MultiPolygon": {
        const s = (
          /** @type {import("../../geom.js").MultiPolygon} */
          e
        );
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          s.getEndss(),
          t,
          q(t),
          s.getStride()
        );
        break;
      }
      case "MultiLineString": {
        const s = (
          /** @type {import("../../geom.js").MultiLineString|RenderFeature} */
          e
        );
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          s.getEnds(),
          t,
          q(t),
          s.getStride()
        );
        break;
      }
      case "MultiPoint": {
        const s = (
          /** @type {import("../../geom.js").MultiPoint|RenderFeature} */
          e
        );
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          null,
          t,
          q(t),
          s.getStride()
        );
        break;
      }
      case "Polygon": {
        const s = (
          /** @type {import("../../geom.js").Polygon|RenderFeature} */
          e
        );
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          s.getEnds(),
          t,
          q(t),
          s.getStride()
        );
        break;
      }
      case "Point": {
        const s = (
          /** @type {import("../../geom.js").Point} */
          e
        );
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          null,
          t,
          q(t),
          s.getStride()
        );
        break;
      }
      case "LineString":
      case "LinearRing": {
        const s = (
          /** @type {import("../../geom.js").LineString} */
          e
        ), o = s.getStride();
        this.addCoordinates_(
          i,
          s.getFlatCoordinates(),
          null,
          t,
          q(t),
          o,
          (r = s.getLayout) == null ? void 0 : r.call(s)
        );
        break;
      }
    }
  }
  /**
   * @param {GeometryType} type Geometry type
   * @param {Array<number>} flatCoords Flat coordinates
   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends
   * @param {Feature|RenderFeature} feature Feature
   * @param {string} featureUid Feature uid
   * @param {number} stride Stride
   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout
   * @private
   */
  addCoordinates_(e, t, i, r, s, o, a) {
    let l;
    switch (e) {
      case "MultiPolygon": {
        const c = (
          /** @type {Array<Array<number>>} */
          i
        );
        for (let h = 0, u = c.length; h < u; h++) {
          let d = c[h];
          const f = h > 0 ? c[h - 1] : null, g = f ? f[f.length - 1] : 0, _ = d[d.length - 1];
          d = g > 0 ? d.map((m) => m - g) : d, this.addCoordinates_(
            "Polygon",
            t.slice(g, _),
            d,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "MultiLineString": {
        const c = (
          /** @type {Array<number>} */
          i
        );
        for (let h = 0, u = c.length; h < u; h++) {
          const d = h > 0 ? c[h - 1] : 0;
          this.addCoordinates_(
            "LineString",
            t.slice(d, c[h]),
            null,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "MultiPoint":
        for (let c = 0, h = t.length; c < h; c += o)
          this.addCoordinates_(
            "Point",
            t.slice(c, c + 2),
            null,
            r,
            s,
            null,
            null
          );
        break;
      case "Polygon": {
        const c = (
          /** @type {Array<number>} */
          i
        );
        if (r instanceof At) {
          const d = bg(t, c);
          if (d.length > 1) {
            this.addCoordinates_(
              "MultiPolygon",
              t,
              d,
              r,
              s,
              o,
              a
            );
            return;
          }
        }
        this.polygonBatch.entries[s] || (this.polygonBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: [],
            verticesCount: 0,
            ringsCount: 0,
            ringsVerticesCounts: []
          }
        )), l = t.length / o;
        const h = i.length, u = i.map(
          (d, f, g) => f > 0 ? (d - g[f - 1]) / o : d / o
        );
        this.polygonBatch.verticesCount += l, this.polygonBatch.ringsCount += h, this.polygonBatch.geometriesCount++, this.polygonBatch.entries[s].flatCoordss.push(
          I1(t, o)
        ), this.polygonBatch.entries[s].ringsVerticesCounts.push(
          u
        ), this.polygonBatch.entries[s].verticesCount += l, this.polygonBatch.entries[s].ringsCount += h;
        for (let d = 0, f = c.length; d < f; d++) {
          const g = d > 0 ? c[d - 1] : 0;
          this.addCoordinates_(
            "LinearRing",
            t.slice(g, c[d]),
            null,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "Point":
        this.pointBatch.entries[s] || (this.pointBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: []
          }
        )), this.pointBatch.geometriesCount++, this.pointBatch.entries[s].flatCoordss.push(t);
        break;
      case "LineString":
      case "LinearRing":
        this.lineStringBatch.entries[s] || (this.lineStringBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: [],
            verticesCount: 0
          }
        )), l = t.length / o, this.lineStringBatch.verticesCount += l, this.lineStringBatch.geometriesCount++, this.lineStringBatch.entries[s].flatCoordss.push(
          A1(t, o, a)
        ), this.lineStringBatch.entries[s].verticesCount += l;
        break;
    }
  }
  /**
   * @param {string} featureUid Feature uid
   * @param {GeometryBatchItem} entry The entry to add
   * @return {GeometryBatchItem} the added entry
   * @private
   */
  addRefToEntry_(e, t) {
    const i = this.uidToRef_.get(e), r = i || this.freeGlobalRef_.pop() || ++this.globalCounter_;
    return t.ref = r, i || (this.refToFeature_.set(r, t.feature), this.uidToRef_.set(e, r)), t;
  }
  /**
   * Return a ref to the pool of available refs.
   * @param {number} ref the ref to return
   * @param {string} featureUid the feature uid
   * @private
   */
  removeRef_(e, t) {
    if (!e)
      throw new Error("This feature has no ref: " + t);
    this.refToFeature_.delete(e), this.uidToRef_.delete(t), this.freeGlobalRef_.push(e);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  changeFeature(e, t) {
    if (!this.uidToRef_.get(q(e)))
      return;
    this.removeFeature(e);
    let i = e.getGeometry();
    i && (t && (i = i.clone(), i.applyTransform(t)), this.addGeometry_(i, e));
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   */
  removeFeature(e) {
    let t = this.clearFeatureEntryInPointBatch_(e);
    t = this.clearFeatureEntryInPolygonBatch_(e) || t, t = this.clearFeatureEntryInLineStringBatch_(e) || t, t && this.removeRef_(t.ref, q(t.feature));
  }
  clear() {
    this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0, this.globalCounter_ = 0, this.freeGlobalRef_ = [], this.refToFeature_.clear(), this.uidToRef_.clear();
  }
  /**
   * Resolve the feature associated to a ref.
   * @param {number} ref Hit detected ref
   * @return {Feature|RenderFeature} feature
   */
  getFeatureFromRef(e) {
    return this.refToFeature_.get(e);
  }
  isEmpty() {
    return this.globalCounter_ === 0;
  }
  /**
   * Will return a new instance of this class that only contains the features
   * for which the provided callback returned true
   * @param {function((Feature|RenderFeature)): boolean} featureFilter Feature filter callback
   * @return {MixedGeometryBatch} Filtered geometry batch
   */
  filter(e) {
    const t = new ba();
    t.globalCounter_ = this.globalCounter_, t.uidToRef_ = this.uidToRef_, t.refToFeature_ = this.refToFeature_;
    let i = !0;
    for (const r of this.refToFeature_.values())
      e(r) && (t.addFeature(r), i = !1);
    return i ? new ba() : t;
  }
}
function I1(n, e) {
  return e === 2 ? n : n.filter((t, i) => i % e < 2);
}
function A1(n, e, t) {
  return e === 3 && t === "XYM" ? n : e === 4 ? n.filter((i, r) => r % e !== 2) : e === 3 ? n.map((i, r) => r % e !== 2 ? i : 0) : new Array(n.length * 1.5).fill(0).map((i, r) => r % 3 === 2 ? 0 : n[Math.round(r / 1.5)]);
}
function L1() {
  const n = 'function t(t,n,x=2){const o=n&&n.length,i=o?n[0]*x:t.length;let u=e(t,0,i,x,!0);const l=[];if(!u||u.next===u.prev)return l;let c,h,y;if(o&&(u=function(t,n,r,x){const o=[];for(let r=0,i=n.length;r<i;r++){const u=e(t,n[r]*x,r<i-1?n[r+1]*x:t.length,x,!1);u===u.next&&(u.steiner=!0),o.push(a(u))}o.sort(f);for(let t=0;t<o.length;t++)r=s(o[t],r);return r}(t,n,u,x)),t.length>80*x){c=1/0,h=1/0;let e=-1/0,n=-1/0;for(let r=x;r<i;r+=x){const x=t[r],o=t[r+1];x<c&&(c=x),o<h&&(h=o),x>e&&(e=x),o>n&&(n=o)}y=Math.max(e-c,n-h),y=0!==y?32767/y:0}return r(u,l,x,c,h,y,0),l}function e(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,i=n-r;o<n;o+=r)x+=(t[i]-t[o])*(t[o+1]+t[i+1]),i=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=w(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=w(x/r|0,t[x],t[x+1],o);return o&&g(o,o.next)&&(A(o),o=o.next),o}function n(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!g(r,r.next)&&0!==v(r.prev,r,r.next))r=r.next;else{if(A(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function r(t,e,f,s,l,a,h){if(!t)return;!h&&a&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=c(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let i=x,u=0;for(let t=0;t<n&&(u++,i=i.nextZ,i);t++);let f=n;for(;u>0||f>0&&i;)0!==u&&(0===f||!i||x.z<=i.z)?(r=x,x=x.nextZ,u--):(r=i,i=i.nextZ,f--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=i}o.nextZ=null,n*=2}while(e>1)}(x)}(t,s,l,a);let y=t;for(;t.prev!==t.next;){const c=t.prev,p=t.next;if(a?o(t,s,l,a):x(t))e.push(c.i,t.i,p.i),A(t),t=p.next,y=p.next;else if((t=p)===y){h?1===h?r(t=i(n(t),e),e,f,s,l,a,2):2===h&&u(t,e,f,s,l,a):r(n(t),e,f,s,l,a,1);break}}}function x(t){const e=t.prev,n=t,r=t.next;if(v(e,n,r)>=0)return!1;const x=e.x,o=n.x,i=r.x,u=e.y,f=n.y,s=r.y,l=Math.min(x,o,i),c=Math.min(u,f,s),a=Math.max(x,o,i),h=Math.max(u,f,s);let p=r.next;for(;p!==e;){if(p.x>=l&&p.x<=a&&p.y>=c&&p.y<=h&&y(x,u,o,f,i,s,p.x,p.y)&&v(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function o(t,e,n,r){const x=t.prev,o=t,i=t.next;if(v(x,o,i)>=0)return!1;const u=x.x,f=o.x,s=i.x,l=x.y,a=o.y,h=i.y,p=Math.min(u,f,s),g=Math.min(l,a,h),b=Math.max(u,f,s),M=Math.max(l,a,h),m=c(p,g,e,n,r),Z=c(b,M,e,n,r);let d=t.prevZ,w=t.nextZ;for(;d&&d.z>=m&&w&&w.z<=Z;){if(d.x>=p&&d.x<=b&&d.y>=g&&d.y<=M&&d!==x&&d!==i&&y(u,l,f,a,s,h,d.x,d.y)&&v(d.prev,d,d.next)>=0)return!1;if(d=d.prevZ,w.x>=p&&w.x<=b&&w.y>=g&&w.y<=M&&w!==x&&w!==i&&y(u,l,f,a,s,h,w.x,w.y)&&v(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;d&&d.z>=m;){if(d.x>=p&&d.x<=b&&d.y>=g&&d.y<=M&&d!==x&&d!==i&&y(u,l,f,a,s,h,d.x,d.y)&&v(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;w&&w.z<=Z;){if(w.x>=p&&w.x<=b&&w.y>=g&&w.y<=M&&w!==x&&w!==i&&y(u,l,f,a,s,h,w.x,w.y)&&v(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function i(t,e){let r=t;do{const n=r.prev,x=r.next.next;!g(n,x)&&b(n,r,r.next,x)&&Z(n,x)&&Z(x,n)&&(e.push(n.i,r.i,x.i),A(r),A(r.next),r=t=x),r=r.next}while(r!==t);return n(r)}function u(t,e,x,o,i,u){let f=t;do{let t=f.next.next;for(;t!==f.prev;){if(f.i!==t.i&&p(f,t)){let s=d(f,t);return f=n(f,f.next),s=n(s,s.next),r(f,e,x,o,i,u,0),void r(s,e,x,o,i,u,0)}t=t.next}f=f.next}while(f!==t)}function f(t,e){let n=t.x-e.x;if(0===n&&(n=t.y-e.y,0===n)){n=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)}return n}function s(t,e){const r=function(t,e){let n=e;const r=t.x,x=t.y;let o,i=-1/0;if(g(t,n))return n;do{if(g(t,n.next))return n.next;if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>i&&(i=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const u=o,f=o.x,s=o.y;let c=1/0;n=o;do{if(r>=n.x&&n.x>=f&&r!==n.x&&h(x<s?r:i,x,f,s,x<s?i:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);Z(n,t)&&(e<c||e===c&&(n.x>o.x||n.x===o.x&&l(o,n)))&&(o=n,c=e)}n=n.next}while(n!==u);return o}(t,e);if(!r)return e;const x=d(r,t);return n(x,x.next),n(r,r.next)}function l(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function c(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function a(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function h(t,e,n,r,x,o,i,u){return(x-i)*(e-u)>=(t-i)*(o-u)&&(t-i)*(r-u)>=(n-i)*(e-u)&&(n-i)*(o-u)>=(x-i)*(r-u)}function y(t,e,n,r,x,o,i,u){return!(t===i&&e===u)&&h(t,e,n,r,x,o,i,u)}function p(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&b(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(Z(t,e)&&Z(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||g(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function g(t,e){return t.x===e.x&&t.y===e.y}function b(t,e,n,r){const x=m(v(t,e,n)),o=m(v(t,e,r)),i=m(v(n,r,t)),u=m(v(n,r,e));return x!==o&&i!==u||(!(0!==x||!M(t,n,e))||(!(0!==o||!M(t,r,e))||(!(0!==i||!M(n,t,r))||!(0!==u||!M(n,e,r)))))}function M(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function m(t){return t>0?1:t<0?-1:0}function Z(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function d(t,e){const n=E(t.i,t.x,t.y),r=E(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function w(t,e,n,r){const x=E(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function A(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function E(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function I(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function z(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,"Transformation matrix cannot be inverted");const x=e[0],o=e[1],i=e[2],u=e[3],f=e[4],s=e[5];return t[0]=u/n,t[1]=-o/n,t[2]=-i/n,t[3]=x/n,t[4]=(i*s-u*f)/n,t[5]=-(x*s-o*f)/n,t}new Array(6);const F=[],P={vertexPosition:0,indexPosition:0};function B(t,e,n,r,x){t[e+0]=n,t[e+1]=r,t[e+2]=x}function N(t,e,n,r,x,o){const i=3+x,u=t[e+0],f=t[e+1],s=F;s.length=x;for(let n=0;n<s.length;n++)s[n]=t[e+2+n];let l=o?o.vertexPosition:0,c=o?o.indexPosition:0;const a=l/i;return B(n,l,u,f,0),s.length&&n.set(s,l+3),l+=i,B(n,l,u,f,1),s.length&&n.set(s,l+3),l+=i,B(n,l,u,f,2),s.length&&n.set(s,l+3),l+=i,B(n,l,u,f,3),s.length&&n.set(s,l+3),l+=i,r[c++]=a,r[c++]=a+1,r[c++]=a+3,r[c++]=a+1,r[c++]=a+2,r[c++]=a+3,P.vertexPosition=l,P.indexPosition=c,P}function R(t,e,n,r,x,o,i,u,f,s,l){const c=10+u.length,a=o.length/c,h=[t[e+0],t[e+1]],y=[t[n],t[n+1]],p=t[e+2],v=t[n+2],g=I(f,[...h]),b=I(f,[...y]);function M(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],i=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),u=[(n[0]-t[0])/i,(n[1]-t[1])/i],f=0===r||0===i?0:Math.acos((s=u[0]*x[0]+u[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;return u[0]*o[0]+u[1]*o[1]>0?f:2*Math.PI-f}let m=-1,Z=-1,d=l;const w=null!==x;if(null!==r){m=M(g,b,I(f,[...[t[r],t[r+1]]])),Math.cos(m)<=.985&&(d+=Math.tan((m-Math.PI)/2))}if(w){Z=M(b,g,I(f,[...[t[x],t[x+1]]])),Math.cos(Z)<=.985&&(d+=Math.tan((Math.PI-Z)/2))}function A(t,e){return 0===e?1e4*t:Math.sign(e)*(1e4*t+Math.abs(e))}return o.push(h[0],h[1],p,y[0],y[1],v,m,Z,s,A(0,l)),o.push(...u),o.push(h[0],h[1],p,y[0],y[1],v,m,Z,s,A(1,l)),o.push(...u),o.push(h[0],h[1],p,y[0],y[1],v,m,Z,s,A(2,l)),o.push(...u),o.push(h[0],h[1],p,y[0],y[1],v,m,Z,s,A(3,l)),o.push(...u),i.push(a,a+1,a+2,a+1,a+3,a+2),{length:s+Math.sqrt((b[0]-g[0])*(b[0]-g[0])+(b[1]-g[1])*(b[1]-g[1])),angle:d}}function S(e,n,r,x,o){const i=2+o;let u=n;const f=e.slice(u,u+o);u+=o;const s=e[u++];let l=0;const c=new Array(s-1);for(let t=0;t<s;t++)l+=e[u++],t<s-1&&(c[t]=l);const a=e.slice(u,u+2*l),h=t(a,c,2);for(let t=0;t<h.length;t++)x.push(h[t]+r.length/i);for(let t=0;t<a.length;t+=2)r.push(a[t],a[t+1],...f);return u+2*l}const T="GENERATE_POLYGON_BUFFERS",_="GENERATE_POINT_BUFFERS",O="GENERATE_LINE_STRING_BUFFERS",U=self;U.onmessage=t=>{const e=t.data;switch(e.type){case _:{const t=3,n=2,r=e.customAttributesSize,x=n+r,o=new Float32Array(e.renderInstructions),i=o.length/x,u=4*i*(r+t),f=new Uint32Array(6*i),s=new Float32Array(u);let l;for(let t=0;t<o.length;t+=x)l=N(o,t,s,f,r,l);const c=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:o.buffer},e);U.postMessage(c,[s.buffer,f.buffer,o.buffer]);break}case O:{const t=[],n=[],r=e.customAttributesSize,x=3,o=new Float32Array(e.renderInstructions);let i=0;const u=[1,0,0,1,0,0];let f,s;for(z(u,e.renderInstructionsTransform);i<o.length;){s=Array.from(o.slice(i,i+r)),i+=r,f=o[i++];const e=i,l=i+(f-1)*x,c=o[e]===o[l]&&o[e+1]===o[l+1];let a=0,h=0;for(let r=0;r<f-1;r++){let y=null;r>0?y=i+(r-1)*x:c&&(y=l-x);let p=null;r<f-2?p=i+(r+2)*x:c&&(p=e+x);const v=R(o,i+r*x,i+(r+1)*x,y,p,t,n,s,u,a,h);a=v.length,h=v.angle}i+=f*x}const l=Uint32Array.from(n),c=Float32Array.from(t),a=Object.assign({vertexBuffer:c.buffer,indexBuffer:l.buffer,renderInstructions:o.buffer},e);U.postMessage(a,[c.buffer,l.buffer,o.buffer]);break}case T:{const t=[],n=[],r=e.customAttributesSize,x=new Float32Array(e.renderInstructions);let o=0;for(;o<x.length;)o=S(x,o,t,n,r);const i=Uint32Array.from(n),u=Float32Array.from(t),f=Object.assign({vertexBuffer:u.buffer,indexBuffer:i.buffer,renderInstructions:x.buffer},e);U.postMessage(f,[u.buffer,i.buffer,x.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(n, "binary").toString("base64") : URL.createObjectURL(new Blob([n], { type: "application/javascript" })));
}
const cc = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
function O1(n, e) {
  e = e || [];
  const t = 256, i = t - 1;
  return e[0] = Math.floor(n / t / t / t) / i, e[1] = Math.floor(n / t / t) % t / i, e[2] = Math.floor(n / t) % t / i, e[3] = n % t / i, e;
}
function M1(n) {
  let e = 0;
  const t = 256, i = t - 1;
  return e += Math.round(n[0] * t * t * t * i), e += Math.round(n[1] * t * t * i), e += Math.round(n[2] * t * i), e += Math.round(n[3] * i), e;
}
function mu(n, e, t, i) {
  let r = 0;
  for (const s in e) {
    const o = e[s], a = o.callback.call(t, t.feature);
    let l = (a == null ? void 0 : a[0]) ?? a;
    l === Jc && console.warn('The "has" operator might return false positives.'), l === void 0 ? l = Jc : l === null && (l = 0), n[i + r++] = l, !(!o.size || o.size === 1) && (n[i + r++] = a[1], !(o.size < 3) && (n[i + r++] = a[2], !(o.size < 4) && (n[i + r++] = a[3])));
  }
  return r;
}
function cl(n) {
  return Object.keys(n).reduce(
    (e, t) => e + (n[t].size || 1),
    0
  );
}
function D1(n, e, t, i) {
  const r = (2 + cl(t)) * n.geometriesCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in n.entries) {
    const l = n.entries[a];
    for (let c = 0, h = l.flatCoordss.length; c < h; c++)
      s[0] = l.flatCoordss[c][0], s[1] = l.flatCoordss[c][1], Ue(i, s), e[o++] = s[0], e[o++] = s[1], o += mu(
        e,
        t,
        l,
        o
      );
  }
  return e;
}
function F1(n, e, t, i) {
  const r = 3 * n.verticesCount + (1 + cl(t)) * n.geometriesCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in n.entries) {
    const l = n.entries[a];
    for (let c = 0, h = l.flatCoordss.length; c < h; c++) {
      s.length = l.flatCoordss[c].length, Sn(
        l.flatCoordss[c],
        0,
        s.length,
        3,
        i,
        s,
        3
      ), o += mu(
        e,
        t,
        l,
        o
      ), e[o++] = s.length / 3;
      for (let u = 0, d = s.length; u < d; u += 3)
        e[o++] = s[u], e[o++] = s[u + 1], e[o++] = s[u + 2];
    }
  }
  return e;
}
function k1(n, e, t, i) {
  const r = 2 * n.verticesCount + (1 + cl(t)) * n.geometriesCount + n.ringsCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in n.entries) {
    const l = n.entries[a];
    for (let c = 0, h = l.flatCoordss.length; c < h; c++) {
      s.length = l.flatCoordss[c].length, Sn(
        l.flatCoordss[c],
        0,
        s.length,
        2,
        i,
        s
      ), o += mu(
        e,
        t,
        l,
        o
      ), e[o++] = l.ringsVerticesCounts[c].length;
      for (let u = 0, d = l.ringsVerticesCounts[c].length; u < d; u++)
        e[o++] = l.ringsVerticesCounts[c][u];
      for (let u = 0, d = s.length; u < d; u += 2)
        e[o++] = s[u], e[o++] = s[u + 1];
    }
  }
  return e;
}
function Ra(n) {
  return (JSON.stringify(n).split("").reduce((t, i) => (t << 5) - t + i.charCodeAt(0), 0) >>> 0).toString();
}
function _u(n, e, t, i) {
  if (`${i}radius` in n && i !== "icon-") {
    let r = ne(
      t,
      n[`${i}radius`],
      Y
    );
    if (`${i}radius2` in n) {
      const s = ne(
        t,
        n[`${i}radius2`],
        Y
      );
      r = `max(${r}, ${s})`;
    }
    `${i}stroke-width` in n && (r = `(${r} + ${ne(
      t,
      n[`${i}stroke-width`],
      Y
    )} * 0.5)`), e.setSymbolSizeExpression(`vec2(${r} * 2. + 0.5)`);
  }
  if (`${i}scale` in n) {
    const r = ne(
      t,
      n[`${i}scale`],
      jt
    );
    e.setSymbolSizeExpression(
      `${e.getSymbolSizeExpression()} * ${r}`
    );
  }
  `${i}displacement` in n && e.setSymbolOffsetExpression(
    ne(
      t,
      n[`${i}displacement`],
      Dt
    )
  ), `${i}rotation` in n && e.setSymbolRotationExpression(
    ne(t, n[`${i}rotation`], Y)
  ), `${i}rotate-with-view` in n && e.setSymbolRotateWithView(!!n[`${i}rotate-with-view`]);
}
function Im(n, e, t, i, r) {
  let s = "vec4(0.)";
  if (e !== null && (s = e), t !== null && i !== null) {
    const l = `smoothstep(-${i} + 0.63, -${i} - 0.58, ${n})`;
    s = `mix(${t}, ${s}, ${l})`;
  }
  const o = `(1.0 - smoothstep(-0.63, 0.58, ${n}))`;
  let a = `${s} * vec4(1.0, 1.0, 1.0, ${o})`;
  return r !== null && (a = `${a} * vec4(1.0, 1.0, 1.0, ${r})`), a;
}
function pu(n, e, t, i, r) {
  const s = new Image();
  s.crossOrigin = n[`${i}cross-origin`] === void 0 ? "anonymous" : n[`${i}cross-origin`], ge(
    typeof n[`${i}src`] == "string",
    `WebGL layers do not support expressions for the ${i}src style property`
  ), s.src = /** @type {string} */
  n[`${i}src`], t[`u_texture${r}_size`] = () => s.complete ? [s.width, s.height] : [0, 0], e.addUniform(`u_texture${r}_size`, "vec2");
  const o = `u_texture${r}_size`;
  return t[`u_texture${r}`] = s, e.addUniform(`u_texture${r}`, "sampler2D"), o;
}
function yu(n, e, t, i, r) {
  let s = ne(
    t,
    n[`${e}offset`],
    jt
  );
  if (`${e}offset-origin` in n)
    switch (n[`${e}offset-origin`]) {
      case "top-right":
        s = `vec2(${i}.x, 0.) + ${r} * vec2(-1., 0.) + ${s} * vec2(-1., 1.)`;
        break;
      case "bottom-left":
        s = `vec2(0., ${i}.y) + ${r} * vec2(0., -1.) + ${s} * vec2(1., -1.)`;
        break;
      case "bottom-right":
        s = `${i} - ${r} - ${s}`;
        break;
    }
  return s;
}
function N1(n, e, t, i) {
  i.functions.circleDistanceField = `float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`, _u(n, e, i, "circle-");
  let r = null;
  "circle-opacity" in n && (r = ne(i, n["circle-opacity"], Y));
  let s = "coordsPx";
  "circle-scale" in n && (s = `coordsPx / ${ne(i, n["circle-scale"], jt)}`);
  let o = null;
  "circle-fill-color" in n && (o = ne(
    i,
    n["circle-fill-color"],
    Me
  ));
  let a = null;
  "circle-stroke-color" in n && (a = ne(
    i,
    n["circle-stroke-color"],
    Me
  ));
  let l = ne(i, n["circle-radius"], Y), c = null;
  "circle-stroke-width" in n && (c = ne(
    i,
    n["circle-stroke-width"],
    Y
  ), l = `(${l} + ${c} * 0.5)`);
  const h = `circleDistanceField(${s}, ${l})`, u = Im(
    h,
    o,
    a,
    c,
    r
  );
  e.setSymbolColorExpression(u);
}
function G1(n, e, t, i) {
  i.functions.round = `float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`, i.functions.starDistanceField = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`, i.functions.regularDistanceField = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`, _u(n, e, i, "shape-");
  let r = null;
  "shape-opacity" in n && (r = ne(i, n["shape-opacity"], Y));
  let s = "coordsPx";
  "shape-scale" in n && (s = `coordsPx / ${ne(i, n["shape-scale"], jt)}`);
  let o = null;
  "shape-fill-color" in n && (o = ne(i, n["shape-fill-color"], Me));
  let a = null;
  "shape-stroke-color" in n && (a = ne(
    i,
    n["shape-stroke-color"],
    Me
  ));
  let l = null;
  "shape-stroke-width" in n && (l = ne(
    i,
    n["shape-stroke-width"],
    Y
  ));
  const c = ne(
    i,
    n["shape-points"],
    Y
  );
  let h = "0.";
  "shape-angle" in n && (h = ne(i, n["shape-angle"], Y));
  let u, d = ne(i, n["shape-radius"], Y);
  if (l !== null && (d = `${d} + ${l} * 0.5`), "shape-radius2" in n) {
    let g = ne(i, n["shape-radius2"], Y);
    l !== null && (g = `${g} + ${l} * 0.5`), u = `starDistanceField(${s}, ${c}, ${d}, ${g}, ${h})`;
  } else
    u = `regularDistanceField(${s}, ${c}, ${d}, ${h})`;
  const f = Im(
    u,
    o,
    a,
    l,
    r
  );
  e.setSymbolColorExpression(f);
}
function U1(n, e, t, i) {
  let r = "vec4(1.0)";
  "icon-color" in n && (r = ne(i, n["icon-color"], Me)), "icon-opacity" in n && (r = `${r} * vec4(1.0, 1.0, 1.0, ${ne(
    i,
    n["icon-opacity"],
    Y
  )})`);
  const s = Ra(n["icon-src"]), o = pu(
    n,
    e,
    t,
    "icon-",
    s
  );
  if (e.setSymbolColorExpression(
    `${r} * texture2D(u_texture${s}, v_texCoord)`
  ).setSymbolSizeExpression(o), "icon-width" in n && "icon-height" in n && e.setSymbolSizeExpression(
    `vec2(${ne(
      i,
      n["icon-width"],
      Y
    )}, ${ne(i, n["icon-height"], Y)})`
  ), "icon-offset" in n && "icon-size" in n) {
    const a = ne(
      i,
      n["icon-size"],
      Dt
    ), l = e.getSymbolSizeExpression();
    e.setSymbolSizeExpression(a);
    const c = yu(
      n,
      "icon-",
      i,
      "v_quadSizePx",
      a
    );
    e.setTextureCoordinateExpression(
      `(vec4((${c}).xyxy) + vec4(0., 0., ${a})) / (${l}).xyxy`
    );
  }
  if (_u(n, e, i, "icon-"), "icon-anchor" in n) {
    const a = ne(
      i,
      n["icon-anchor"],
      Dt
    );
    let l = "1.0";
    "icon-scale" in n && (l = ne(i, n["icon-scale"], jt));
    let c;
    n["icon-anchor-x-units"] === "pixels" && n["icon-anchor-y-units"] === "pixels" ? c = `${a} * ${l}` : n["icon-anchor-x-units"] === "pixels" ? c = `${a} * vec2(vec2(${l}).x, v_quadSizePx.y)` : n["icon-anchor-y-units"] === "pixels" ? c = `${a} * vec2(v_quadSizePx.x, vec2(${l}).x)` : c = `${a} * v_quadSizePx`;
    let h = `v_quadSizePx * vec2(0.5, -0.5) + ${c} * vec2(-1., 1.)`;
    if ("icon-anchor-origin" in n)
      switch (n["icon-anchor-origin"]) {
        case "top-right":
          h = `v_quadSizePx * -0.5 + ${c}`;
          break;
        case "bottom-left":
          h = `v_quadSizePx * 0.5 - ${c}`;
          break;
        case "bottom-right":
          h = `v_quadSizePx * vec2(-0.5, 0.5) + ${c} * vec2(1., -1.)`;
          break;
      }
    e.setSymbolOffsetExpression(
      `${e.getSymbolOffsetExpression()} + ${h}`
    );
  }
}
function B1(n, e, t, i) {
  if ("stroke-color" in n && e.setStrokeColorExpression(
    ne(i, n["stroke-color"], Me)
  ), "stroke-pattern-src" in n) {
    const r = Ra(n["stroke-pattern-src"]), s = pu(
      n,
      e,
      t,
      "stroke-pattern-",
      r
    );
    let o = s, a = "vec2(0.)";
    "stroke-pattern-offset" in n && "stroke-pattern-size" in n && (o = ne(
      i,
      n["stroke-pattern-size"],
      Dt
    ), a = yu(
      n,
      "stroke-pattern-",
      i,
      s,
      o
    ));
    let l = "0.";
    "stroke-pattern-spacing" in n && (l = ne(
      i,
      n["stroke-pattern-spacing"],
      Y
    )), i.functions.sampleStrokePattern = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return texture2D(texture, texCoord);
}`;
    const c = `u_texture${r}`;
    let h = "1.";
    "stroke-color" in n && (h = e.getStrokeColorExpression()), e.setStrokeColorExpression(
      `${h} * sampleStrokePattern(${c}, ${s}, ${a}, ${o}, ${l}, currentLengthPx, currentRadiusRatio, v_width)`
    );
  }
  if ("stroke-width" in n && e.setStrokeWidthExpression(
    ne(i, n["stroke-width"], Y)
  ), "stroke-offset" in n && e.setStrokeOffsetExpression(
    ne(i, n["stroke-offset"], Y)
  ), "stroke-line-cap" in n && e.setStrokeCapExpression(
    ne(i, n["stroke-line-cap"], He)
  ), "stroke-line-join" in n && e.setStrokeJoinExpression(
    ne(i, n["stroke-line-join"], He)
  ), "stroke-miter-limit" in n && e.setStrokeMiterLimitExpression(
    ne(i, n["stroke-miter-limit"], Y)
  ), "stroke-line-dash" in n) {
    i.functions.getSingleDashDistance = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType, float lineWidth) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${jn("square")}) {
    distanceSegment -= lineWidth * 0.5;
  } else if (capType == ${jn("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - lineWidth * 0.5);
  }
  return distanceSegment;
}`;
    let r = n["stroke-line-dash"].map(
      (f) => ne(i, f, Y)
    );
    r.length % 2 === 1 && (r = [...r, ...r]);
    let s = "0.";
    "stroke-line-dash-offset" in n && (s = ne(
      i,
      n["stroke-line-dash-offset"],
      Y
    ));
    const a = `dashDistanceField_${Ra(n["stroke-line-dash"])}`, l = r.map((f, g) => `float dashLength${g}`).join(", "), c = r.map((f, g) => `dashLength${g}`).join(" + ");
    let h = "0.", u = `getSingleDashDistance(distance, radius, ${h}, dashLength0, totalDashLength, capType, lineWidth)`;
    for (let f = 2; f < r.length; f += 2)
      h = `${h} + dashLength${f - 2} + dashLength${f - 1}`, u = `min(${u}, getSingleDashDistance(distance, radius, ${h}, dashLength${f}, totalDashLength, capType, lineWidth))`;
    i.functions[a] = `float ${a}(float distance, float radius, float capType, float lineWidth, ${l}) {
  float totalDashLength = ${c};
  return ${u};
}`;
    const d = r.map((f, g) => `${f}`).join(", ");
    e.setStrokeDistanceFieldExpression(
      `${a}(currentLengthPx + ${s}, currentRadiusPx, capType, v_width, ${d})`
    );
  }
}
function z1(n, e, t, i) {
  if ("fill-color" in n && e.setFillColorExpression(
    ne(i, n["fill-color"], Me)
  ), "fill-pattern-src" in n) {
    const r = Ra(n["fill-pattern-src"]), s = pu(
      n,
      e,
      t,
      "fill-pattern-",
      r
    );
    let o = s, a = "vec2(0.)";
    "fill-pattern-offset" in n && "fill-pattern-size" in n && (o = ne(
      i,
      n["fill-pattern-size"],
      Dt
    ), a = yu(
      n,
      "fill-pattern-",
      i,
      s,
      o
    )), i.functions.sampleFillPattern = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return texture2D(texture, (samplePos + textureOffset) / textureSize);
}`;
    const l = `u_texture${r}`;
    let c = "1.";
    "fill-color" in n && (c = e.getFillColorExpression()), e.setFillColorExpression(
      `${c} * sampleFillPattern(${l}, ${s}, ${a}, ${o}, pxOrigin, pxPos)`
    );
  }
}
function W1(n, e, t) {
  const i = Tm(), r = new bm(), s = {};
  if ("icon-src" in n ? U1(n, r, s, i) : "shape-points" in n ? G1(n, r, s, i) : "circle-radius" in n && N1(n, r, s, i), B1(n, r, s, i), z1(n, r, s, i), t) {
    const l = ne(i, t, Xe);
    r.setFragmentDiscardExpression(`!${l}`);
  }
  const o = {};
  function a(l, c, h, u) {
    if (!i[l])
      return;
    const d = Qc(h), f = gu(h);
    r.addAttribute(`a_${c}`, d), o[c] = {
      size: f,
      callback: u
    };
  }
  return a(
    "geometryType",
    Sm,
    He,
    (l) => qs(il(l.getGeometry()))
  ), a(
    "featureId",
    wm,
    He | Y,
    (l) => {
      const c = l.getId() ?? null;
      return typeof c == "string" ? qs(c) : c;
    }
  ), Rm(r, i), {
    builder: r,
    attributes: { ...o, ...Pm(i) },
    uniforms: {
      ...s,
      ...Cm(i, e)
    }
  };
}
function Y1(n) {
  const e = Array.isArray(n) ? n : [n];
  if ("style" in e[0]) {
    const t = [], i = (
      /** @type {Array<import('../../style/flat.js').Rule>} */
      e
    ), r = [];
    for (const s of i) {
      const o = Array.isArray(s.style) ? s.style : [s.style];
      let a = s.filter;
      s.else && r.length && (a = [
        "all",
        ...r.map((c) => ["!", c])
      ], s.filter && a.push(s.filter), a.length < 3 && (a = a[1])), s.filter && r.push(s.filter);
      const l = o.map((c) => ({
        style: c,
        ...a && { filter: a }
      }));
      t.push(...l);
    }
    return t;
  }
  return "builder" in e[0] ? (
    /** @type {Array<StyleAsShaders>} */
    e
  ) : e.map(
    (t) => (
      /** @type {StyleAsRule} */
      {
        style: t
      }
    )
  );
}
const $1 = [];
let hc;
function j1() {
  return hc || (hc = L1()), hc;
}
let V1 = 0;
const mn = {
  POSITION: "a_position",
  INDEX: "a_index",
  SEGMENT_START: "a_segmentStart",
  SEGMENT_END: "a_segmentEnd",
  MEASURE_START: "a_measureStart",
  MEASURE_END: "a_measureEnd",
  PARAMETERS: "a_parameters",
  JOIN_ANGLES: "a_joinAngles",
  DISTANCE: "a_distance"
};
class X1 {
  /**
   * @param {VectorStyle} styleOrShaders Literal style or custom shaders
   * @param {import('../../style/flat.js').StyleVariables} variables Style variables
   * @param {import('../../webgl/Helper.js').default} helper Helper
   * @param {boolean} [enableHitDetection] Whether to enable the hit detection (needs compatible shader)
   * @param {import("../../expr/expression.js").ExpressionValue} [filter] Optional filter expression
   */
  constructor(e, t, i, r, s) {
    this.helper_, this.hitDetectionEnabled_ = !!r;
    let o = (
      /** @type {AsShaders} */
      e
    );
    if (!("builder" in e)) {
      const h = (
        /** @type {AsRule} */
        e
      ), u = W1(
        h.style,
        t,
        h.filter
      );
      o = {
        builder: u.builder,
        attributes: u.attributes,
        uniforms: u.uniforms
      };
    }
    this.fillProgram_, this.strokeProgram_, this.symbolProgram_, this.hasFill_ = !!o.builder.getFillVertexShader(), this.hasFill_ && (this.fillVertexShader_ = o.builder.getFillVertexShader(), this.fillFragmentShader_ = o.builder.getFillFragmentShader()), this.hasStroke_ = !!o.builder.getStrokeVertexShader(), this.hasStroke_ && (this.strokeVertexShader_ = o.builder.getStrokeVertexShader(), this.strokeFragmentShader_ = o.builder.getStrokeFragmentShader()), this.hasSymbol_ = !!o.builder.getSymbolVertexShader(), this.hasSymbol_ && (this.symbolVertexShader_ = o.builder.getSymbolVertexShader(), this.symbolFragmentShader_ = o.builder.getSymbolFragmentShader()), this.featureFilter_ = null, s && (this.featureFilter_ = this.computeFeatureFilter(s));
    const l = this.hitDetectionEnabled_ ? {
      hitColor: {
        callback() {
          return O1(this.ref, $1);
        },
        size: 4
      }
    } : {};
    this.customAttributes_ = Object.assign(
      {},
      l,
      o.attributes
    ), this.uniforms_ = o.uniforms;
    const c = Object.entries(this.customAttributes_).map(
      ([h, u]) => ({
        name: `a_${h}`,
        size: u.size || 1,
        type: yt.FLOAT
      })
    );
    this.polygonAttributesDesc_ = [
      {
        name: mn.POSITION,
        size: 2,
        type: yt.FLOAT
      },
      ...c
    ], this.lineStringAttributesDesc_ = [
      {
        name: mn.SEGMENT_START,
        size: 2,
        type: yt.FLOAT
      },
      {
        name: mn.MEASURE_START,
        size: 1,
        type: yt.FLOAT
      },
      {
        name: mn.SEGMENT_END,
        size: 2,
        type: yt.FLOAT
      },
      {
        name: mn.MEASURE_END,
        size: 1,
        type: yt.FLOAT
      },
      {
        name: mn.JOIN_ANGLES,
        size: 2,
        type: yt.FLOAT
      },
      {
        name: mn.DISTANCE,
        size: 1,
        type: yt.FLOAT
      },
      {
        name: mn.PARAMETERS,
        size: 1,
        type: yt.FLOAT
      },
      ...c
    ], this.pointAttributesDesc_ = [
      {
        name: mn.POSITION,
        size: 2,
        type: yt.FLOAT
      },
      {
        name: mn.INDEX,
        size: 1,
        type: yt.FLOAT
      },
      ...c
    ], this.setHelper(i);
  }
  /**
   * Will apply the style filter when generating geometry batches (if it can be evaluated outside a map context)
   * @param {import("../../expr/expression.js").ExpressionValue} filter Style filter
   * @return {function(import('../../Feature.js').FeatureLike): boolean} Feature filter
   * @private
   */
  computeFeatureFilter(e) {
    const t = nl();
    let i;
    try {
      i = Rn(e, Xe, t);
    } catch {
      return null;
    }
    if (t.mapState || t.variables.size > 0)
      return null;
    const r = jh();
    return (s) => {
      if (r.properties = s.getPropertiesInternal(), t.featureId) {
        const o = s.getId();
        o !== void 0 ? r.featureId = o : r.featureId = null;
      }
      return r.geometryType = il(s.getGeometry()), /** @type {boolean} */
      i(r);
    };
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<WebGLBuffers|null>} A promise resolving to WebGL buffers; returns null if buffers are empty
   */
  async generateBuffers(e, t) {
    let i = e;
    if (this.featureFilter_ && (i = i.filter(this.featureFilter_), i.isEmpty()))
      return null;
    const r = this.generateRenderInstructions_(
      i,
      t
    ), [s, o, a] = await Promise.all(
      [
        this.generateBuffersForType_(
          r.polygonInstructions,
          "Polygon",
          t
        ),
        this.generateBuffersForType_(
          r.lineStringInstructions,
          "LineString",
          t
        ),
        this.generateBuffersForType_(
          r.pointInstructions,
          "Point",
          t
        )
      ]
    ), l = Bs(
      Ke(),
      t
    );
    return {
      polygonBuffers: s,
      lineStringBuffers: o,
      pointBuffers: a,
      invertVerticesTransform: l
    };
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {RenderInstructions} Render instructions
   * @private
   */
  generateRenderInstructions_(e, t) {
    const i = this.hasFill_ ? k1(
      e.polygonBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null, r = this.hasStroke_ ? F1(
      e.lineStringBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null, s = this.hasSymbol_ ? D1(
      e.pointBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null;
    return {
      polygonInstructions: i,
      lineStringInstructions: r,
      pointInstructions: s
    };
  }
  /**
   * @param {Float32Array|null} renderInstructions Render instructions
   * @param {import("../../geom/Geometry.js").Type} geometryType Geometry type
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render
   * @private
   */
  generateBuffersForType_(e, t, i) {
    if (e === null)
      return null;
    const r = V1++;
    let s;
    switch (t) {
      case "Polygon":
        s = cc.GENERATE_POLYGON_BUFFERS;
        break;
      case "LineString":
        s = cc.GENERATE_LINE_STRING_BUFFERS;
        break;
      case "Point":
        s = cc.GENERATE_POINT_BUFFERS;
        break;
    }
    const o = {
      id: r,
      type: s,
      renderInstructions: e.buffer,
      renderInstructionsTransform: i,
      customAttributesSize: cl(this.customAttributes_)
    }, a = j1();
    return a.postMessage(o, [e.buffer]), e = null, new Promise((l) => {
      const c = (h) => {
        const u = h.data;
        if (u.id !== r || (a.removeEventListener("message", c), !this.helper_.getGL()))
          return;
        const d = new af(
          lu,
          sf
        ).fromArrayBuffer(u.vertexBuffer), f = new af(
          cu,
          sf
        ).fromArrayBuffer(u.indexBuffer);
        this.helper_.flushBufferData(d), this.helper_.flushBufferData(f), l([f, d]);
      };
      a.addEventListener("message", c);
    });
  }
  /**
   * Render the geometries in the given buffers.
   * @param {WebGLBuffers} buffers WebGL Buffers to draw
   * @param {import("../../Map.js").FrameState} frameState Frame state
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   */
  render(e, t, i) {
    this.hasFill_ && this.renderInternal_(
      e.polygonBuffers[0],
      e.polygonBuffers[1],
      this.fillProgram_,
      this.polygonAttributesDesc_,
      t,
      i
    ), this.hasStroke_ && this.renderInternal_(
      e.lineStringBuffers[0],
      e.lineStringBuffers[1],
      this.strokeProgram_,
      this.lineStringAttributesDesc_,
      t,
      i
    ), this.hasSymbol_ && this.renderInternal_(
      e.pointBuffers[0],
      e.pointBuffers[1],
      this.symbolProgram_,
      this.pointAttributesDesc_,
      t,
      i
    );
  }
  /**
   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer
   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer
   * @param {WebGLProgram} program Program
   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   * @private
   */
  renderInternal_(e, t, i, r, s, o) {
    const a = e.getSize();
    a !== 0 && (this.helper_.useProgram(i, s), this.helper_.bindBuffer(t), this.helper_.bindBuffer(e), this.helper_.enableAttributes(r), o(), this.helper_.drawElements(0, a));
  }
  /**
   * @param {import('../../webgl/Helper.js').default} helper Helper
   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any
   */
  setHelper(e, t = null) {
    this.helper_ = e, this.hasFill_ && (this.fillProgram_ = this.helper_.getProgram(
      this.fillFragmentShader_,
      this.fillVertexShader_
    )), this.hasStroke_ && (this.strokeProgram_ = this.helper_.getProgram(
      this.strokeFragmentShader_,
      this.strokeVertexShader_
    )), this.hasSymbol_ && (this.symbolProgram_ = this.helper_.getProgram(
      this.symbolFragmentShader_,
      this.symbolVertexShader_
    )), this.helper_.addUniforms(this.uniforms_), t && (t.polygonBuffers && (this.helper_.flushBufferData(t.polygonBuffers[0]), this.helper_.flushBufferData(t.polygonBuffers[1])), t.lineStringBuffers && (this.helper_.flushBufferData(t.lineStringBuffers[0]), this.helper_.flushBufferData(t.lineStringBuffers[1])), t.pointBuffers && (this.helper_.flushBufferData(t.pointBuffers[0]), this.helper_.flushBufferData(t.pointBuffers[1])));
  }
}
const _n = new Uint8Array(4);
class H1 {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const i = e.getGL();
    this.texture_ = i.createTexture(), this.framebuffer_ = i.createFramebuffer(), this.depthbuffer_ = i.createRenderbuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   */
  setSize(e) {
    oi(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return _n[0] = 0, _n[1] = 0, _n[2] = 0, _n[3] = 0, _n;
    this.readAll();
    const i = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return _n[0] = this.data_[i * 4], _n[1] = this.data_[i * 4 + 1], _n[2] = this.data_[i * 4 + 2], _n[3] = this.data_[i * 4 + 3], _n;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer of the render target
   */
  getDepthbuffer() {
    return this.depthbuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), t.bindRenderbuffer(t.RENDERBUFFER, this.depthbuffer_), t.renderbufferStorage(
      t.RENDERBUFFER,
      t.DEPTH_COMPONENT16,
      e[0],
      e[1]
    ), t.framebufferRenderbuffer(
      t.FRAMEBUFFER,
      t.DEPTH_ATTACHMENT,
      t.RENDERBUFFER,
      this.depthbuffer_
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
function K1(n, e) {
  const t = n.viewState.projection, r = e.getSource().getWrapX() && t.canWrapX(), s = t.getExtent(), o = n.extent, a = r ? Ee(s) : null, l = r ? Math.ceil((o[2] - s[2]) / a) + 1 : 1;
  return [r ? Math.floor((o[0] - s[0]) / a) : 0, l, a];
}
const Rr = {
  ...zn,
  RENDER_EXTENT: "u_renderExtent",
  // intersection of layer, source, and view extent
  PATTERN_ORIGIN: "u_patternOrigin",
  GLOBAL_ALPHA: "u_globalAlpha"
};
class Z1 extends hu {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const i = {
      [Rr.RENDER_EXTENT]: [0, 0, 0, 0],
      [Rr.PATTERN_ORIGIN]: [0, 0],
      [Rr.GLOBAL_ALPHA]: 1
    };
    super(e, {
      uniforms: i,
      postProcesses: t.postProcesses
    }), this.hitDetectionEnabled_ = !t.disableHitDetection, this.hitRenderTarget_, this.sourceRevision_ = -1, this.previousExtent_ = St(), this.currentTransform_ = Ke(), this.tmpCoords_ = [0, 0], this.tmpTransform_ = Ke(), this.tmpMat4_ = ym(), this.currentFrameStateTransform_ = Ke(), this.styleVariables_ = {}, this.styles_ = [], this.styleRenderers_ = [], this.buffers_ = [], this.applyOptions_(t), this.batch_ = new ba(), this.initialFeaturesAdded_ = !1, this.sourceListenKeys_ = null;
  }
  /**
   * @private
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  addInitialFeatures_(e) {
    const t = this.getLayer().getSource();
    let i;
    this.batch_.addFeatures(t.getFeatures(), i), this.sourceListenKeys_ = [
      ce(
        t,
        ct.ADDFEATURE,
        this.handleSourceFeatureAdded_.bind(this, i)
      ),
      ce(
        t,
        ct.CHANGEFEATURE,
        this.handleSourceFeatureChanged_.bind(this, i),
        this
      ),
      ce(
        t,
        ct.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      ce(
        t,
        ct.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ];
  }
  /**
   * @param {Options} options Options.
   * @private
   */
  applyOptions_(e) {
    this.styleVariables_ = e.variables, this.styles_ = Y1(e.style);
  }
  /**
   * @private
   */
  createRenderers_() {
    this.buffers_ = [], this.styleRenderers_ = this.styles_.map(
      (e) => new X1(
        e,
        this.styleVariables_,
        this.helper,
        this.hitDetectionEnabled_,
        "filter" in e ? e.filter : null
      )
    );
  }
  /**
   * @override
   */
  reset(e) {
    this.applyOptions_(e), this.helper && this.createRenderers_(), super.reset(e);
  }
  /**
   * @override
   */
  afterHelperCreated() {
    this.styleRenderers_.length ? this.styleRenderers_.forEach(
      (e, t) => e.setHelper(this.helper, this.buffers_[t])
    ) : this.createRenderers_(), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new H1(this.helper));
  }
  /**
   * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e, t) {
    const i = t.feature;
    this.batch_.addFeature(i, e);
  }
  /**
   * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e, t) {
    const i = t.feature;
    this.batch_.changeFeature(i, e);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    this.batch_.removeFeature(t);
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.batch_.clear();
  }
  /**
   * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed
   * @private
   */
  applyUniforms_(e) {
    fg(this.tmpTransform_, this.currentFrameStateTransform_), Ch(this.tmpTransform_, e), this.helper.setUniformMatrixValue(
      Rr.PROJECTION_MATRIX,
      Zc(this.tmpMat4_, this.tmpTransform_)
    ), Bs(this.tmpTransform_, this.tmpTransform_), this.helper.setUniformMatrixValue(
      Rr.SCREEN_TO_WORLD_MATRIX,
      Zc(this.tmpMat4_, this.tmpTransform_)
    ), this.tmpCoords_[0] = 0, this.tmpCoords_[1] = 0, Bs(this.tmpTransform_, e), Ue(this.tmpTransform_, this.tmpCoords_), this.helper.setUniformFloatVec2(Rr.PATTERN_ORIGIN, this.tmpCoords_);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const [i, r, s] = K1(
      e,
      this.getLayer()
    );
    this.helper.prepareDraw(e), this.renderWorlds(e, !1, i, r, s), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const o = this.helper.getCanvas();
    return this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, i, r, s), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), o;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrameInternal(e) {
    this.initialFeaturesAdded_ || (this.addInitialFeatures_(e), this.initialFeaturesAdded_ = !0);
    const t = this.getLayer(), i = t.getSource(), r = e.viewState, s = !e.viewHints[Qe.ANIMATING] && !e.viewHints[Qe.INTERACTING], o = !Vr(this.previousExtent_, e.extent), a = this.sourceRevision_ < i.getRevision();
    if (a && (this.sourceRevision_ = i.getRevision()), s && (o || a)) {
      const l = r.projection, c = r.resolution, h = t instanceof ol ? t.getRenderBuffer() : 0, u = ni(e.extent, h * c);
      i.loadFeatures(u, c, l), this.ready = !1;
      const d = this.helper.makeProjectionTransform(
        e,
        Ke()
      ), f = this.styleRenderers_.map(
        (g, _) => g.generateBuffers(this.batch_, d).then((m) => {
          this.buffers_[_] && this.disposeBuffers(this.buffers_[_]), this.buffers_[_] = m;
        })
      );
      Promise.all(f).then(() => {
        this.ready = !0, this.getLayer().changed();
      }), this.previousExtent_ = e.extent.slice();
    }
    return !0;
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(e, t, i, r, s) {
    let o = i;
    t && (this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    ));
    do {
      this.helper.makeProjectionTransform(
        e,
        this.currentFrameStateTransform_
      ), Vy(
        this.currentFrameStateTransform_,
        o * s,
        0
      );
      for (let a = 0, l = this.styleRenderers_.length; a < l; a++) {
        const c = this.styleRenderers_[a], h = this.buffers_[a];
        h && c.render(h, e, () => {
          this.applyUniforms_(h.invertVerticesTransform), this.helper.applyHitDetectionUniform(t);
        });
      }
    } while (++o < r);
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, i, r, s) {
    if (ge(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    ), !this.styleRenderers_.length || !this.hitDetectionEnabled_)
      return;
    const o = Ue(
      t.coordinateToPixelTransform,
      e.slice()
    ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], c = M1(l), h = this.batch_.getFeatureFromRef(c);
    if (h)
      return r(h, this.getLayer(), null);
  }
  /**
   * Will release a set of Webgl buffers
   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers
   */
  disposeBuffers(e) {
    const t = (i) => {
      for (const r of i)
        r && this.helper.deleteBuffer(r);
    };
    e.pointBuffers && t(e.pointBuffers), e.lineStringBuffers && t(e.lineStringBuffers), e.polygonBuffers && t(e.polygonBuffers);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.buffers_.forEach((e) => {
      e && this.disposeBuffers(e);
    }), this.sourceListenKeys_ && (this.sourceListenKeys_.forEach(function(e) {
      Re(e);
    }), this.sourceListenKeys_ = null), super.disposeInternal();
  }
  renderDeclutter() {
  }
}
const Gn = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, q1 = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class J1 extends ol {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.filter_ = e.filter ?? !0, this.styleVariables_ = e.variables || {}, this.gradient_ = null, this.addChangeListener(Gn.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : q1), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const i = e.weight ? e.weight : "weight";
    this.weight_ = i, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {import("../style/flat.js").NumberExpression} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {import("../style/flat.js").NumberExpression} */
      this.get(Gn.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(Gn.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {import("../style/flat.js").NumberExpression} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {import("../style/flat.js").NumberExpression} */
      this.get(Gn.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = Q1(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {import("../style/flat.js").NumberExpression} blur Blur size in pixels (supports expressions).
   * @api
   * @observable
   */
  setBlur(e) {
    const t = this.get(Gn.BLUR);
    if (this.set(Gn.BLUR, e), typeof e == "number" && typeof t == "number") {
      this.changed();
      return;
    }
    this.clearRenderer();
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(Gn.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {import("../style/flat.js").NumberExpression} radius Radius size in pixel (supports expressions).
   * @api
   * @observable
   */
  setRadius(e) {
    const t = this.get(Gn.RADIUS);
    if (this.set(Gn.RADIUS, e), typeof e == "number" && typeof t == "number") {
      this.changed();
      return;
    }
    this.clearRenderer();
  }
  /**
   * Set the filter expression
   * @param {import("../style/flat.js").BooleanExpression} filter Filter expression
   * @api
   */
  setFilter(e) {
    this.filter_ = e, this.changed(), this.clearRenderer();
  }
  /**
   * Set the weight expression
   * @param {WeightExpression} weight Weight expression
   * @api
   */
  setWeight(e) {
    this.weight_ = e, this.changed(), this.clearRenderer();
  }
  /**
   * @override
   */
  createRenderer() {
    const e = new bm(), t = Tm(), i = ne(t, this.filter_, Xe);
    let r = ne(
      t,
      this.getRadius(),
      Y
    ), s = ne(t, this.getBlur(), Y);
    const o = {};
    typeof this.getBlur() == "number" && (s = "a_blur", o.a_blur = () => this.getBlur(), e.addUniform("a_blur", "float")), typeof this.getRadius() == "number" && (r = "a_radius", o.a_radius = () => this.getRadius(), e.addUniform("a_radius", "float"));
    const a = {};
    let l = null;
    if (typeof this.weight_ == "string" || typeof this.weight_ == "function") {
      const u = typeof this.weight_ == "string" ? (d) => d.get(this.weight_) : this.weight_;
      a.prop_weight = {
        size: 1,
        callback: (d) => {
          const f = u(d);
          return f !== void 0 ? De(f, 0, 1) : 1;
        }
      }, l = "a_prop_weight", e.addAttribute("a_prop_weight", "float");
    } else {
      const u = ["clamp", this.weight_, 0, 1];
      l = ne(t, u, Y);
    }
    e.addFragmentShaderFunction(
      `float getBlurSlope() {
  float blur = max(1., ${s});
  float radius = ${r};
  return radius / blur;
}`
    ).setSymbolSizeExpression(`vec2(${r} + ${s}) * 2.`).setSymbolColorExpression(
      `vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * getBlurSlope()) * ${l})`
    ).setStrokeColorExpression(
      `vec4(smoothstep(0., 1., (1. - length(currentRadiusPx * 2. / v_width)) * getBlurSlope()) * ${l})`
    ).setStrokeWidthExpression(`(${r} + ${s}) * 2.`).setFillColorExpression(`vec4(${l})`).setFragmentDiscardExpression(`!${i}`), Rm(e, t);
    const c = Pm(t), h = Cm(t, this.styleVariables_);
    return new Z1(this, {
      className: this.getClassName(),
      variables: this.styleVariables_,
      style: {
        builder: e,
        attributes: {
          ...c,
          ...a
        },
        uniforms: {
          ...h,
          ...o
        }
      },
      disableHitDetection: !1,
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
  /**
   * @override
   */
  renderDeclutter() {
  }
}
function Q1(n) {
  const i = je(1, 256), r = i.createLinearGradient(0, 0, 1, 256), s = 1 / (n.length - 1);
  for (let o = 0, a = n.length; o < a; ++o)
    r.addColorStop(o * s, n[o]);
  return i.fillStyle = r, i.fillRect(0, 0, 1, 256), i.canvas;
}
class eT {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
    Ri, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let i = t.dataProjection ? Ie(t.dataProjection) : this.readProjection(e);
      t.extent && i && i.getUnits() === "tile-pixels" && (i = Ie(i), i.setWorldExtent(t.extent)), t = {
        dataProjection: i,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return Q();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeature(e, t) {
    return Q();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   */
  readFeatures(e, t) {
    return Q();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return Q();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return Q();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return Q();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return Q();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return Q();
  }
}
function xu(n, e, t) {
  const i = t ? Ie(t.featureProjection) : null, r = t ? Ie(t.dataProjection) : null;
  let s = n;
  if (i && r && !Qo(i, r)) {
    e && (s = /** @type {T} */
    n.clone());
    const o = e ? i : r, a = e ? r : i;
    o.getUnits() === "tile-pixels" ? s.transform(o, a) : s.applyTransform(Kr(o, a));
  }
  if (e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), a = function(l) {
      for (let c = 0, h = l.length; c < h; ++c)
        l[c] = Math.round(l[c] * o) / o;
      return l;
    };
    s === n && (s = /** @type {T} */
    n.clone()), s.applyTransform(a);
  }
  return s;
}
const tT = {
  Point: on,
  LineString: Zr,
  Polygon: Ci,
  MultiPoint: Qa,
  MultiLineString: ya,
  MultiPolygon: xa
};
function nT(n, e, t) {
  return Array.isArray(e[0]) ? (Sg(n, 0, e, t) || (n = n.slice(), kc(n, 0, e, t)), n) : (kh(n, 0, e, t) || (n = n.slice(), fa(n, 0, e, t)), n);
}
function Am(n, e) {
  var s;
  const t = n.geometry;
  if (!t)
    return [];
  if (Array.isArray(t))
    return t.map((o) => Am({ ...n, geometry: o })).flat();
  const i = t.type === "MultiPolygon" ? "Polygon" : t.type;
  if (i === "GeometryCollection" || i === "Circle")
    throw new Error("Unsupported geometry type: " + i);
  const r = t.layout.length;
  return xu(
    new At(
      i,
      i === "Polygon" ? nT(t.flatCoordinates, t.ends, r) : t.flatCoordinates,
      (s = t.ends) == null ? void 0 : s.flat(),
      r,
      n.properties || {},
      n.id
    ).enableSimplifyTransformed(),
    !1,
    e
  );
}
function vu(n, e) {
  if (!n)
    return null;
  if (Array.isArray(n)) {
    const i = n.map(
      (r) => vu(r, e)
    );
    return new pa(i);
  }
  const t = tT[n.type];
  return xu(
    new t(n.flatCoordinates, n.layout || "XY", n.ends),
    !1,
    e
  );
}
class iT extends eT {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @api
   * @override
   */
  readFeature(e, t) {
    return this.readFeatureFromObject(
      Ho(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    return this.readFeaturesFromObject(
      Ho(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeatureFromObject(e, t) {
    return Q();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   */
  readFeaturesFromObject(e, t) {
    return Q();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      Ho(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return Q();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    return this.readProjectionFromObject(Ho(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return Q();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   * @override
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return Q();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   * @override
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return Q();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   * @override
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return Q();
  }
}
function Ho(n) {
  if (typeof n == "string") {
    const e = JSON.parse(n);
    return e || null;
  }
  return n !== null ? n : null;
}
class rT extends iT {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = Ie(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = Ie(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @override
   */
  readFeatureFromObject(e, t) {
    let i = null;
    e.type === "Feature" ? i = /** @type {GeoJSONFeature} */
    e : i = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const r = Eu(i.geometry);
    if (this.featureClass === At)
      return (
        /** @type {FeatureType|Array<FeatureType>} */
        Am(
          {
            geometry: r,
            id: i.id,
            properties: i.properties
          },
          t
        )
      );
    const s = new Ri();
    return this.geometryName_ ? s.setGeometryName(this.geometryName_) : this.extractGeometryName_ && i.geometry_name && s.setGeometryName(i.geometry_name), s.setGeometry(vu(r, t)), "id" in i && s.setId(i.id), i.properties && s.setProperties(i.properties, !0), /** @type {FeatureType|Array<FeatureType>} */
    s;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   * @override
   */
  readFeaturesFromObject(e, t) {
    const i = (
      /** @type {GeoJSONObject} */
      e
    );
    let r = null;
    if (i.type === "FeatureCollection") {
      const s = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      r = [];
      const o = s.features;
      for (let a = 0, l = o.length; a < l; ++a) {
        const c = this.readFeatureFromObject(
          o[a],
          t
        );
        c && r.push(c);
      }
    } else
      r = [this.readFeatureFromObject(e, t)];
    return (
      /** @type {Array<FeatureType>} */
      r.flat()
    );
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromObject(e, t) {
    return sT(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let i;
    if (t)
      if (t.type == "name")
        i = Ie(t.properties.name);
      else if (t.type === "EPSG")
        i = Ie("EPSG:" + t.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      i = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      i
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   * @override
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const i = {
      type: "Feature",
      geometry: null,
      properties: null
    }, r = e.getId();
    if (r !== void 0 && (i.id = r), !e.hasProperties())
      return i;
    const s = e.getProperties(), o = e.getGeometry();
    return o && (i.geometry = eh(o, t), delete s[e.getGeometryName()]), er(s) || (i.properties = s), i;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   * @override
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const i = [];
    for (let r = 0, s = e.length; r < s; ++r)
      i.push(this.writeFeatureObject(e[r], t));
    return {
      type: "FeatureCollection",
      features: i
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   * @override
   */
  writeGeometryObject(e, t) {
    return eh(e, this.adaptOptions(t));
  }
}
function Eu(n, e) {
  if (!n)
    return null;
  let t;
  switch (n.type) {
    case "Point": {
      t = aT(
        /** @type {GeoJSONPoint} */
        n
      );
      break;
    }
    case "LineString": {
      t = lT(
        /** @type {GeoJSONLineString} */
        n
      );
      break;
    }
    case "Polygon": {
      t = dT(
        /** @type {GeoJSONPolygon} */
        n
      );
      break;
    }
    case "MultiPoint": {
      t = hT(
        /** @type {GeoJSONMultiPoint} */
        n
      );
      break;
    }
    case "MultiLineString": {
      t = cT(
        /** @type {GeoJSONMultiLineString} */
        n
      );
      break;
    }
    case "MultiPolygon": {
      t = uT(
        /** @type {GeoJSONMultiPolygon} */
        n
      );
      break;
    }
    case "GeometryCollection": {
      t = oT(
        /** @type {GeoJSONGeometryCollection} */
        n
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + n.type);
  }
  return t;
}
function sT(n, e) {
  const t = Eu(n);
  return vu(t, e);
}
function oT(n, e) {
  return n.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(i) {
      return Eu(i);
    }
  );
}
function aT(n) {
  const e = n.coordinates;
  return {
    type: "Point",
    flatCoordinates: e,
    layout: lr(e.length)
  };
}
function lT(n) {
  var i;
  const e = n.coordinates, t = e.flat();
  return {
    type: "LineString",
    flatCoordinates: t,
    ends: [t.length],
    layout: lr(((i = e[0]) == null ? void 0 : i.length) || 2)
  };
}
function cT(n) {
  var s, o;
  const e = n.coordinates, t = ((o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o.length) || 2, i = [], r = ho(i, 0, e, t);
  return {
    type: "MultiLineString",
    flatCoordinates: i,
    ends: r,
    layout: lr(t)
  };
}
function hT(n) {
  var t;
  const e = n.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: e.flat(),
    layout: lr(((t = e[0]) == null ? void 0 : t.length) || 2)
  };
}
function uT(n) {
  var s, o;
  const e = n.coordinates, t = [], i = ((o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o[0].length) || 2, r = yg(
    t,
    0,
    e,
    i
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: t,
    ends: r,
    layout: lr(i)
  };
}
function dT(n) {
  var s, o;
  const e = n.coordinates, t = [], i = (o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o.length, r = ho(t, 0, e, i);
  return {
    type: "Polygon",
    flatCoordinates: t,
    ends: r,
    layout: lr(i)
  };
}
function eh(n, e) {
  n = xu(n, !0, e);
  const t = n.getType();
  let i;
  switch (t) {
    case "Point": {
      i = yT(
        /** @type {import("../geom/Point.js").default} */
        n
      );
      break;
    }
    case "LineString": {
      i = gT(
        /** @type {import("../geom/LineString.js").default} */
        n
      );
      break;
    }
    case "Polygon": {
      i = xT(
        /** @type {import("../geom/Polygon.js").default} */
        n,
        e
      );
      break;
    }
    case "MultiPoint": {
      i = _T(
        /** @type {import("../geom/MultiPoint.js").default} */
        n
      );
      break;
    }
    case "MultiLineString": {
      i = mT(
        /** @type {import("../geom/MultiLineString.js").default} */
        n
      );
      break;
    }
    case "MultiPolygon": {
      i = pT(
        /** @type {import("../geom/MultiPolygon.js").default} */
        n,
        e
      );
      break;
    }
    case "GeometryCollection": {
      i = fT(
        /** @type {import("../geom/GeometryCollection.js").default} */
        n,
        e
      );
      break;
    }
    case "Circle": {
      i = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return i;
}
function fT(n, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: n.getGeometriesArray().map(function(i) {
      return eh(i, e);
    })
  };
}
function gT(n, e) {
  return {
    type: "LineString",
    coordinates: n.getCoordinates()
  };
}
function mT(n, e) {
  return {
    type: "MultiLineString",
    coordinates: n.getCoordinates()
  };
}
function _T(n, e) {
  return {
    type: "MultiPoint",
    coordinates: n.getCoordinates()
  };
}
function pT(n, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: n.getCoordinates(t)
  };
}
function yT(n, e) {
  return {
    type: "Point",
    coordinates: n.getCoordinates()
  };
}
function xT(n, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: n.getCoordinates(t)
  };
}
var Lm = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, df = he.createContext && /* @__PURE__ */ he.createContext(Lm), vT = ["attr", "size", "title"];
function ET(n, e) {
  if (n == null) return {};
  var t = TT(n, e), i, r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      i = s[r], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i]);
  }
  return t;
}
function TT(n, e) {
  if (n == null) return {};
  var t = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      if (e.indexOf(i) >= 0) continue;
      t[i] = n[i];
    }
  return t;
}
function Ca() {
  return Ca = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Ca.apply(this, arguments);
}
function ff(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function Pa(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ff(Object(t), !0).forEach(function(i) {
      wT(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : ff(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function wT(n, e, t) {
  return e = ST(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function ST(n) {
  var e = bT(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function bT(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function Om(n) {
  return n && n.map((e, t) => /* @__PURE__ */ he.createElement(e.tag, Pa({
    key: t
  }, e.attr), Om(e.child)));
}
function xo(n) {
  return (e) => /* @__PURE__ */ he.createElement(RT, Ca({
    attr: Pa({}, n.attr)
  }, e), Om(n.child));
}
function RT(n) {
  var e = (t) => {
    var {
      attr: i,
      size: r,
      title: s
    } = n, o = ET(n, vT), a = r || t.size || "1em", l;
    return t.className && (l = t.className), n.className && (l = (l ? l + " " : "") + n.className), /* @__PURE__ */ he.createElement("svg", Ca({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, t.attr, i, o, {
      className: l,
      style: Pa(Pa({
        color: n.color || t.color
      }, t.style), n.style),
      height: a,
      width: a,
      xmlns: "http://www.w3.org/2000/svg"
    }), s && /* @__PURE__ */ he.createElement("title", null, s), n.children);
  };
  return df !== void 0 ? /* @__PURE__ */ he.createElement(df.Consumer, null, (t) => e(t)) : e(Lm);
}
function CT(n) {
  return xo({ attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" }, child: [] }] })(n);
}
function PT(n) {
  return xo({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34z" }, child: [] }] })(n);
}
class gf extends Error {
  constructor(t, i, r) {
    const s = t.status || t.status === 0 ? t.status : "", o = t.statusText || "", a = `${s} ${o}`.trim(), l = a ? `status code ${a}` : "an unknown error";
    super(`Request failed with ${l}: ${i.method} ${i.url}`);
    Jt(this, "response");
    Jt(this, "request");
    Jt(this, "options");
    this.name = "HTTPError", this.response = t, this.request = i, this.options = r;
  }
}
class Mm extends Error {
  constructor(t) {
    super(`Request timed out: ${t.method} ${t.url}`);
    Jt(this, "request");
    this.name = "TimeoutError", this.request = t;
  }
}
const mf = (() => {
  let n = !1, e = !1;
  const t = typeof globalThis.ReadableStream == "function", i = typeof globalThis.Request == "function";
  if (t && i)
    try {
      e = new globalThis.Request("https://empty.invalid", {
        body: new globalThis.ReadableStream(),
        method: "POST",
        // @ts-expect-error - Types are outdated.
        get duplex() {
          return n = !0, "half";
        }
      }).headers.has("Content-Type");
    } catch (r) {
      if (r instanceof Error && r.message === "unsupported BodyInit type")
        return !1;
      throw r;
    }
  return n && !e;
})(), IT = typeof globalThis.AbortController == "function", AT = typeof globalThis.AbortSignal == "function" && typeof globalThis.AbortSignal.any == "function", LT = typeof globalThis.ReadableStream == "function", OT = typeof globalThis.FormData == "function", Dm = ["get", "post", "put", "patch", "head", "delete"], MT = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
}, uc = 2147483647, DT = new TextEncoder().encode("------WebKitFormBoundaryaxpyiPgbbPti10Rw").length, Fm = Symbol("stop"), FT = {
  json: !0,
  parseJson: !0,
  stringifyJson: !0,
  searchParams: !0,
  prefixUrl: !0,
  retry: !0,
  timeout: !0,
  hooks: !0,
  throwHttpErrors: !0,
  onDownloadProgress: !0,
  onUploadProgress: !0,
  fetch: !0
}, kT = {
  method: !0,
  headers: !0,
  body: !0,
  mode: !0,
  credentials: !0,
  cache: !0,
  redirect: !0,
  referrer: !0,
  referrerPolicy: !0,
  integrity: !0,
  keepalive: !0,
  signal: !0,
  window: !0,
  dispatcher: !0,
  duplex: !0,
  priority: !0
}, NT = (n) => {
  if (!n)
    return 0;
  if (n instanceof FormData) {
    let e = 0;
    for (const [t, i] of n)
      e += DT, e += new TextEncoder().encode(`Content-Disposition: form-data; name="${t}"`).length, e += typeof i == "string" ? new TextEncoder().encode(i).length : i.size;
    return e;
  }
  if (n instanceof Blob)
    return n.size;
  if (n instanceof ArrayBuffer)
    return n.byteLength;
  if (typeof n == "string")
    return new TextEncoder().encode(n).length;
  if (n instanceof URLSearchParams)
    return new TextEncoder().encode(n.toString()).length;
  if ("byteLength" in n)
    return n.byteLength;
  if (typeof n == "object" && n !== null)
    try {
      const e = JSON.stringify(n);
      return new TextEncoder().encode(e).length;
    } catch {
      return 0;
    }
  return 0;
}, GT = (n, e) => {
  const t = Number(n.headers.get("content-length")) || 0;
  let i = 0;
  return n.status === 204 ? (e && e({ percent: 1, totalBytes: t, transferredBytes: i }, new Uint8Array()), new Response(null, {
    status: n.status,
    statusText: n.statusText,
    headers: n.headers
  })) : new Response(new ReadableStream({
    async start(r) {
      const s = n.body.getReader();
      e && e({ percent: 0, transferredBytes: 0, totalBytes: t }, new Uint8Array());
      async function o() {
        const { done: a, value: l } = await s.read();
        if (a) {
          r.close();
          return;
        }
        if (e) {
          i += l.byteLength;
          const c = t === 0 ? 0 : i / t;
          e({ percent: c, transferredBytes: i, totalBytes: t }, l);
        }
        r.enqueue(l), await o();
      }
      await o();
    }
  }), {
    status: n.status,
    statusText: n.statusText,
    headers: n.headers
  });
}, UT = (n, e) => {
  const t = NT(n.body);
  let i = 0;
  return new Request(n, {
    // @ts-expect-error - Types are outdated.
    duplex: "half",
    body: new ReadableStream({
      async start(r) {
        const s = n.body instanceof ReadableStream ? n.body.getReader() : new Response("").body.getReader();
        async function o() {
          const { done: a, value: l } = await s.read();
          if (a) {
            e && e({ percent: 1, transferredBytes: i, totalBytes: Math.max(t, i) }, new Uint8Array()), r.close();
            return;
          }
          i += l.byteLength;
          let c = t === 0 ? 0 : i / t;
          (t < i || c === 1) && (c = 0.99), e && e({ percent: Number(c.toFixed(2)), transferredBytes: i, totalBytes: t }, l), r.enqueue(l), await o();
        }
        await o();
      }
    })
  });
}, Is = (n) => n !== null && typeof n == "object", Ko = (...n) => {
  for (const e of n)
    if ((!Is(e) || Array.isArray(e)) && e !== void 0)
      throw new TypeError("The `options` argument must be an object");
  return Tu({}, ...n);
}, km = (n = {}, e = {}) => {
  const t = new globalThis.Headers(n), i = e instanceof globalThis.Headers, r = new globalThis.Headers(e);
  for (const [s, o] of r.entries())
    i && o === "undefined" || o === void 0 ? t.delete(s) : t.set(s, o);
  return t;
};
function Zo(n, e, t) {
  return Object.hasOwn(e, t) && e[t] === void 0 ? [] : Tu(n[t] ?? [], e[t] ?? []);
}
const Nm = (n = {}, e = {}) => ({
  beforeRequest: Zo(n, e, "beforeRequest"),
  beforeRetry: Zo(n, e, "beforeRetry"),
  afterResponse: Zo(n, e, "afterResponse"),
  beforeError: Zo(n, e, "beforeError")
}), Tu = (...n) => {
  let e = {}, t = {}, i = {};
  for (const r of n)
    if (Array.isArray(r))
      Array.isArray(e) || (e = []), e = [...e, ...r];
    else if (Is(r)) {
      for (let [s, o] of Object.entries(r))
        Is(o) && s in e && (o = Tu(e[s], o)), e = { ...e, [s]: o };
      Is(r.hooks) && (i = Nm(i, r.hooks), e.hooks = i), Is(r.headers) && (t = km(t, r.headers), e.headers = t);
    }
  return e;
}, BT = (n) => Dm.includes(n) ? n.toUpperCase() : n, zT = ["get", "put", "head", "delete", "options", "trace"], WT = [408, 413, 429, 500, 502, 503, 504], YT = [413, 429, 503], _f = {
  limit: 2,
  methods: zT,
  statusCodes: WT,
  afterStatusCodes: YT,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (n) => 0.3 * 2 ** (n - 1) * 1e3
}, $T = (n = {}) => {
  if (typeof n == "number")
    return {
      ..._f,
      limit: n
    };
  if (n.methods && !Array.isArray(n.methods))
    throw new Error("retry.methods must be an array");
  if (n.statusCodes && !Array.isArray(n.statusCodes))
    throw new Error("retry.statusCodes must be an array");
  return {
    ..._f,
    ...n
  };
};
async function jT(n, e, t, i) {
  return new Promise((r, s) => {
    const o = setTimeout(() => {
      t && t.abort(), s(new Mm(n));
    }, i.timeout);
    i.fetch(n, e).then(r).catch(s).then(() => {
      clearTimeout(o);
    });
  });
}
async function VT(n, { signal: e }) {
  return new Promise((t, i) => {
    e && (e.throwIfAborted(), e.addEventListener("abort", r, { once: !0 }));
    function r() {
      clearTimeout(s), i(e.reason);
    }
    const s = setTimeout(() => {
      e == null || e.removeEventListener("abort", r), t();
    }, n);
  });
}
const XT = (n, e) => {
  const t = {};
  for (const i in e)
    !(i in kT) && !(i in FT) && !(i in n) && (t[i] = e[i]);
  return t;
};
class Ia {
  // eslint-disable-next-line complexity
  constructor(e, t = {}) {
    Jt(this, "request");
    Jt(this, "abortController");
    Jt(this, "_retryCount", 0);
    Jt(this, "_input");
    Jt(this, "_options");
    var i, r;
    if (this._input = e, this._options = {
      ...t,
      headers: km(this._input.headers, t.headers),
      hooks: Nm({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, t.hooks),
      method: BT(t.method ?? this._input.method ?? "GET"),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(t.prefixUrl || ""),
      retry: $T(t.retry),
      throwHttpErrors: t.throwHttpErrors !== !1,
      timeout: t.timeout ?? 1e4,
      fetch: t.fetch ?? globalThis.fetch.bind(globalThis)
    }, typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request))
      throw new TypeError("`input` must be a string, URL, or Request");
    if (this._options.prefixUrl && typeof this._input == "string") {
      if (this._input.startsWith("/"))
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"), this._input = this._options.prefixUrl + this._input;
    }
    if (IT && AT) {
      const s = this._options.signal ?? this._input.signal;
      this.abortController = new globalThis.AbortController(), this._options.signal = s ? AbortSignal.any([s, this.abortController.signal]) : this.abortController.signal;
    }
    if (mf && (this._options.duplex = "half"), this._options.json !== void 0 && (this._options.body = ((r = (i = this._options).stringifyJson) == null ? void 0 : r.call(i, this._options.json)) ?? JSON.stringify(this._options.json), this._options.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json")), this.request = new globalThis.Request(this._input, this._options), this._options.searchParams) {
      const o = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString()), a = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, o);
      (OT && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"), this.request = new globalThis.Request(new globalThis.Request(a, { ...this.request }), this._options);
    }
    if (this._options.onUploadProgress) {
      if (typeof this._options.onUploadProgress != "function")
        throw new TypeError("The `onUploadProgress` option must be a function");
      if (!mf)
        throw new Error("Request streams are not supported in your environment. The `duplex` option for `Request` is not available.");
      this.request.body && (this.request = UT(this.request, this._options.onUploadProgress));
    }
  }
  static create(e, t) {
    const i = new Ia(e, t), r = async () => {
      if (typeof i._options.timeout == "number" && i._options.timeout > uc)
        throw new RangeError(`The \`timeout\` option cannot be greater than ${uc}`);
      await Promise.resolve();
      let a = await i._fetch();
      for (const l of i._options.hooks.afterResponse) {
        const c = await l(i.request, i._options, i._decorateResponse(a.clone()));
        c instanceof globalThis.Response && (a = c);
      }
      if (i._decorateResponse(a), !a.ok && i._options.throwHttpErrors) {
        let l = new gf(a, i.request, i._options);
        for (const c of i._options.hooks.beforeError)
          l = await c(l);
        throw l;
      }
      if (i._options.onDownloadProgress) {
        if (typeof i._options.onDownloadProgress != "function")
          throw new TypeError("The `onDownloadProgress` option must be a function");
        if (!LT)
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        return GT(a.clone(), i._options.onDownloadProgress);
      }
      return a;
    }, o = (i._options.retry.methods.includes(i.request.method.toLowerCase()) ? i._retry(r) : r()).finally(async () => {
      var a;
      i.request.bodyUsed || await ((a = i.request.body) == null ? void 0 : a.cancel());
    });
    for (const [a, l] of Object.entries(MT))
      o[a] = async () => {
        i.request.headers.set("accept", i.request.headers.get("accept") || l);
        const c = await o;
        if (a === "json") {
          if (c.status === 204 || (await c.clone().arrayBuffer()).byteLength === 0)
            return "";
          if (t.parseJson)
            return t.parseJson(await c.text());
        }
        return c[a]();
      };
    return o;
  }
  _calculateRetryDelay(e) {
    if (this._retryCount++, this._retryCount > this._options.retry.limit || e instanceof Mm)
      throw e;
    if (e instanceof gf) {
      if (!this._options.retry.statusCodes.includes(e.response.status))
        throw e;
      const i = e.response.headers.get("Retry-After") ?? e.response.headers.get("RateLimit-Reset") ?? e.response.headers.get("X-RateLimit-Reset") ?? e.response.headers.get("X-Rate-Limit-Reset");
      if (i && this._options.retry.afterStatusCodes.includes(e.response.status)) {
        let r = Number(i) * 1e3;
        Number.isNaN(r) ? r = Date.parse(i) - Date.now() : r >= Date.parse("2024-01-01") && (r -= Date.now());
        const s = this._options.retry.maxRetryAfter ?? r;
        return r < s ? r : s;
      }
      if (e.response.status === 413)
        throw e;
    }
    const t = this._options.retry.delay(this._retryCount);
    return Math.min(this._options.retry.backoffLimit, t);
  }
  _decorateResponse(e) {
    return this._options.parseJson && (e.json = async () => this._options.parseJson(await e.text())), e;
  }
  async _retry(e) {
    try {
      return await e();
    } catch (t) {
      const i = Math.min(this._calculateRetryDelay(t), uc);
      if (this._retryCount < 1)
        throw t;
      await VT(i, { signal: this._options.signal });
      for (const r of this._options.hooks.beforeRetry)
        if (await r({
          request: this.request,
          options: this._options,
          error: t,
          retryCount: this._retryCount
        }) === Fm)
          return;
      return this._retry(e);
    }
  }
  async _fetch() {
    for (const i of this._options.hooks.beforeRequest) {
      const r = await i(this.request, this._options);
      if (r instanceof Request) {
        this.request = r;
        break;
      }
      if (r instanceof Response)
        return r;
    }
    const e = XT(this.request, this._options), t = this.request;
    return this.request = t.clone(), this._options.timeout === !1 ? this._options.fetch(t, e) : jT(t, e, this.abortController, this._options);
  }
}
/*! MIT License © Sindre Sorhus */
const th = (n) => {
  const e = (t, i) => Ia.create(t, Ko(n, i));
  for (const t of Dm)
    e[t] = (i, r) => Ia.create(i, Ko(n, r, { method: t }));
  return e.create = (t) => th(Ko(t)), e.extend = (t) => (typeof t == "function" && (t = t(n ?? {})), th(Ko(n, t))), e.stop = Fm, e;
}, HT = th(), KT = () => {
  const {
    cookieEnabled: n,
    deviceMemory: e,
    doNotTrack: t,
    hardwareConcurrency: i,
    language: r,
    languages: s,
    maxTouchPoints: o,
    platform: a,
    userAgent: l,
    vendor: c
  } = window.navigator, { width: h, height: u, colorDepth: d, pixelDepth: f } = window.screen, g = (/* @__PURE__ */ new Date()).getTimezoneOffset(), _ = Intl.DateTimeFormat().resolvedOptions().timeZone, m = "ontouchstart" in window, y = window.devicePixelRatio, p = ZT(), E = qT(), x = JT(), v = JSON.stringify(
    {
      canvas: p,
      colorDepth: d,
      cookieEnabled: n,
      deviceMemory: e,
      devicePixelRatio: y,
      doNotTrack: t,
      hardwareConcurrency: i,
      height: u,
      language: r,
      languages: s,
      maxTouchPoints: o,
      pixelDepth: f,
      platform: a,
      timezone: _,
      timezoneOffset: g,
      touchSupport: m,
      userAgent: l,
      vendor: c,
      webgl: E,
      webglInfo: x,
      width: h
    },
    null,
    8
  );
  return wu(JSON.stringify(v, null, 4));
}, ZT = () => {
  try {
    const n = document.createElement("canvas"), e = n.getContext("2d");
    if (!e) return null;
    const t = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~1!2@3#4$5%6^7&8*9(0)-_=+[{]}|;:',<.>/?";
    e.textBaseline = "top", e.font = "14px 'serif'", e.textBaseline = "alphabetic", e.fillStyle = "#f60", e.fillRect(125, 1, 62, 20), e.fillStyle = "#069", e.fillText(t, 2, 15), e.fillStyle = "rgba(102, 204, 0, 0.7)", e.fillText(t, 4, 17);
    const i = n.toDataURL();
    return e.clearRect(0, 0, n.width, n.height), wu(i);
  } catch {
    return null;
  }
}, qT = () => {
  try {
    const n = document.createElement("canvas"), e = n.getContext("webgl");
    if (!e) return null;
    n.width = 256, n.height = 128;
    const t = "attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}", i = "precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}", r = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, r);
    const s = new Float32Array([-0.2, -0.9, 0, 0.4, -0.26, 0, 0, 0.7321, 0]);
    e.bufferData(e.ARRAY_BUFFER, s, e.STATIC_DRAW), r.itemSize = 3, r.numItems = 3;
    const o = e.createProgram(), a = e.createShader(e.VERTEX_SHADER);
    e.shaderSource(a, t), e.compileShader(a);
    const l = e.createShader(e.FRAGMENT_SHADER);
    e.shaderSource(l, i), e.compileShader(l), e.attachShader(o, a), e.attachShader(o, l), e.linkProgram(o), e.useProgram(o), o.vertexPosAttrib = e.getAttribLocation(o, "attrVertex"), o.offsetUniform = e.getUniformLocation(o, "uniformOffset"), e.enableVertexAttribArray(o.vertexPosArray), e.vertexAttribPointer(o.vertexPosAttrib, r.itemSize, e.FLOAT, !1, 0, 0), e.uniform2f(o.offsetUniform, 1, 1), e.drawArrays(e.TRIANGLE_STRIP, 0, r.numItems);
    const c = new Uint8Array(n.width * n.height * 4);
    e.readPixels(
      0,
      0,
      n.width,
      n.height,
      e.RGBA,
      e.UNSIGNED_BYTE,
      c
    );
    const h = JSON.stringify(c).replace(/,?"[0-9]+":/g, "");
    return e.clear(
      e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT
    ), wu(h);
  } catch {
    return null;
  }
}, JT = () => {
  try {
    const n = document.createElement("canvas").getContext("webgl");
    return {
      VERSION: n.getParameter(n.VERSION),
      SHADING_LANGUAGE_VERSION: n.getParameter(n.SHADING_LANGUAGE_VERSION),
      VENDOR: n.getParameter(n.VENDOR),
      SUPORTED_EXTENSIONS: n.getSupportedExtensions()
    };
  } catch {
    return null;
  }
}, wu = (n) => {
  const e = n.length & 3, t = n.length - e, i = 3432918353, r = 461845907;
  let s = 0, o, a;
  for (let c = 0; c < t; c++)
    a = n.charCodeAt(c) & 255 | (n.charCodeAt(++c) & 255) << 8 | (n.charCodeAt(++c) & 255) << 16 | (n.charCodeAt(++c) & 255) << 24, ++c, a = (a & 65535) * i + (((a >>> 16) * i & 65535) << 16) & 4294967295, a = a << 15 | a >>> 17, a = (a & 65535) * r + (((a >>> 16) * r & 65535) << 16) & 4294967295, s ^= a, s = s << 13 | s >>> 19, o = (s & 65535) * 5 + (((s >>> 16) * 5 & 65535) << 16) & 4294967295, s = (o & 65535) + 27492 + (((o >>> 16) + 58964 & 65535) << 16);
  const l = t - 1;
  switch (a = 0, e) {
    case 3: {
      a ^= (n.charCodeAt(l + 2) & 255) << 16;
      break;
    }
    case 2: {
      a ^= (n.charCodeAt(l + 1) & 255) << 8;
      break;
    }
    case 1: {
      a ^= n.charCodeAt(l) & 255;
      break;
    }
  }
  return a = (a & 65535) * i + (((a >>> 16) * i & 65535) << 16) & 4294967295, a = a << 15 | a >>> 17, a = (a & 65535) * r + (((a >>> 16) * r & 65535) << 16) & 4294967295, s ^= a, s ^= n.length, s ^= s >>> 16, s = (s & 65535) * 2246822507 + (((s >>> 16) * 2246822507 & 65535) << 16) & 4294967295, s ^= s >>> 13, s = (s & 65535) * 3266489909 + (((s >>> 16) * 3266489909 & 65535) << 16) & 4294967295, s ^= s >>> 16, s >>> 0;
};
let dc;
const Gm = () => (dc || (dc = KT().toString()), dc);
function Um(n, e) {
  return function() {
    return n.apply(e, arguments);
  };
}
const { toString: QT } = Object.prototype, { getPrototypeOf: Su } = Object, { iterator: hl, toStringTag: Bm } = Symbol, ul = /* @__PURE__ */ ((n) => (e) => {
  const t = QT.call(e);
  return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), un = (n) => (n = n.toLowerCase(), (e) => ul(e) === n), dl = (n) => (e) => typeof e === n, { isArray: ts } = Array, Js = dl("undefined");
function vo(n) {
  return n !== null && !Js(n) && n.constructor !== null && !Js(n.constructor) && Ot(n.constructor.isBuffer) && n.constructor.isBuffer(n);
}
const zm = un("ArrayBuffer");
function ew(n) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && zm(n.buffer), e;
}
const tw = dl("string"), Ot = dl("function"), Wm = dl("number"), Eo = (n) => n !== null && typeof n == "object", nw = (n) => n === !0 || n === !1, ta = (n) => {
  if (ul(n) !== "object")
    return !1;
  const e = Su(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Bm in n) && !(hl in n);
}, iw = (n) => {
  if (!Eo(n) || vo(n))
    return !1;
  try {
    return Object.keys(n).length === 0 && Object.getPrototypeOf(n) === Object.prototype;
  } catch {
    return !1;
  }
}, rw = un("Date"), sw = un("File"), ow = un("Blob"), aw = un("FileList"), lw = (n) => Eo(n) && Ot(n.pipe), cw = (n) => {
  let e;
  return n && (typeof FormData == "function" && n instanceof FormData || Ot(n.append) && ((e = ul(n)) === "formdata" || // detect form-data instance
  e === "object" && Ot(n.toString) && n.toString() === "[object FormData]"));
}, hw = un("URLSearchParams"), [uw, dw, fw, gw] = ["ReadableStream", "Request", "Response", "Headers"].map(un), mw = (n) => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function To(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > "u")
    return;
  let i, r;
  if (typeof n != "object" && (n = [n]), ts(n))
    for (i = 0, r = n.length; i < r; i++)
      e.call(null, n[i], i, n);
  else {
    if (vo(n))
      return;
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n), o = s.length;
    let a;
    for (i = 0; i < o; i++)
      a = s[i], e.call(null, n[a], a, n);
  }
}
function Ym(n, e) {
  if (vo(n))
    return null;
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length, r;
  for (; i-- > 0; )
    if (r = t[i], e === r.toLowerCase())
      return r;
  return null;
}
const Yi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, $m = (n) => !Js(n) && n !== Yi;
function nh() {
  const { caseless: n } = $m(this) && this || {}, e = {}, t = (i, r) => {
    const s = n && Ym(e, r) || r;
    ta(e[s]) && ta(i) ? e[s] = nh(e[s], i) : ta(i) ? e[s] = nh({}, i) : ts(i) ? e[s] = i.slice() : e[s] = i;
  };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && To(arguments[i], t);
  return e;
}
const _w = (n, e, t, { allOwnKeys: i } = {}) => (To(e, (r, s) => {
  t && Ot(r) ? n[s] = Um(r, t) : n[s] = r;
}, { allOwnKeys: i }), n), pw = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), yw = (n, e, t, i) => {
  n.prototype = Object.create(e.prototype, i), n.prototype.constructor = n, Object.defineProperty(n, "super", {
    value: e.prototype
  }), t && Object.assign(n.prototype, t);
}, xw = (n, e, t, i) => {
  let r, s, o;
  const a = {};
  if (e = e || {}, n == null) return e;
  do {
    for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
      o = r[s], (!i || i(o, n, e)) && !a[o] && (e[o] = n[o], a[o] = !0);
    n = t !== !1 && Su(n);
  } while (n && (!t || t(n, e)) && n !== Object.prototype);
  return e;
}, vw = (n, e, t) => {
  n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
  const i = n.indexOf(e, t);
  return i !== -1 && i === t;
}, Ew = (n) => {
  if (!n) return null;
  if (ts(n)) return n;
  let e = n.length;
  if (!Wm(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = n[e];
  return t;
}, Tw = /* @__PURE__ */ ((n) => (e) => n && e instanceof n)(typeof Uint8Array < "u" && Su(Uint8Array)), ww = (n, e) => {
  const i = (n && n[hl]).call(n);
  let r;
  for (; (r = i.next()) && !r.done; ) {
    const s = r.value;
    e.call(n, s[0], s[1]);
  }
}, Sw = (n, e) => {
  let t;
  const i = [];
  for (; (t = n.exec(e)) !== null; )
    i.push(t);
  return i;
}, bw = un("HTMLFormElement"), Rw = (n) => n.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, i, r) {
    return i.toUpperCase() + r;
  }
), pf = (({ hasOwnProperty: n }) => (e, t) => n.call(e, t))(Object.prototype), Cw = un("RegExp"), jm = (n, e) => {
  const t = Object.getOwnPropertyDescriptors(n), i = {};
  To(t, (r, s) => {
    let o;
    (o = e(r, s, n)) !== !1 && (i[s] = o || r);
  }), Object.defineProperties(n, i);
}, Pw = (n) => {
  jm(n, (e, t) => {
    if (Ot(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const i = n[t];
    if (Ot(i)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, Iw = (n, e) => {
  const t = {}, i = (r) => {
    r.forEach((s) => {
      t[s] = !0;
    });
  };
  return ts(n) ? i(n) : i(String(n).split(e)), t;
}, Aw = () => {
}, Lw = (n, e) => n != null && Number.isFinite(n = +n) ? n : e;
function Ow(n) {
  return !!(n && Ot(n.append) && n[Bm] === "FormData" && n[hl]);
}
const Mw = (n) => {
  const e = new Array(10), t = (i, r) => {
    if (Eo(i)) {
      if (e.indexOf(i) >= 0)
        return;
      if (vo(i))
        return i;
      if (!("toJSON" in i)) {
        e[r] = i;
        const s = ts(i) ? [] : {};
        return To(i, (o, a) => {
          const l = t(o, r + 1);
          !Js(l) && (s[a] = l);
        }), e[r] = void 0, s;
      }
    }
    return i;
  };
  return t(n, 0);
}, Dw = un("AsyncFunction"), Fw = (n) => n && (Eo(n) || Ot(n)) && Ot(n.then) && Ot(n.catch), Vm = ((n, e) => n ? setImmediate : e ? ((t, i) => (Yi.addEventListener("message", ({ source: r, data: s }) => {
  r === Yi && s === t && i.length && i.shift()();
}, !1), (r) => {
  i.push(r), Yi.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(
  typeof setImmediate == "function",
  Ot(Yi.postMessage)
), kw = typeof queueMicrotask < "u" ? queueMicrotask.bind(Yi) : typeof process < "u" && process.nextTick || Vm, Nw = (n) => n != null && Ot(n[hl]), C = {
  isArray: ts,
  isArrayBuffer: zm,
  isBuffer: vo,
  isFormData: cw,
  isArrayBufferView: ew,
  isString: tw,
  isNumber: Wm,
  isBoolean: nw,
  isObject: Eo,
  isPlainObject: ta,
  isEmptyObject: iw,
  isReadableStream: uw,
  isRequest: dw,
  isResponse: fw,
  isHeaders: gw,
  isUndefined: Js,
  isDate: rw,
  isFile: sw,
  isBlob: ow,
  isRegExp: Cw,
  isFunction: Ot,
  isStream: lw,
  isURLSearchParams: hw,
  isTypedArray: Tw,
  isFileList: aw,
  forEach: To,
  merge: nh,
  extend: _w,
  trim: mw,
  stripBOM: pw,
  inherits: yw,
  toFlatObject: xw,
  kindOf: ul,
  kindOfTest: un,
  endsWith: vw,
  toArray: Ew,
  forEachEntry: ww,
  matchAll: Sw,
  isHTMLForm: bw,
  hasOwnProperty: pf,
  hasOwnProp: pf,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: jm,
  freezeMethods: Pw,
  toObjectSet: Iw,
  toCamelCase: Rw,
  noop: Aw,
  toFiniteNumber: Lw,
  findKey: Ym,
  global: Yi,
  isContextDefined: $m,
  isSpecCompliantForm: Ow,
  toJSONObject: Mw,
  isAsyncFn: Dw,
  isThenable: Fw,
  setImmediate: Vm,
  asap: kw,
  isIterable: Nw
};
function se(n, e, t, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), r && (this.response = r, this.status = r.status ? r.status : null);
}
C.inherits(se, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: C.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Xm = se.prototype, Hm = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((n) => {
  Hm[n] = { value: n };
});
Object.defineProperties(se, Hm);
Object.defineProperty(Xm, "isAxiosError", { value: !0 });
se.from = (n, e, t, i, r, s) => {
  const o = Object.create(Xm);
  return C.toFlatObject(n, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), se.call(o, n.message, e, t, i, r), o.cause = n, o.name = n.name, s && Object.assign(o, s), o;
};
const Gw = null;
function ih(n) {
  return C.isPlainObject(n) || C.isArray(n);
}
function Km(n) {
  return C.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function yf(n, e, t) {
  return n ? n.concat(e).map(function(r, s) {
    return r = Km(r), !t && s ? "[" + r + "]" : r;
  }).join(t ? "." : "") : e;
}
function Uw(n) {
  return C.isArray(n) && !n.some(ih);
}
const Bw = C.toFlatObject(C, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function fl(n, e, t) {
  if (!C.isObject(n))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = C.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(_, m) {
    return !C.isUndefined(m[_]);
  });
  const i = t.metaTokens, r = t.visitor || h, s = t.dots, o = t.indexes, l = (t.Blob || typeof Blob < "u" && Blob) && C.isSpecCompliantForm(e);
  if (!C.isFunction(r))
    throw new TypeError("visitor must be a function");
  function c(g) {
    if (g === null) return "";
    if (C.isDate(g))
      return g.toISOString();
    if (C.isBoolean(g))
      return g.toString();
    if (!l && C.isBlob(g))
      throw new se("Blob is not supported. Use a Buffer instead.");
    return C.isArrayBuffer(g) || C.isTypedArray(g) ? l && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
  function h(g, _, m) {
    let y = g;
    if (g && !m && typeof g == "object") {
      if (C.endsWith(_, "{}"))
        _ = i ? _ : _.slice(0, -2), g = JSON.stringify(g);
      else if (C.isArray(g) && Uw(g) || (C.isFileList(g) || C.endsWith(_, "[]")) && (y = C.toArray(g)))
        return _ = Km(_), y.forEach(function(E, x) {
          !(C.isUndefined(E) || E === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? yf([_], x, s) : o === null ? _ : _ + "[]",
            c(E)
          );
        }), !1;
    }
    return ih(g) ? !0 : (e.append(yf(m, _, s), c(g)), !1);
  }
  const u = [], d = Object.assign(Bw, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: ih
  });
  function f(g, _) {
    if (!C.isUndefined(g)) {
      if (u.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + _.join("."));
      u.push(g), C.forEach(g, function(y, p) {
        (!(C.isUndefined(y) || y === null) && r.call(
          e,
          y,
          C.isString(p) ? p.trim() : p,
          _,
          d
        )) === !0 && f(y, _ ? _.concat(p) : [p]);
      }), u.pop();
    }
  }
  if (!C.isObject(n))
    throw new TypeError("data must be an object");
  return f(n), e;
}
function xf(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(i) {
    return e[i];
  });
}
function bu(n, e) {
  this._pairs = [], n && fl(n, this, e);
}
const Zm = bu.prototype;
Zm.append = function(e, t) {
  this._pairs.push([e, t]);
};
Zm.toString = function(e) {
  const t = e ? function(i) {
    return e.call(this, i, xf);
  } : xf;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function zw(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function qm(n, e, t) {
  if (!e)
    return n;
  const i = t && t.encode || zw;
  C.isFunction(t) && (t = {
    serialize: t
  });
  const r = t && t.serialize;
  let s;
  if (r ? s = r(e, t) : s = C.isURLSearchParams(e) ? e.toString() : new bu(e, t).toString(i), s) {
    const o = n.indexOf("#");
    o !== -1 && (n = n.slice(0, o)), n += (n.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return n;
}
class vf {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, i) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    C.forEach(this.handlers, function(i) {
      i !== null && e(i);
    });
  }
}
const Jm = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Ww = typeof URLSearchParams < "u" ? URLSearchParams : bu, Yw = typeof FormData < "u" ? FormData : null, $w = typeof Blob < "u" ? Blob : null, jw = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Ww,
    FormData: Yw,
    Blob: $w
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Ru = typeof window < "u" && typeof document < "u", rh = typeof navigator == "object" && navigator || void 0, Vw = Ru && (!rh || ["ReactNative", "NativeScript", "NS"].indexOf(rh.product) < 0), Xw = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Hw = Ru && window.location.href || "http://localhost", Kw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ru,
  hasStandardBrowserEnv: Vw,
  hasStandardBrowserWebWorkerEnv: Xw,
  navigator: rh,
  origin: Hw
}, Symbol.toStringTag, { value: "Module" })), ht = {
  ...Kw,
  ...jw
};
function Zw(n, e) {
  return fl(n, new ht.classes.URLSearchParams(), {
    visitor: function(t, i, r, s) {
      return ht.isNode && C.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function qw(n) {
  return C.matchAll(/\w+|\[(\w*)]/g, n).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Jw(n) {
  const e = {}, t = Object.keys(n);
  let i;
  const r = t.length;
  let s;
  for (i = 0; i < r; i++)
    s = t[i], e[s] = n[s];
  return e;
}
function Qm(n) {
  function e(t, i, r, s) {
    let o = t[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), l = s >= t.length;
    return o = !o && C.isArray(r) ? r.length : o, l ? (C.hasOwnProp(r, o) ? r[o] = [r[o], i] : r[o] = i, !a) : ((!r[o] || !C.isObject(r[o])) && (r[o] = []), e(t, i, r[o], s) && C.isArray(r[o]) && (r[o] = Jw(r[o])), !a);
  }
  if (C.isFormData(n) && C.isFunction(n.entries)) {
    const t = {};
    return C.forEachEntry(n, (i, r) => {
      e(qw(i), r, t, 0);
    }), t;
  }
  return null;
}
function Qw(n, e, t) {
  if (C.isString(n))
    try {
      return (e || JSON.parse)(n), C.trim(n);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (t || JSON.stringify)(n);
}
const wo = {
  transitional: Jm,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const i = t.getContentType() || "", r = i.indexOf("application/json") > -1, s = C.isObject(e);
    if (s && C.isHTMLForm(e) && (e = new FormData(e)), C.isFormData(e))
      return r ? JSON.stringify(Qm(e)) : e;
    if (C.isArrayBuffer(e) || C.isBuffer(e) || C.isStream(e) || C.isFile(e) || C.isBlob(e) || C.isReadableStream(e))
      return e;
    if (C.isArrayBufferView(e))
      return e.buffer;
    if (C.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return Zw(e, this.formSerializer).toString();
      if ((a = C.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return fl(
          a ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || r ? (t.setContentType("application/json", !1), Qw(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || wo.transitional, i = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (C.isResponse(e) || C.isReadableStream(e))
      return e;
    if (e && C.isString(e) && (i && !this.responseType || r)) {
      const o = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? se.from(a, se.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ht.classes.FormData,
    Blob: ht.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
C.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  wo.headers[n] = {};
});
const eS = C.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), tS = (n) => {
  const e = {};
  let t, i, r;
  return n && n.split(`
`).forEach(function(o) {
    r = o.indexOf(":"), t = o.substring(0, r).trim().toLowerCase(), i = o.substring(r + 1).trim(), !(!t || e[t] && eS[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i);
  }), e;
}, Ef = Symbol("internals");
function Es(n) {
  return n && String(n).trim().toLowerCase();
}
function na(n) {
  return n === !1 || n == null ? n : C.isArray(n) ? n.map(na) : String(n);
}
function nS(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = t.exec(n); )
    e[i[1]] = i[2];
  return e;
}
const iS = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function fc(n, e, t, i, r) {
  if (C.isFunction(i))
    return i.call(this, e, t);
  if (r && (e = t), !!C.isString(e)) {
    if (C.isString(i))
      return e.indexOf(i) !== -1;
    if (C.isRegExp(i))
      return i.test(e);
  }
}
function rS(n) {
  return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function sS(n, e) {
  const t = C.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function(r, s, o) {
        return this[i].call(this, e, r, s, o);
      },
      configurable: !0
    });
  });
}
let Mt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function s(a, l, c) {
      const h = Es(l);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const u = C.findKey(r, h);
      (!u || r[u] === void 0 || c === !0 || c === void 0 && r[u] !== !1) && (r[u || l] = na(a));
    }
    const o = (a, l) => C.forEach(a, (c, h) => s(c, h, l));
    if (C.isPlainObject(e) || e instanceof this.constructor)
      o(e, t);
    else if (C.isString(e) && (e = e.trim()) && !iS(e))
      o(tS(e), t);
    else if (C.isObject(e) && C.isIterable(e)) {
      let a = {}, l, c;
      for (const h of e) {
        if (!C.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        a[c = h[0]] = (l = a[c]) ? C.isArray(l) ? [...l, h[1]] : [l, h[1]] : h[1];
      }
      o(a, t);
    } else
      e != null && s(t, e, i);
    return this;
  }
  get(e, t) {
    if (e = Es(e), e) {
      const i = C.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t)
          return r;
        if (t === !0)
          return nS(r);
        if (C.isFunction(t))
          return t.call(this, r, i);
        if (C.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Es(e), e) {
      const i = C.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || fc(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function s(o) {
      if (o = Es(o), o) {
        const a = C.findKey(i, o);
        a && (!t || fc(i, i[a], a, t)) && (delete i[a], r = !0);
      }
    }
    return C.isArray(e) ? e.forEach(s) : s(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length, r = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || fc(this, this[s], s, e, !0)) && (delete this[s], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, i = {};
    return C.forEach(this, (r, s) => {
      const o = C.findKey(i, s);
      if (o) {
        t[o] = na(r), delete t[s];
        return;
      }
      const a = e ? rS(s) : String(s).trim();
      a !== s && delete t[s], t[a] = na(r), i[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return C.forEach(this, (i, r) => {
      i != null && i !== !1 && (t[r] = e && C.isArray(i) ? i.join(", ") : i);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return t.forEach((r) => i.set(r)), i;
  }
  static accessor(e) {
    const i = (this[Ef] = this[Ef] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function s(o) {
      const a = Es(o);
      i[a] || (sS(r, o), i[a] = !0);
    }
    return C.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
Mt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
C.reduceDescriptors(Mt.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => n,
    set(i) {
      this[t] = i;
    }
  };
});
C.freezeMethods(Mt);
function gc(n, e) {
  const t = this || wo, i = e || t, r = Mt.from(i.headers);
  let s = i.data;
  return C.forEach(n, function(a) {
    s = a.call(t, s, r.normalize(), e ? e.status : void 0);
  }), r.normalize(), s;
}
function e_(n) {
  return !!(n && n.__CANCEL__);
}
function ns(n, e, t) {
  se.call(this, n ?? "canceled", se.ERR_CANCELED, e, t), this.name = "CanceledError";
}
C.inherits(ns, se, {
  __CANCEL__: !0
});
function t_(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status) ? n(t) : e(new se(
    "Request failed with status code " + t.status,
    [se.ERR_BAD_REQUEST, se.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
function oS(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return e && e[1] || "";
}
function aS(n, e) {
  n = n || 10;
  const t = new Array(n), i = new Array(n);
  let r = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const c = Date.now(), h = i[s];
    o || (o = c), t[r] = l, i[r] = c;
    let u = s, d = 0;
    for (; u !== r; )
      d += t[u++], u = u % n;
    if (r = (r + 1) % n, r === s && (s = (s + 1) % n), c - o < e)
      return;
    const f = h && c - h;
    return f ? Math.round(d * 1e3 / f) : void 0;
  };
}
function lS(n, e) {
  let t = 0, i = 1e3 / e, r, s;
  const o = (c, h = Date.now()) => {
    t = h, r = null, s && (clearTimeout(s), s = null), n(...c);
  };
  return [(...c) => {
    const h = Date.now(), u = h - t;
    u >= i ? o(c, h) : (r = c, s || (s = setTimeout(() => {
      s = null, o(r);
    }, i - u)));
  }, () => r && o(r)];
}
const Aa = (n, e, t = 3) => {
  let i = 0;
  const r = aS(50, 250);
  return lS((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, l = o - i, c = r(l), h = o <= a;
    i = o;
    const u = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && h ? (a - o) / c : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    n(u);
  }, t);
}, Tf = (n, e) => {
  const t = n != null;
  return [(i) => e[0]({
    lengthComputable: t,
    total: n,
    loaded: i
  }), e[1]];
}, wf = (n) => (...e) => C.asap(() => n(...e)), cS = ht.hasStandardBrowserEnv ? /* @__PURE__ */ ((n, e) => (t) => (t = new URL(t, ht.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(
  new URL(ht.origin),
  ht.navigator && /(msie|trident)/i.test(ht.navigator.userAgent)
) : () => !0, hS = ht.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(n, e, t, i, r, s) {
      const o = [n + "=" + encodeURIComponent(e)];
      C.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()), C.isString(i) && o.push("path=" + i), C.isString(r) && o.push("domain=" + r), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(n) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(n) {
      this.write(n, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function uS(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function dS(n, e) {
  return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function n_(n, e, t) {
  let i = !uS(e);
  return n && (i || t == !1) ? dS(n, e) : e;
}
const Sf = (n) => n instanceof Mt ? { ...n } : n;
function rr(n, e) {
  e = e || {};
  const t = {};
  function i(c, h, u, d) {
    return C.isPlainObject(c) && C.isPlainObject(h) ? C.merge.call({ caseless: d }, c, h) : C.isPlainObject(h) ? C.merge({}, h) : C.isArray(h) ? h.slice() : h;
  }
  function r(c, h, u, d) {
    if (C.isUndefined(h)) {
      if (!C.isUndefined(c))
        return i(void 0, c, u, d);
    } else return i(c, h, u, d);
  }
  function s(c, h) {
    if (!C.isUndefined(h))
      return i(void 0, h);
  }
  function o(c, h) {
    if (C.isUndefined(h)) {
      if (!C.isUndefined(c))
        return i(void 0, c);
    } else return i(void 0, h);
  }
  function a(c, h, u) {
    if (u in e)
      return i(c, h);
    if (u in n)
      return i(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, h, u) => r(Sf(c), Sf(h), u, !0)
  };
  return C.forEach(Object.keys({ ...n, ...e }), function(h) {
    const u = l[h] || r, d = u(n[h], e[h], h);
    C.isUndefined(d) && u !== a || (t[h] = d);
  }), t;
}
const i_ = (n) => {
  const e = rr({}, n);
  let { data: t, withXSRFToken: i, xsrfHeaderName: r, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = Mt.from(o), e.url = qm(n_(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (C.isFormData(t)) {
    if (ht.hasStandardBrowserEnv || ht.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...h] = l ? l.split(";").map((u) => u.trim()).filter(Boolean) : [];
      o.setContentType([c || "multipart/form-data", ...h].join("; "));
    }
  }
  if (ht.hasStandardBrowserEnv && (i && C.isFunction(i) && (i = i(e)), i || i !== !1 && cS(e.url))) {
    const c = r && s && hS.read(s);
    c && o.set(r, c);
  }
  return e;
}, fS = typeof XMLHttpRequest < "u", gS = fS && function(n) {
  return new Promise(function(t, i) {
    const r = i_(n);
    let s = r.data;
    const o = Mt.from(r.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = r, h, u, d, f, g;
    function _() {
      f && f(), g && g(), r.cancelToken && r.cancelToken.unsubscribe(h), r.signal && r.signal.removeEventListener("abort", h);
    }
    let m = new XMLHttpRequest();
    m.open(r.method.toUpperCase(), r.url, !0), m.timeout = r.timeout;
    function y() {
      if (!m)
        return;
      const E = Mt.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), v = {
        data: !a || a === "text" || a === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: E,
        config: n,
        request: m
      };
      t_(function(w) {
        t(w), _();
      }, function(w) {
        i(w), _();
      }, v), m = null;
    }
    "onloadend" in m ? m.onloadend = y : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(y);
    }, m.onabort = function() {
      m && (i(new se("Request aborted", se.ECONNABORTED, n, m)), m = null);
    }, m.onerror = function() {
      i(new se("Network Error", se.ERR_NETWORK, n, m)), m = null;
    }, m.ontimeout = function() {
      let x = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const v = r.transitional || Jm;
      r.timeoutErrorMessage && (x = r.timeoutErrorMessage), i(new se(
        x,
        v.clarifyTimeoutError ? se.ETIMEDOUT : se.ECONNABORTED,
        n,
        m
      )), m = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in m && C.forEach(o.toJSON(), function(x, v) {
      m.setRequestHeader(v, x);
    }), C.isUndefined(r.withCredentials) || (m.withCredentials = !!r.withCredentials), a && a !== "json" && (m.responseType = r.responseType), c && ([d, g] = Aa(c, !0), m.addEventListener("progress", d)), l && m.upload && ([u, f] = Aa(l), m.upload.addEventListener("progress", u), m.upload.addEventListener("loadend", f)), (r.cancelToken || r.signal) && (h = (E) => {
      m && (i(!E || E.type ? new ns(null, n, m) : E), m.abort(), m = null);
    }, r.cancelToken && r.cancelToken.subscribe(h), r.signal && (r.signal.aborted ? h() : r.signal.addEventListener("abort", h)));
    const p = oS(r.url);
    if (p && ht.protocols.indexOf(p) === -1) {
      i(new se("Unsupported protocol " + p + ":", se.ERR_BAD_REQUEST, n));
      return;
    }
    m.send(s || null);
  });
}, mS = (n, e) => {
  const { length: t } = n = n ? n.filter(Boolean) : [];
  if (e || t) {
    let i = new AbortController(), r;
    const s = function(c) {
      if (!r) {
        r = !0, a();
        const h = c instanceof Error ? c : this.reason;
        i.abort(h instanceof se ? h : new ns(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new se(`timeout ${e} of ms exceeded`, se.ETIMEDOUT));
    }, e);
    const a = () => {
      n && (o && clearTimeout(o), o = null, n.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s);
      }), n = null);
    };
    n.forEach((c) => c.addEventListener("abort", s));
    const { signal: l } = i;
    return l.unsubscribe = () => C.asap(a), l;
  }
}, _S = function* (n, e) {
  let t = n.byteLength;
  if (t < e) {
    yield n;
    return;
  }
  let i = 0, r;
  for (; i < t; )
    r = i + e, yield n.slice(i, r), i = r;
}, pS = async function* (n, e) {
  for await (const t of yS(n))
    yield* _S(t, e);
}, yS = async function* (n) {
  if (n[Symbol.asyncIterator]) {
    yield* n;
    return;
  }
  const e = n.getReader();
  try {
    for (; ; ) {
      const { done: t, value: i } = await e.read();
      if (t)
        break;
      yield i;
    }
  } finally {
    await e.cancel();
  }
}, bf = (n, e, t, i) => {
  const r = pS(n, e);
  let s = 0, o, a = (l) => {
    o || (o = !0, i && i(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: h } = await r.next();
        if (c) {
          a(), l.close();
          return;
        }
        let u = h.byteLength;
        if (t) {
          let d = s += u;
          t(d);
        }
        l.enqueue(new Uint8Array(h));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), r.return();
    }
  }, {
    highWaterMark: 2
  });
}, gl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", r_ = gl && typeof ReadableStream == "function", xS = gl && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((n) => (e) => n.encode(e))(new TextEncoder()) : async (n) => new Uint8Array(await new Response(n).arrayBuffer())), s_ = (n, ...e) => {
  try {
    return !!n(...e);
  } catch {
    return !1;
  }
}, vS = r_ && s_(() => {
  let n = !1;
  const e = new Request(ht.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return n = !0, "half";
    }
  }).headers.has("Content-Type");
  return n && !e;
}), Rf = 64 * 1024, sh = r_ && s_(() => C.isReadableStream(new Response("").body)), La = {
  stream: sh && ((n) => n.body)
};
gl && ((n) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !La[e] && (La[e] = C.isFunction(n[e]) ? (t) => t[e]() : (t, i) => {
      throw new se(`Response type '${e}' is not supported`, se.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const ES = async (n) => {
  if (n == null)
    return 0;
  if (C.isBlob(n))
    return n.size;
  if (C.isSpecCompliantForm(n))
    return (await new Request(ht.origin, {
      method: "POST",
      body: n
    }).arrayBuffer()).byteLength;
  if (C.isArrayBufferView(n) || C.isArrayBuffer(n))
    return n.byteLength;
  if (C.isURLSearchParams(n) && (n = n + ""), C.isString(n))
    return (await xS(n)).byteLength;
}, TS = async (n, e) => {
  const t = C.toFiniteNumber(n.getContentLength());
  return t ?? ES(e);
}, wS = gl && (async (n) => {
  let {
    url: e,
    method: t,
    data: i,
    signal: r,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: h,
    withCredentials: u = "same-origin",
    fetchOptions: d
  } = i_(n);
  c = c ? (c + "").toLowerCase() : "text";
  let f = mS([r, s && s.toAbortSignal()], o), g;
  const _ = f && f.unsubscribe && (() => {
    f.unsubscribe();
  });
  let m;
  try {
    if (l && vS && t !== "get" && t !== "head" && (m = await TS(h, i)) !== 0) {
      let v = new Request(e, {
        method: "POST",
        body: i,
        duplex: "half"
      }), S;
      if (C.isFormData(i) && (S = v.headers.get("content-type")) && h.setContentType(S), v.body) {
        const [w, b] = Tf(
          m,
          Aa(wf(l))
        );
        i = bf(v.body, Rf, w, b);
      }
    }
    C.isString(u) || (u = u ? "include" : "omit");
    const y = "credentials" in Request.prototype;
    g = new Request(e, {
      ...d,
      signal: f,
      method: t.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: i,
      duplex: "half",
      credentials: y ? u : void 0
    });
    let p = await fetch(g, d);
    const E = sh && (c === "stream" || c === "response");
    if (sh && (a || E && _)) {
      const v = {};
      ["status", "statusText", "headers"].forEach((P) => {
        v[P] = p[P];
      });
      const S = C.toFiniteNumber(p.headers.get("content-length")), [w, b] = a && Tf(
        S,
        Aa(wf(a), !0)
      ) || [];
      p = new Response(
        bf(p.body, Rf, w, () => {
          b && b(), _ && _();
        }),
        v
      );
    }
    c = c || "text";
    let x = await La[C.findKey(La, c) || "text"](p, n);
    return !E && _ && _(), await new Promise((v, S) => {
      t_(v, S, {
        data: x,
        headers: Mt.from(p.headers),
        status: p.status,
        statusText: p.statusText,
        config: n,
        request: g
      });
    });
  } catch (y) {
    throw _ && _(), y && y.name === "TypeError" && /Load failed|fetch/i.test(y.message) ? Object.assign(
      new se("Network Error", se.ERR_NETWORK, n, g),
      {
        cause: y.cause || y
      }
    ) : se.from(y, y && y.code, n, g);
  }
}), oh = {
  http: Gw,
  xhr: gS,
  fetch: wS
};
C.forEach(oh, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", { value: e });
    } catch {
    }
    Object.defineProperty(n, "adapterName", { value: e });
  }
});
const Cf = (n) => `- ${n}`, SS = (n) => C.isFunction(n) || n === null || n === !1, o_ = {
  getAdapter: (n) => {
    n = C.isArray(n) ? n : [n];
    const { length: e } = n;
    let t, i;
    const r = {};
    for (let s = 0; s < e; s++) {
      t = n[s];
      let o;
      if (i = t, !SS(t) && (i = oh[(o = String(t)).toLowerCase()], i === void 0))
        throw new se(`Unknown adapter '${o}'`);
      if (i)
        break;
      r[o || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(r).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(Cf).join(`
`) : " " + Cf(s[0]) : "as no adapter specified";
      throw new se(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: oh
};
function mc(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new ns(null, n);
}
function Pf(n) {
  return mc(n), n.headers = Mt.from(n.headers), n.data = gc.call(
    n,
    n.transformRequest
  ), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), o_.getAdapter(n.adapter || wo.adapter)(n).then(function(i) {
    return mc(n), i.data = gc.call(
      n,
      n.transformResponse,
      i
    ), i.headers = Mt.from(i.headers), i;
  }, function(i) {
    return e_(i) || (mc(n), i && i.response && (i.response.data = gc.call(
      n,
      n.transformResponse,
      i.response
    ), i.response.headers = Mt.from(i.response.headers))), Promise.reject(i);
  });
}
const a_ = "1.11.0", ml = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
  ml[n] = function(i) {
    return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
const If = {};
ml.transitional = function(e, t, i) {
  function r(s, o) {
    return "[Axios v" + a_ + "] Transitional option '" + s + "'" + o + (i ? ". " + i : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new se(
        r(o, " has been removed" + (t ? " in " + t : "")),
        se.ERR_DEPRECATED
      );
    return t && !If[o] && (If[o] = !0, console.warn(
      r(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
ml.spelling = function(e) {
  return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0);
};
function bS(n, e, t) {
  if (typeof n != "object")
    throw new se("options must be an object", se.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r], o = e[s];
    if (o) {
      const a = n[s], l = a === void 0 || o(a, s, n);
      if (l !== !0)
        throw new se("option " + s + " must be " + l, se.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new se("Unknown option " + s, se.ERR_BAD_OPTION);
  }
}
const ia = {
  assertOptions: bS,
  validators: ml
}, pn = ia.validators;
let qi = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new vf(),
      response: new vf()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const s = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = rr(this.defaults, t);
    const { transitional: i, paramsSerializer: r, headers: s } = t;
    i !== void 0 && ia.assertOptions(i, {
      silentJSONParsing: pn.transitional(pn.boolean),
      forcedJSONParsing: pn.transitional(pn.boolean),
      clarifyTimeoutError: pn.transitional(pn.boolean)
    }, !1), r != null && (C.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : ia.assertOptions(r, {
      encode: pn.function,
      serialize: pn.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), ia.assertOptions(t, {
      baseUrl: pn.spelling("baseURL"),
      withXsrfToken: pn.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let o = s && C.merge(
      s.common,
      s[t.method]
    );
    s && C.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete s[g];
      }
    ), t.headers = Mt.concat(o, s);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(_) {
      typeof _.runWhen == "function" && _.runWhen(t) === !1 || (l = l && _.synchronous, a.unshift(_.fulfilled, _.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(_) {
      c.push(_.fulfilled, _.rejected);
    });
    let h, u = 0, d;
    if (!l) {
      const g = [Pf.bind(this), void 0];
      for (g.unshift(...a), g.push(...c), d = g.length, h = Promise.resolve(t); u < d; )
        h = h.then(g[u++], g[u++]);
      return h;
    }
    d = a.length;
    let f = t;
    for (u = 0; u < d; ) {
      const g = a[u++], _ = a[u++];
      try {
        f = g(f);
      } catch (m) {
        _.call(this, m);
        break;
      }
    }
    try {
      h = Pf.call(this, f);
    } catch (g) {
      return Promise.reject(g);
    }
    for (u = 0, d = c.length; u < d; )
      h = h.then(c[u++], c[u++]);
    return h;
  }
  getUri(e) {
    e = rr(this.defaults, e);
    const t = n_(e.baseURL, e.url, e.allowAbsoluteUrls);
    return qm(t, e.params, e.paramsSerializer);
  }
};
C.forEach(["delete", "get", "head", "options"], function(e) {
  qi.prototype[e] = function(t, i) {
    return this.request(rr(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
C.forEach(["post", "put", "patch"], function(e) {
  function t(i) {
    return function(s, o, a) {
      return this.request(rr(a || {}, {
        method: e,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  qi.prototype[e] = t(), qi.prototype[e + "Form"] = t(!0);
});
let RS = class l_ {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const i = this;
    this.promise.then((r) => {
      if (!i._listeners) return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let s;
      const o = new Promise((a) => {
        i.subscribe(a), s = a;
      }).then(r);
      return o.cancel = function() {
        i.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      i.reason || (i.reason = new ns(s, o, a), t(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (i) => {
      e.abort(i);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new l_(function(r) {
        e = r;
      }),
      cancel: e
    };
  }
};
function CS(n) {
  return function(t) {
    return n.apply(null, t);
  };
}
function PS(n) {
  return C.isObject(n) && n.isAxiosError === !0;
}
const ah = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(ah).forEach(([n, e]) => {
  ah[e] = n;
});
function c_(n) {
  const e = new qi(n), t = Um(qi.prototype.request, e);
  return C.extend(t, qi.prototype, e, { allOwnKeys: !0 }), C.extend(t, e, null, { allOwnKeys: !0 }), t.create = function(r) {
    return c_(rr(n, r));
  }, t;
}
const Be = c_(wo);
Be.Axios = qi;
Be.CanceledError = ns;
Be.CancelToken = RS;
Be.isCancel = e_;
Be.VERSION = a_;
Be.toFormData = fl;
Be.AxiosError = se;
Be.Cancel = Be.CanceledError;
Be.all = function(e) {
  return Promise.all(e);
};
Be.spread = CS;
Be.isAxiosError = PS;
Be.mergeConfig = rr;
Be.AxiosHeaders = Mt;
Be.formToJSON = (n) => Qm(C.isHTMLForm(n) ? new FormData(n) : n);
Be.getAdapter = o_.getAdapter;
Be.HttpStatusCode = ah;
Be.default = Be;
const {
  Axios: WI,
  AxiosError: YI,
  CanceledError: $I,
  isCancel: jI,
  CancelToken: VI,
  VERSION: XI,
  all: HI,
  Cancel: KI,
  isAxiosError: ZI,
  spread: qI,
  toFormData: JI,
  AxiosHeaders: QI,
  HttpStatusCode: eA,
  formToJSON: tA,
  getAdapter: nA,
  mergeConfig: iA
} = Be, IS = 256, h_ = new TextEncoder(), AS = new TextDecoder(), LS = async (n) => {
  const e = typeof n == "string" ? n : JSON.stringify(n), t = window.crypto.getRandomValues(new Uint8Array(16)), i = window.crypto.getRandomValues(new Uint8Array(16)), r = await u_(f_), s = await d_(r, t, ["encrypt"]), o = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: i },
    s,
    h_.encode(e)
  ), a = new Uint8Array(o), l = new Uint8Array(
    t.byteLength + i.byteLength + a.byteLength
  );
  return l.set(t, 0), l.set(i, t.byteLength), l.set(a, t.byteLength + i.byteLength), MS(l);
}, OS = async (n) => {
  const e = DS(n), t = e.slice(0, 16), i = e.slice(16, 32), r = e.slice(32), s = await u_(f_), o = await d_(s, t, ["decrypt"]), a = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: i },
    o,
    r
  );
  return AS.decode(a);
}, MS = (n) => window.btoa(
  Array.from(n).map((e) => String.fromCharCode(e)).join("")
), DS = (n) => Uint8Array.from(window.atob(n), (e) => e.charCodeAt(0)), u_ = (n) => window.crypto.subtle.importKey(
  "raw",
  h_.encode(n),
  "PBKDF2",
  !1,
  ["deriveKey"]
), d_ = (n, e, t) => window.crypto.subtle.deriveKey(
  {
    name: "PBKDF2",
    salt: e,
    iterations: 179,
    hash: "SHA-256"
  },
  n,
  { name: "AES-GCM", length: IS },
  !1,
  t
), f_ = String.fromCharCode(
  ...new Uint8Array(
    [
      "22",
      "14",
      "2s",
      "24",
      "2c",
      "15",
      "3o",
      "16",
      "1i",
      "2f",
      "1c",
      "1k",
      "3i",
      "2t",
      "3p",
      "1h",
      "36",
      "1b",
      "2a",
      "26",
      "12",
      "20",
      "37",
      "2j",
      "27",
      "41",
      "1q",
      "1r",
      "1i",
      "23",
      "21"
    ].map((n) => parseInt(n, parseInt("11111", 2)))
  )
);
let g_ = "http://localhost:4013/";
console.warn = function() {
}, g_ = "http://localhost:4013/";
const FS = {
  baseURL: g_,
  headers: {
    "Content-Type": "application/json",
    Accept: "*/*",
    "allow-gis": "%?Y?_TYqc2QM7^p4t#>c"
  }
}, _l = Be.create(FS);
_l.interceptors.request.use(
  async (n) => {
    var t;
    n.headers["request-type"] = "web";
    const e = localStorage.getItem("token");
    if (e && (n.headers.Authorization = `Bearer ${e}`), n.headers.fp = Gm(), n.data && ["post", "put", "patch"].includes(((t = n.method) == null ? void 0 : t.toLowerCase()) || "")) {
      const i = await LS(n.data);
      n.data = { data: i };
    }
    return n;
  },
  (n) => Promise.reject(n)
);
_l.interceptors.response.use(
  async (n) => {
    const e = await OS(n.data.message);
    return JSON.parse(e);
  },
  (n) => {
    var e, t, i, r;
    return console.error(
      "API Response Error:",
      (t = (e = n == null ? void 0 : n.response) == null ? void 0 : e.data) == null ? void 0 : t.error,
      "Oops, the server encountered an error. Please try again later"
    ), Promise.reject(
      ((r = (i = n == null ? void 0 : n.response) == null ? void 0 : i.data) == null ? void 0 : r.error) || (n == null ? void 0 : n.message) || "Unknown error occurred"
    );
  }
);
const kS = async () => {
  const n = localStorage.getItem("token"), e = localStorage.getItem("isProduction");
  let t = {
    fp: Gm()
  };
  return e && (t = {
    ...t,
    Authorization: `Bearer ${n || ""}`
  }), e || (t = {
    ...t,
    "allow-gis": "%?Y?_TYqc2QM7^p4t#>c"
  }), t;
}, Cu = async (n, e) => HT.get(n, { headers: await kS() }), NS = (n, e) => _l.post(`${n}gis/intersected-sdtv`, e), GS = (n, e) => _l.post(
  `${n}birthRegi/getBirthCountForCluster`,
  e
), Af = (n) => {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (c, h) => {
    const u = typeof c == "function" ? c(e) : c;
    if (!Object.is(u, e)) {
      const d = e;
      e = h ?? (typeof u != "object" || u === null) ? u : Object.assign({}, e, u), t.forEach((f) => f(e, d));
    }
  }, r = () => e, a = { setState: i, getState: r, getInitialState: () => l, subscribe: (c) => (t.add(c), () => t.delete(c)) }, l = e = n(i, r, a);
  return a;
}, US = (n) => n ? Af(n) : Af, BS = (n) => n;
function zS(n, e = BS) {
  const t = he.useSyncExternalStore(
    n.subscribe,
    he.useCallback(() => e(n.getState()), [n, e]),
    he.useCallback(() => e(n.getInitialState()), [n, e])
  );
  return he.useDebugValue(t), t;
}
const WS = (n) => {
  const e = US(n), t = (i) => zS(e, i);
  return Object.assign(t, e), t;
}, YS = (n) => WS, $S = (n) => {
  let e = n;
  e.use = {};
  for (let t of Object.keys(e.getState()))
    e.use[t] = () => e((i) => i[t]);
  return e;
};
var jS = class extends Ft {
  constructor(e) {
    super(e), this._listener = [], e && e.active === !1 ? this.set("active", !1) : this.set("active", !0);
  }
  /** Activate / deactivate filter
  *	@param {boolean} b
  */
  setActive(e) {
    this.set("active", e === !0);
  }
  /** Get filter active
  *	@return {boolean}
  */
  getActive() {
    return this.get("active");
  }
};
(function() {
  function n(s) {
    this.get("active") && s.context && this.precompose(s);
  }
  function e(s) {
    this.get("active") && s.context && this.postcompose(s);
  }
  function t() {
    if (this.renderSync)
      try {
        this.renderSync();
      } catch {
      }
    else
      this.changed();
  }
  function i(s) {
    this.filters_ || (this.filters_ = []), this.filters_.push(s), s.addToLayer && s.addToLayer(this), s.precompose && s._listener.push({ listener: this.on(["precompose", "prerender"], n.bind(s)), target: this }), s.postcompose && s._listener.push({ listener: this.on(["postcompose", "postrender"], e.bind(s)), target: this }), s._listener.push({ listener: s.on("propertychange", t.bind(this)), target: this }), t.call(this);
  }
  function r(s) {
    var o;
    if (this.filters_ || (this.filters_ = []), !s) {
      this.filters_.forEach((function(a) {
        this.removeFilter(a);
      }).bind(this));
      return;
    }
    for (o = this.filters_.length - 1; o >= 0; o--)
      this.filters_[o] === s && this.filters_.splice(o, 1);
    for (o = s._listener.length - 1; o >= 0; o--)
      s._listener[o].target === this && (s.removeFromLayer && s.removeFromLayer(this), Pi(s._listener[o].listener), s._listener.splice(o, 1));
    t.call(this);
  }
  Zi.prototype.addFilter = function(s) {
    console.warn("[OL-EXT] addFilter deprecated on map."), i.call(this, s);
  }, Zi.prototype.removeFilter = function(s) {
    r.call(this, s);
  }, Zi.prototype.getFilters = function() {
    return this.filters_ || [];
  }, Ur.prototype.addFilter = function(s) {
    i.call(this, s);
  }, Ur.prototype.removeFilter = function(s) {
    r.call(this, s);
  }, Ur.prototype.getFilters = function() {
    return this.filters_ || [];
  };
})();
var VS = class extends jS {
  constructor(e) {
    if (e = e || {}, super(e), e.feature)
      switch (e.feature.getGeometry().getType()) {
        case "Polygon":
        case "MultiPolygon":
          this.feature_ = e.feature;
          break;
      }
    this.set("inner", e.inner), this._fillColor = e.fill && Vn(e.fill.getColor()) || "rgba(0,0,0,0.2)", this._shadowColor = e.shadowColor && Vn(e.shadowColor) || "rgba(0,0,0,0.5)", this.set("shadowWidth", e.shadowWidth || 0), this.set("shadowMapUnits", e.shadowMapUnits === !0);
  }
  /** Set filter fill color
   * @param {ol/colorLike} color
   */
  setFillColor(e) {
    this._fillColor = e && Vn(e) || "rgba(0,0,0,0.2)";
  }
  /** Set filter shadow color
   * @param {ol/colorLike} color
   */
  setShadowColor(e) {
    this._shadowColor = e && Vn(e) || "rgba(0,0,0,0.5)";
  }
  /** Draw the feature into canvas
   * @private
   */
  drawFeaturePath_(e, t) {
    var i = e.context, r = i.canvas, s = e.frameState.pixelRatio, o;
    if (e.frameState.coordinateToPixelTransform) {
      var a = e.frameState.coordinateToPixelTransform;
      if (e.inversePixelTransform) {
        var l = e.inversePixelTransform;
        o = function(E) {
          return E = [
            E[0] * a[0] + E[1] * a[1] + a[4],
            E[0] * a[2] + E[1] * a[3] + a[5]
          ], [
            E[0] * l[0] - E[1] * l[1] + l[4],
            -E[0] * l[2] + E[1] * l[3] + l[5]
          ];
        };
      } else
        o = function(E) {
          return [
            (E[0] * a[0] + E[1] * a[1] + a[4]) * s,
            (E[0] * a[2] + E[1] * a[3] + a[5]) * s
          ];
        };
    } else
      a = e.frameState.coordinateToPixelMatrix, o = function(E) {
        return [
          (E[0] * a[0] + E[1] * a[1] + a[12]) * s,
          (E[0] * a[4] + E[1] * a[5] + a[13]) * s
        ];
      };
    var c = this.feature_.getGeometry().getCoordinates();
    this.feature_.getGeometry().getType() === "Polygon" && (c = [c]);
    function h(E) {
      for (var x = 0; x < c.length; x++)
        for (var v = c[x], S = 0; S < v.length; S++) {
          var w = o([v[S][0][0] + E, v[S][0][1]]);
          i.moveTo(w[0], w[1]);
          for (var b = 1; b < v[S].length; b++)
            w = o([v[S][b][0] + E, v[S][b][1]]), i.lineTo(w[0], w[1]);
        }
    }
    if (i.beginPath(), t && (i.moveTo(-100, -100), i.lineTo(r.width + 100, -100), i.lineTo(r.width + 100, r.height + 100), i.lineTo(-100, r.height + 100), i.lineTo(-100, -100)), this.get("wrapX")) {
      var u = e.frameState.viewState.projection.getExtent(), d = u[2] - u[0], f = e.frameState.extent, g = this.feature_.getGeometry().getExtent(), _ = g[2] - g[1], m = Math.floor((f[0] - _ - u[0]) / d), y = Math.floor((f[2] + _ - u[2]) / d) + 1;
      m > y && ([m, y] = [y, m]);
      for (var p = m; p <= y; p++)
        h(p * d);
    } else
      h(0);
  }
  /**
   * @param {ol/Event} e 
   * @private
   */
  postcompose(e) {
    if (this.feature_) {
      var t = e.context;
      if (t.save(), this.drawFeaturePath_(e, !this.get("inner")), t.fillStyle = this._fillColor, t.fill("evenodd"), this.get("shadowWidth")) {
        var i = this.get("shadowWidth") * e.frameState.pixelRatio;
        this.get("shadowMapUnits") && (i /= e.frameState.viewState.resolution), t.clip("evenodd"), t.filter = "blur(" + i + "px)", t.strokeStyle = this._shadowColor, t.lineCap = "round", t.lineJoin = "round", t.lineWidth = i, t.stroke();
      }
      t.restore();
    }
  }
}, XS = class extends VS {
  constructor(e) {
    e = e || {}, super(e);
  }
  /**
   * @param {ol/Event} e 
   * @private
   */
  precompose(e) {
    if (this.feature_) {
      var t = e.context;
      t.save(), this.drawFeaturePath_(e, this.get("inner")), t.clip("evenodd");
    }
  }
  /**
   * @param {ol/Event} e 
   * @private
   */
  postcompose(e) {
    if (this.feature_) {
      var t = e.context;
      if (t.restore(), this.get("shadowWidth")) {
        t.save();
        var i = this.get("shadowWidth") * e.frameState.pixelRatio;
        this.get("shadowMapUnits") && (i /= e.frameState.viewState.resolution), this.drawFeaturePath_(e, !this.get("inner")), t.clip("evenodd"), t.filter = "blur(" + i + "px)", t.strokeStyle = this._shadowColor, t.lineCap = "round", t.lineJoin = "round", t.lineWidth = i, t.stroke(), t.restore();
      }
    }
  }
};
const HS = YS()((n) => ({
  map: new Zi(),
  setMap: (e) => n({ map: e }),
  showLayersLegend: !0,
  setShowLayersLegend: (e) => n({ showLayersLegend: e }),
  visibleLayers: {},
  setVisibleLayers: (e) => n({ visibleLayers: e }),
  areaOfIntersectLayers: {},
  setAreaOfIntersectLayers: (e) => n({ areaOfIntersectLayers: e }),
  isAoIEnabled: !1,
  setAoIEnabled: (e) => n({ isAoIEnabled: e }),
  openedGroup: void 0,
  setOpenedGroup: (e) => n({ openedGroup: e }),
  drawnCoordinates: [],
  setDrawnCoordinates: (e) => n({ drawnCoordinates: e }),
  selectedLayers: [],
  setSelectedLayers: (e) => n({ selectedLayers: e }),
  searchResults: [],
  setSearchResults: (e) => n({ searchResults: e }),
  navigationCropFilter: new XS(),
  setNavigationCropFilter: (e) => n({ navigationCropFilter: e }),
  isProduction: !1,
  setIsProduction: (e) => n({ isProduction: e })
})), tn = $S(HS), KS = 256, m_ = new TextEncoder();
new TextDecoder();
const ZS = async (n) => {
  const e = typeof n == "string" ? n : JSON.stringify(n), t = window.crypto.getRandomValues(new Uint8Array(16)), i = window.crypto.getRandomValues(new Uint8Array(16)), r = await JS(eb), s = await QS(r, t, ["encrypt"]), o = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: i },
    s,
    m_.encode(e)
  ), a = new Uint8Array(o), l = new Uint8Array(
    t.byteLength + i.byteLength + a.byteLength
  );
  return l.set(t, 0), l.set(i, t.byteLength), l.set(a, t.byteLength + i.byteLength), qS(l);
}, qS = (n) => window.btoa(
  Array.from(n).map((e) => String.fromCharCode(e)).join("")
), JS = (n) => window.crypto.subtle.importKey(
  "raw",
  m_.encode(n),
  "PBKDF2",
  !1,
  ["deriveKey"]
), QS = (n, e, t) => window.crypto.subtle.deriveKey(
  {
    name: "PBKDF2",
    salt: e,
    iterations: 179,
    hash: "SHA-256"
  },
  n,
  { name: "AES-GCM", length: KS },
  !1,
  t
), eb = String.fromCharCode(
  ...new Uint8Array(
    [
      "22",
      "14",
      "2s",
      "24",
      "2c",
      "15",
      "3o",
      "16",
      "1i",
      "2f",
      "1c",
      "1k",
      "3i",
      "2t",
      "3p",
      "1h",
      "36",
      "1b",
      "2a",
      "26",
      "12",
      "20",
      "37",
      "2j",
      "27",
      "41",
      "1q",
      "1r",
      "1i",
      "23",
      "21"
    ].map((n) => parseInt(n, parseInt("11111", 2)))
  )
), tb = ["localwms", "wms"], nb = async (n, e) => {
  if (n instanceof Jh) {
    const t = await Cu(await Pu(e));
    if (t.status !== 200)
      return;
    const i = await t.blob(), r = n.getImage();
    if (r instanceof HTMLImageElement) {
      const s = URL.createObjectURL(i);
      r.onload = () => {
        URL.revokeObjectURL(s);
      }, r.src = s;
    }
  }
}, ib = (n) => tb.some((e) => n.includes(e)), Pu = async (n) => {
  if (!ib(n))
    return n;
  const e = new URL(n), t = e.origin + e.pathname, i = e.search.substring(1);
  return `${t}?data=${encodeURIComponent(await ZS(i))}`;
}, rb = () => {
  const n = tn.use.map(), e = ei(null), [t, i] = st(), [r, s] = st(""), [o, a] = st(), l = ei(), [c, h] = st();
  xt(() => {
    const g = new sE({
      element: e.current,
      autoPan: { animation: { duration: 250 } }
    });
    i(g), n.addOverlay(g);
    const _ = (m) => {
      var E;
      if (kv(m))
        return;
      const p = n.getAllLayers().filter((x) => {
        if (!x.getVisible() || !x.getData || [
          "Village",
          "Taluka",
          "District",
          "State",
          "Google",
          "India Tiles"
        ].includes(x.get("name")))
          return !1;
        const v = x.getData(m.pixel);
        return !(!(v instanceof Uint8ClampedArray) || Array.from(v).every((S) => S === 0));
      })[0];
      if (p instanceof al || p instanceof Ks || p instanceof J1 || p instanceof ir) {
        const x = (E = p == null ? void 0 : p.getSource()) == null ? void 0 : E.getFeatureInfoUrl(
          m.coordinate,
          n.getView().getResolution(),
          "EPSG:3857",
          {
            INFO_FORMAT: "application/json"
          }
        );
        if (!x)
          return;
        Pu(x).then((v) => Cu(v)).then((v) => v.json()).then((v) => {
          var k;
          if (v.features.length === 0)
            return;
          const S = new rT().readFeatures(v);
          a((k = S[0].getGeometry()) == null ? void 0 : k.getExtent());
          const w = v.features[0].properties, b = p.get("name"), P = p.getSource().getParams().LAYERS;
          h({
            props: {
              ...w
            },
            displayName: b,
            paramsName: P
          }), s(b), g == null || g.setPosition(m.coordinate);
          const O = new fo({ features: S }), N = new Ks({
            source: O,
            style: new wt({
              stroke: new Gt({ color: "#0BC5EA", width: 5 })
            })
          });
          l.current && n.removeLayer(l.current), l.current = N, n.addLayer(N);
        });
      }
    };
    return n.on("singleclick", _), () => {
      n.un("singleclick", _), n.removeOverlay(t), n.removeLayer(l.current);
    };
  }, [n]);
  const u = () => {
    const g = nn(o);
    n.getView().fit(new on(g), {
      size: n.getSize(),
      duration: 1e3,
      maxZoom: 10
    });
  }, d = () => {
    var g, _;
    t == null || t.setPosition(void 0), (_ = (g = e.current) == null ? void 0 : g.parentElement) == null || _.classList.remove("pin-top-right"), n.removeLayer(l.current);
  }, f = /* @__PURE__ */ j.jsx(j.Fragment, { children: /* @__PURE__ */ j.jsx("div", { className: "body", children: !!(c != null && c.props) && Object.entries(sb(c == null ? void 0 : c.props)).map(([g, _]) => /* @__PURE__ */ j.jsxs("div", { className: "cell", children: [
    /* @__PURE__ */ j.jsx("div", { className: "key", children: g }),
    /* @__PURE__ */ j.jsx("div", { className: "val", children: _ })
  ] }, g)) }) });
  return /* @__PURE__ */ j.jsxs("div", { ref: e, id: "popup", className: "identify-popup", children: [
    /* @__PURE__ */ j.jsxs("header", { className: "d-flex align-items-center justify-content-between gap-2 p-2", children: [
      /* @__PURE__ */ j.jsx("span", { color: "black", children: r }),
      /* @__PURE__ */ j.jsxs("div", { className: "d-flex align-items-center gap-2", children: [
        /* @__PURE__ */ j.jsx(CT, { size: 22, role: "button", onClick: u }),
        /* @__PURE__ */ j.jsx(
          PT,
          {
            className: "",
            color: "black",
            size: 24,
            role: "button",
            onClick: d
          }
        )
      ] })
    ] }),
    f
  ] });
}, sb = (n) => {
  const e = { ...n };
  return delete e.minx, delete e.miny, delete e.maxx, delete e.maxy, delete e.wkt, delete e.geom, delete e.userid, delete e.username, delete e.action, Object.keys(e).forEach((t) => {
    const i = e[t], r = t.replaceAll("_", " "), s = !i || typeof i == "string" && i.trim().length === 0 || i == "null" || i == "NULL" ? "-" : i;
    delete e[t], e[r] = new String(s);
  }), e;
};
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var __;
function G() {
  return __.apply(null, arguments);
}
function ob(n) {
  __ = n;
}
function cn(n) {
  return n instanceof Array || Object.prototype.toString.call(n) === "[object Array]";
}
function Ji(n) {
  return n != null && Object.prototype.toString.call(n) === "[object Object]";
}
function pe(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function Iu(n) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(n).length === 0;
  var e;
  for (e in n)
    if (pe(n, e))
      return !1;
  return !0;
}
function Ct(n) {
  return n === void 0;
}
function si(n) {
  return typeof n == "number" || Object.prototype.toString.call(n) === "[object Number]";
}
function So(n) {
  return n instanceof Date || Object.prototype.toString.call(n) === "[object Date]";
}
function p_(n, e) {
  var t = [], i, r = n.length;
  for (i = 0; i < r; ++i)
    t.push(e(n[i], i));
  return t;
}
function Ei(n, e) {
  for (var t in e)
    pe(e, t) && (n[t] = e[t]);
  return pe(e, "toString") && (n.toString = e.toString), pe(e, "valueOf") && (n.valueOf = e.valueOf), n;
}
function Cn(n, e, t, i) {
  return B_(n, e, t, i, !0).utc();
}
function ab() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function ae(n) {
  return n._pf == null && (n._pf = ab()), n._pf;
}
var lh;
Array.prototype.some ? lh = Array.prototype.some : lh = function(n) {
  var e = Object(this), t = e.length >>> 0, i;
  for (i = 0; i < t; i++)
    if (i in e && n.call(this, e[i], i, e))
      return !0;
  return !1;
};
function Au(n) {
  var e = null, t = !1, i = n._d && !isNaN(n._d.getTime());
  if (i && (e = ae(n), t = lh.call(e.parsedDateParts, function(r) {
    return r != null;
  }), i = e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && t), n._strict && (i = i && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(n))
    n._isValid = i;
  else
    return i;
  return n._isValid;
}
function pl(n) {
  var e = Cn(NaN);
  return n != null ? Ei(ae(e), n) : ae(e).userInvalidated = !0, e;
}
var Lf = G.momentProperties = [], _c = !1;
function Lu(n, e) {
  var t, i, r, s = Lf.length;
  if (Ct(e._isAMomentObject) || (n._isAMomentObject = e._isAMomentObject), Ct(e._i) || (n._i = e._i), Ct(e._f) || (n._f = e._f), Ct(e._l) || (n._l = e._l), Ct(e._strict) || (n._strict = e._strict), Ct(e._tzm) || (n._tzm = e._tzm), Ct(e._isUTC) || (n._isUTC = e._isUTC), Ct(e._offset) || (n._offset = e._offset), Ct(e._pf) || (n._pf = ae(e)), Ct(e._locale) || (n._locale = e._locale), s > 0)
    for (t = 0; t < s; t++)
      i = Lf[t], r = e[i], Ct(r) || (n[i] = r);
  return n;
}
function bo(n) {
  Lu(this, n), this._d = new Date(n._d != null ? n._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), _c === !1 && (_c = !0, G.updateOffset(this), _c = !1);
}
function hn(n) {
  return n instanceof bo || n != null && n._isAMomentObject != null;
}
function y_(n) {
  G.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + n);
}
function Ht(n, e) {
  var t = !0;
  return Ei(function() {
    if (G.deprecationHandler != null && G.deprecationHandler(null, n), t) {
      var i = [], r, s, o, a = arguments.length;
      for (s = 0; s < a; s++) {
        if (r = "", typeof arguments[s] == "object") {
          r += `
[` + s + "] ";
          for (o in arguments[0])
            pe(arguments[0], o) && (r += o + ": " + arguments[0][o] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[s];
        i.push(r);
      }
      y_(
        n + `
Arguments: ` + Array.prototype.slice.call(i).join("") + `
` + new Error().stack
      ), t = !1;
    }
    return e.apply(this, arguments);
  }, e);
}
var Of = {};
function x_(n, e) {
  G.deprecationHandler != null && G.deprecationHandler(n, e), Of[n] || (y_(e), Of[n] = !0);
}
G.suppressDeprecationWarnings = !1;
G.deprecationHandler = null;
function Pn(n) {
  return typeof Function < "u" && n instanceof Function || Object.prototype.toString.call(n) === "[object Function]";
}
function lb(n) {
  var e, t;
  for (t in n)
    pe(n, t) && (e = n[t], Pn(e) ? this[t] = e : this["_" + t] = e);
  this._config = n, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function ch(n, e) {
  var t = Ei({}, n), i;
  for (i in e)
    pe(e, i) && (Ji(n[i]) && Ji(e[i]) ? (t[i] = {}, Ei(t[i], n[i]), Ei(t[i], e[i])) : e[i] != null ? t[i] = e[i] : delete t[i]);
  for (i in n)
    pe(n, i) && !pe(e, i) && Ji(n[i]) && (t[i] = Ei({}, t[i]));
  return t;
}
function Ou(n) {
  n != null && this.set(n);
}
var hh;
Object.keys ? hh = Object.keys : hh = function(n) {
  var e, t = [];
  for (e in n)
    pe(n, e) && t.push(e);
  return t;
};
var cb = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function hb(n, e, t) {
  var i = this._calendar[n] || this._calendar.sameElse;
  return Pn(i) ? i.call(e, t) : i;
}
function bn(n, e, t) {
  var i = "" + Math.abs(n), r = e - i.length, s = n >= 0;
  return (s ? t ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + i;
}
var Mu = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, qo = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, pc = {}, zr = {};
function V(n, e, t, i) {
  var r = i;
  typeof i == "string" && (r = function() {
    return this[i]();
  }), n && (zr[n] = r), e && (zr[e[0]] = function() {
    return bn(r.apply(this, arguments), e[1], e[2]);
  }), t && (zr[t] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      n
    );
  });
}
function ub(n) {
  return n.match(/\[[\s\S]/) ? n.replace(/^\[|\]$/g, "") : n.replace(/\\/g, "");
}
function db(n) {
  var e = n.match(Mu), t, i;
  for (t = 0, i = e.length; t < i; t++)
    zr[e[t]] ? e[t] = zr[e[t]] : e[t] = ub(e[t]);
  return function(r) {
    var s = "", o;
    for (o = 0; o < i; o++)
      s += Pn(e[o]) ? e[o].call(r, n) : e[o];
    return s;
  };
}
function ra(n, e) {
  return n.isValid() ? (e = v_(e, n.localeData()), pc[e] = pc[e] || db(e), pc[e](n)) : n.localeData().invalidDate();
}
function v_(n, e) {
  var t = 5;
  function i(r) {
    return e.longDateFormat(r) || r;
  }
  for (qo.lastIndex = 0; t >= 0 && qo.test(n); )
    n = n.replace(
      qo,
      i
    ), qo.lastIndex = 0, t -= 1;
  return n;
}
var fb = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function gb(n) {
  var e = this._longDateFormat[n], t = this._longDateFormat[n.toUpperCase()];
  return e || !t ? e : (this._longDateFormat[n] = t.match(Mu).map(function(i) {
    return i === "MMMM" || i === "MM" || i === "DD" || i === "dddd" ? i.slice(1) : i;
  }).join(""), this._longDateFormat[n]);
}
var mb = "Invalid date";
function _b() {
  return this._invalidDate;
}
var pb = "%d", yb = /\d{1,2}/;
function xb(n) {
  return this._ordinal.replace("%d", n);
}
var vb = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function Eb(n, e, t, i) {
  var r = this._relativeTime[t];
  return Pn(r) ? r(n, e, t, i) : r.replace(/%d/i, n);
}
function Tb(n, e) {
  var t = this._relativeTime[n > 0 ? "future" : "past"];
  return Pn(t) ? t(e) : t.replace(/%s/i, e);
}
var Mf = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function Kt(n) {
  return typeof n == "string" ? Mf[n] || Mf[n.toLowerCase()] : void 0;
}
function Du(n) {
  var e = {}, t, i;
  for (i in n)
    pe(n, i) && (t = Kt(i), t && (e[t] = n[i]));
  return e;
}
var wb = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function Sb(n) {
  var e = [], t;
  for (t in n)
    pe(n, t) && e.push({ unit: t, priority: wb[t] });
  return e.sort(function(i, r) {
    return i.priority - r.priority;
  }), e;
}
var E_ = /\d/, Ut = /\d\d/, T_ = /\d{3}/, Fu = /\d{4}/, yl = /[+-]?\d{6}/, Le = /\d\d?/, w_ = /\d\d\d\d?/, S_ = /\d\d\d\d\d\d?/, xl = /\d{1,3}/, ku = /\d{1,4}/, vl = /[+-]?\d{1,6}/, is = /\d+/, El = /[+-]?\d+/, bb = /Z|[+-]\d\d:?\d\d/gi, Tl = /Z|[+-]\d\d(?::?\d\d)?/gi, Rb = /[+-]?\d+(\.\d{1,3})?/, Ro = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, rs = /^[1-9]\d?/, Nu = /^([1-9]\d|\d)/, Oa;
Oa = {};
function W(n, e, t) {
  Oa[n] = Pn(e) ? e : function(i, r) {
    return i && t ? t : e;
  };
}
function Cb(n, e) {
  return pe(Oa, n) ? Oa[n](e._strict, e._locale) : new RegExp(Pb(n));
}
function Pb(n) {
  return Jn(
    n.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(e, t, i, r, s) {
        return t || i || r || s;
      }
    )
  );
}
function Jn(n) {
  return n.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function Yt(n) {
  return n < 0 ? Math.ceil(n) || 0 : Math.floor(n);
}
function de(n) {
  var e = +n, t = 0;
  return e !== 0 && isFinite(e) && (t = Yt(e)), t;
}
var uh = {};
function Se(n, e) {
  var t, i = e, r;
  for (typeof n == "string" && (n = [n]), si(e) && (i = function(s, o) {
    o[e] = de(s);
  }), r = n.length, t = 0; t < r; t++)
    uh[n[t]] = i;
}
function Co(n, e) {
  Se(n, function(t, i, r, s) {
    r._w = r._w || {}, e(t, r._w, r, s);
  });
}
function Ib(n, e, t) {
  e != null && pe(uh, n) && uh[n](e, t._a, t, n);
}
function wl(n) {
  return n % 4 === 0 && n % 100 !== 0 || n % 400 === 0;
}
var dt = 0, Xn = 1, vn = 2, Ze = 3, en = 4, Hn = 5, $i = 6, Ab = 7, Lb = 8;
V("Y", 0, 0, function() {
  var n = this.year();
  return n <= 9999 ? bn(n, 4) : "+" + n;
});
V(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
V(0, ["YYYY", 4], 0, "year");
V(0, ["YYYYY", 5], 0, "year");
V(0, ["YYYYYY", 6, !0], 0, "year");
W("Y", El);
W("YY", Le, Ut);
W("YYYY", ku, Fu);
W("YYYYY", vl, yl);
W("YYYYYY", vl, yl);
Se(["YYYYY", "YYYYYY"], dt);
Se("YYYY", function(n, e) {
  e[dt] = n.length === 2 ? G.parseTwoDigitYear(n) : de(n);
});
Se("YY", function(n, e) {
  e[dt] = G.parseTwoDigitYear(n);
});
Se("Y", function(n, e) {
  e[dt] = parseInt(n, 10);
});
function Ds(n) {
  return wl(n) ? 366 : 365;
}
G.parseTwoDigitYear = function(n) {
  return de(n) + (de(n) > 68 ? 1900 : 2e3);
};
var b_ = ss("FullYear", !0);
function Ob() {
  return wl(this.year());
}
function ss(n, e) {
  return function(t) {
    return t != null ? (R_(this, n, t), G.updateOffset(this, e), this) : Qs(this, n);
  };
}
function Qs(n, e) {
  if (!n.isValid())
    return NaN;
  var t = n._d, i = n._isUTC;
  switch (e) {
    case "Milliseconds":
      return i ? t.getUTCMilliseconds() : t.getMilliseconds();
    case "Seconds":
      return i ? t.getUTCSeconds() : t.getSeconds();
    case "Minutes":
      return i ? t.getUTCMinutes() : t.getMinutes();
    case "Hours":
      return i ? t.getUTCHours() : t.getHours();
    case "Date":
      return i ? t.getUTCDate() : t.getDate();
    case "Day":
      return i ? t.getUTCDay() : t.getDay();
    case "Month":
      return i ? t.getUTCMonth() : t.getMonth();
    case "FullYear":
      return i ? t.getUTCFullYear() : t.getFullYear();
    default:
      return NaN;
  }
}
function R_(n, e, t) {
  var i, r, s, o, a;
  if (!(!n.isValid() || isNaN(t))) {
    switch (i = n._d, r = n._isUTC, e) {
      case "Milliseconds":
        return void (r ? i.setUTCMilliseconds(t) : i.setMilliseconds(t));
      case "Seconds":
        return void (r ? i.setUTCSeconds(t) : i.setSeconds(t));
      case "Minutes":
        return void (r ? i.setUTCMinutes(t) : i.setMinutes(t));
      case "Hours":
        return void (r ? i.setUTCHours(t) : i.setHours(t));
      case "Date":
        return void (r ? i.setUTCDate(t) : i.setDate(t));
      case "FullYear":
        break;
      default:
        return;
    }
    s = t, o = n.month(), a = n.date(), a = a === 29 && o === 1 && !wl(s) ? 28 : a, r ? i.setUTCFullYear(s, o, a) : i.setFullYear(s, o, a);
  }
}
function Mb(n) {
  return n = Kt(n), Pn(this[n]) ? this[n]() : this;
}
function Db(n, e) {
  if (typeof n == "object") {
    n = Du(n);
    var t = Sb(n), i, r = t.length;
    for (i = 0; i < r; i++)
      this[t[i].unit](n[t[i].unit]);
  } else if (n = Kt(n), Pn(this[n]))
    return this[n](e);
  return this;
}
function Fb(n, e) {
  return (n % e + e) % e;
}
var Ge;
Array.prototype.indexOf ? Ge = Array.prototype.indexOf : Ge = function(n) {
  var e;
  for (e = 0; e < this.length; ++e)
    if (this[e] === n)
      return e;
  return -1;
};
function Gu(n, e) {
  if (isNaN(n) || isNaN(e))
    return NaN;
  var t = Fb(e, 12);
  return n += (e - t) / 12, t === 1 ? wl(n) ? 29 : 28 : 31 - t % 7 % 2;
}
V("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
V("MMM", 0, 0, function(n) {
  return this.localeData().monthsShort(this, n);
});
V("MMMM", 0, 0, function(n) {
  return this.localeData().months(this, n);
});
W("M", Le, rs);
W("MM", Le, Ut);
W("MMM", function(n, e) {
  return e.monthsShortRegex(n);
});
W("MMMM", function(n, e) {
  return e.monthsRegex(n);
});
Se(["M", "MM"], function(n, e) {
  e[Xn] = de(n) - 1;
});
Se(["MMM", "MMMM"], function(n, e, t, i) {
  var r = t._locale.monthsParse(n, i, t._strict);
  r != null ? e[Xn] = r : ae(t).invalidMonth = n;
});
var kb = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), C_ = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), P_ = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Nb = Ro, Gb = Ro;
function Ub(n, e) {
  return n ? cn(this._months) ? this._months[n.month()] : this._months[(this._months.isFormat || P_).test(e) ? "format" : "standalone"][n.month()] : cn(this._months) ? this._months : this._months.standalone;
}
function Bb(n, e) {
  return n ? cn(this._monthsShort) ? this._monthsShort[n.month()] : this._monthsShort[P_.test(e) ? "format" : "standalone"][n.month()] : cn(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function zb(n, e, t) {
  var i, r, s, o = n.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i)
      s = Cn([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(
        s,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[i] = this.months(s, "").toLocaleLowerCase();
  return t ? e === "MMM" ? (r = Ge.call(this._shortMonthsParse, o), r !== -1 ? r : null) : (r = Ge.call(this._longMonthsParse, o), r !== -1 ? r : null) : e === "MMM" ? (r = Ge.call(this._shortMonthsParse, o), r !== -1 ? r : (r = Ge.call(this._longMonthsParse, o), r !== -1 ? r : null)) : (r = Ge.call(this._longMonthsParse, o), r !== -1 ? r : (r = Ge.call(this._shortMonthsParse, o), r !== -1 ? r : null));
}
function Wb(n, e, t) {
  var i, r, s;
  if (this._monthsParseExact)
    return zb.call(this, n, e, t);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
    if (r = Cn([2e3, i]), t && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[i] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !t && !this._monthsParse[i] && (s = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[i] = new RegExp(s.replace(".", ""), "i")), t && e === "MMMM" && this._longMonthsParse[i].test(n))
      return i;
    if (t && e === "MMM" && this._shortMonthsParse[i].test(n))
      return i;
    if (!t && this._monthsParse[i].test(n))
      return i;
  }
}
function I_(n, e) {
  if (!n.isValid())
    return n;
  if (typeof e == "string") {
    if (/^\d+$/.test(e))
      e = de(e);
    else if (e = n.localeData().monthsParse(e), !si(e))
      return n;
  }
  var t = e, i = n.date();
  return i = i < 29 ? i : Math.min(i, Gu(n.year(), t)), n._isUTC ? n._d.setUTCMonth(t, i) : n._d.setMonth(t, i), n;
}
function A_(n) {
  return n != null ? (I_(this, n), G.updateOffset(this, !0), this) : Qs(this, "Month");
}
function Yb() {
  return Gu(this.year(), this.month());
}
function $b(n) {
  return this._monthsParseExact ? (pe(this, "_monthsRegex") || L_.call(this), n ? this._monthsShortStrictRegex : this._monthsShortRegex) : (pe(this, "_monthsShortRegex") || (this._monthsShortRegex = Nb), this._monthsShortStrictRegex && n ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function jb(n) {
  return this._monthsParseExact ? (pe(this, "_monthsRegex") || L_.call(this), n ? this._monthsStrictRegex : this._monthsRegex) : (pe(this, "_monthsRegex") || (this._monthsRegex = Gb), this._monthsStrictRegex && n ? this._monthsStrictRegex : this._monthsRegex);
}
function L_() {
  function n(l, c) {
    return c.length - l.length;
  }
  var e = [], t = [], i = [], r, s, o, a;
  for (r = 0; r < 12; r++)
    s = Cn([2e3, r]), o = Jn(this.monthsShort(s, "")), a = Jn(this.months(s, "")), e.push(o), t.push(a), i.push(a), i.push(o);
  e.sort(n), t.sort(n), i.sort(n), this._monthsRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
function Vb(n, e, t, i, r, s, o) {
  var a;
  return n < 100 && n >= 0 ? (a = new Date(n + 400, e, t, i, r, s, o), isFinite(a.getFullYear()) && a.setFullYear(n)) : a = new Date(n, e, t, i, r, s, o), a;
}
function eo(n) {
  var e, t;
  return n < 100 && n >= 0 ? (t = Array.prototype.slice.call(arguments), t[0] = n + 400, e = new Date(Date.UTC.apply(null, t)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(n)) : e = new Date(Date.UTC.apply(null, arguments)), e;
}
function Ma(n, e, t) {
  var i = 7 + e - t, r = (7 + eo(n, 0, i).getUTCDay() - e) % 7;
  return -r + i - 1;
}
function O_(n, e, t, i, r) {
  var s = (7 + t - i) % 7, o = Ma(n, i, r), a = 1 + 7 * (e - 1) + s + o, l, c;
  return a <= 0 ? (l = n - 1, c = Ds(l) + a) : a > Ds(n) ? (l = n + 1, c = a - Ds(n)) : (l = n, c = a), {
    year: l,
    dayOfYear: c
  };
}
function to(n, e, t) {
  var i = Ma(n.year(), e, t), r = Math.floor((n.dayOfYear() - i - 1) / 7) + 1, s, o;
  return r < 1 ? (o = n.year() - 1, s = r + Qn(o, e, t)) : r > Qn(n.year(), e, t) ? (s = r - Qn(n.year(), e, t), o = n.year() + 1) : (o = n.year(), s = r), {
    week: s,
    year: o
  };
}
function Qn(n, e, t) {
  var i = Ma(n, e, t), r = Ma(n + 1, e, t);
  return (Ds(n) - i + r) / 7;
}
V("w", ["ww", 2], "wo", "week");
V("W", ["WW", 2], "Wo", "isoWeek");
W("w", Le, rs);
W("ww", Le, Ut);
W("W", Le, rs);
W("WW", Le, Ut);
Co(
  ["w", "ww", "W", "WW"],
  function(n, e, t, i) {
    e[i.substr(0, 1)] = de(n);
  }
);
function Xb(n) {
  return to(n, this._week.dow, this._week.doy).week;
}
var Hb = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function Kb() {
  return this._week.dow;
}
function Zb() {
  return this._week.doy;
}
function qb(n) {
  var e = this.localeData().week(this);
  return n == null ? e : this.add((n - e) * 7, "d");
}
function Jb(n) {
  var e = to(this, 1, 4).week;
  return n == null ? e : this.add((n - e) * 7, "d");
}
V("d", 0, "do", "day");
V("dd", 0, 0, function(n) {
  return this.localeData().weekdaysMin(this, n);
});
V("ddd", 0, 0, function(n) {
  return this.localeData().weekdaysShort(this, n);
});
V("dddd", 0, 0, function(n) {
  return this.localeData().weekdays(this, n);
});
V("e", 0, 0, "weekday");
V("E", 0, 0, "isoWeekday");
W("d", Le);
W("e", Le);
W("E", Le);
W("dd", function(n, e) {
  return e.weekdaysMinRegex(n);
});
W("ddd", function(n, e) {
  return e.weekdaysShortRegex(n);
});
W("dddd", function(n, e) {
  return e.weekdaysRegex(n);
});
Co(["dd", "ddd", "dddd"], function(n, e, t, i) {
  var r = t._locale.weekdaysParse(n, i, t._strict);
  r != null ? e.d = r : ae(t).invalidWeekday = n;
});
Co(["d", "e", "E"], function(n, e, t, i) {
  e[i] = de(n);
});
function Qb(n, e) {
  return typeof n != "string" ? n : isNaN(n) ? (n = e.weekdaysParse(n), typeof n == "number" ? n : null) : parseInt(n, 10);
}
function eR(n, e) {
  return typeof n == "string" ? e.weekdaysParse(n) % 7 || 7 : isNaN(n) ? null : n;
}
function Uu(n, e) {
  return n.slice(e, 7).concat(n.slice(0, e));
}
var tR = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), M_ = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), nR = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), iR = Ro, rR = Ro, sR = Ro;
function oR(n, e) {
  var t = cn(this._weekdays) ? this._weekdays : this._weekdays[n && n !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
  return n === !0 ? Uu(t, this._week.dow) : n ? t[n.day()] : t;
}
function aR(n) {
  return n === !0 ? Uu(this._weekdaysShort, this._week.dow) : n ? this._weekdaysShort[n.day()] : this._weekdaysShort;
}
function lR(n) {
  return n === !0 ? Uu(this._weekdaysMin, this._week.dow) : n ? this._weekdaysMin[n.day()] : this._weekdaysMin;
}
function cR(n, e, t) {
  var i, r, s, o = n.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i)
      s = Cn([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(
        s,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(
        s,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(s, "").toLocaleLowerCase();
  return t ? e === "dddd" ? (r = Ge.call(this._weekdaysParse, o), r !== -1 ? r : null) : e === "ddd" ? (r = Ge.call(this._shortWeekdaysParse, o), r !== -1 ? r : null) : (r = Ge.call(this._minWeekdaysParse, o), r !== -1 ? r : null) : e === "dddd" ? (r = Ge.call(this._weekdaysParse, o), r !== -1 || (r = Ge.call(this._shortWeekdaysParse, o), r !== -1) ? r : (r = Ge.call(this._minWeekdaysParse, o), r !== -1 ? r : null)) : e === "ddd" ? (r = Ge.call(this._shortWeekdaysParse, o), r !== -1 || (r = Ge.call(this._weekdaysParse, o), r !== -1) ? r : (r = Ge.call(this._minWeekdaysParse, o), r !== -1 ? r : null)) : (r = Ge.call(this._minWeekdaysParse, o), r !== -1 || (r = Ge.call(this._weekdaysParse, o), r !== -1) ? r : (r = Ge.call(this._shortWeekdaysParse, o), r !== -1 ? r : null));
}
function hR(n, e, t) {
  var i, r, s;
  if (this._weekdaysParseExact)
    return cR.call(this, n, e, t);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
    if (r = Cn([2e3, 1]).day(i), t && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[i] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[i] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[i] || (s = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[i] = new RegExp(s.replace(".", ""), "i")), t && e === "dddd" && this._fullWeekdaysParse[i].test(n))
      return i;
    if (t && e === "ddd" && this._shortWeekdaysParse[i].test(n))
      return i;
    if (t && e === "dd" && this._minWeekdaysParse[i].test(n))
      return i;
    if (!t && this._weekdaysParse[i].test(n))
      return i;
  }
}
function uR(n) {
  if (!this.isValid())
    return n != null ? this : NaN;
  var e = Qs(this, "Day");
  return n != null ? (n = Qb(n, this.localeData()), this.add(n - e, "d")) : e;
}
function dR(n) {
  if (!this.isValid())
    return n != null ? this : NaN;
  var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return n == null ? e : this.add(n - e, "d");
}
function fR(n) {
  if (!this.isValid())
    return n != null ? this : NaN;
  if (n != null) {
    var e = eR(n, this.localeData());
    return this.day(this.day() % 7 ? e : e - 7);
  } else
    return this.day() || 7;
}
function gR(n) {
  return this._weekdaysParseExact ? (pe(this, "_weekdaysRegex") || Bu.call(this), n ? this._weekdaysStrictRegex : this._weekdaysRegex) : (pe(this, "_weekdaysRegex") || (this._weekdaysRegex = iR), this._weekdaysStrictRegex && n ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function mR(n) {
  return this._weekdaysParseExact ? (pe(this, "_weekdaysRegex") || Bu.call(this), n ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (pe(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = rR), this._weekdaysShortStrictRegex && n ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function _R(n) {
  return this._weekdaysParseExact ? (pe(this, "_weekdaysRegex") || Bu.call(this), n ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (pe(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = sR), this._weekdaysMinStrictRegex && n ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Bu() {
  function n(h, u) {
    return u.length - h.length;
  }
  var e = [], t = [], i = [], r = [], s, o, a, l, c;
  for (s = 0; s < 7; s++)
    o = Cn([2e3, 1]).day(s), a = Jn(this.weekdaysMin(o, "")), l = Jn(this.weekdaysShort(o, "")), c = Jn(this.weekdays(o, "")), e.push(a), t.push(l), i.push(c), r.push(a), r.push(l), r.push(c);
  e.sort(n), t.sort(n), i.sort(n), r.sort(n), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
function zu() {
  return this.hours() % 12 || 12;
}
function pR() {
  return this.hours() || 24;
}
V("H", ["HH", 2], 0, "hour");
V("h", ["hh", 2], 0, zu);
V("k", ["kk", 2], 0, pR);
V("hmm", 0, 0, function() {
  return "" + zu.apply(this) + bn(this.minutes(), 2);
});
V("hmmss", 0, 0, function() {
  return "" + zu.apply(this) + bn(this.minutes(), 2) + bn(this.seconds(), 2);
});
V("Hmm", 0, 0, function() {
  return "" + this.hours() + bn(this.minutes(), 2);
});
V("Hmmss", 0, 0, function() {
  return "" + this.hours() + bn(this.minutes(), 2) + bn(this.seconds(), 2);
});
function D_(n, e) {
  V(n, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      e
    );
  });
}
D_("a", !0);
D_("A", !1);
function F_(n, e) {
  return e._meridiemParse;
}
W("a", F_);
W("A", F_);
W("H", Le, Nu);
W("h", Le, rs);
W("k", Le, rs);
W("HH", Le, Ut);
W("hh", Le, Ut);
W("kk", Le, Ut);
W("hmm", w_);
W("hmmss", S_);
W("Hmm", w_);
W("Hmmss", S_);
Se(["H", "HH"], Ze);
Se(["k", "kk"], function(n, e, t) {
  var i = de(n);
  e[Ze] = i === 24 ? 0 : i;
});
Se(["a", "A"], function(n, e, t) {
  t._isPm = t._locale.isPM(n), t._meridiem = n;
});
Se(["h", "hh"], function(n, e, t) {
  e[Ze] = de(n), ae(t).bigHour = !0;
});
Se("hmm", function(n, e, t) {
  var i = n.length - 2;
  e[Ze] = de(n.substr(0, i)), e[en] = de(n.substr(i)), ae(t).bigHour = !0;
});
Se("hmmss", function(n, e, t) {
  var i = n.length - 4, r = n.length - 2;
  e[Ze] = de(n.substr(0, i)), e[en] = de(n.substr(i, 2)), e[Hn] = de(n.substr(r)), ae(t).bigHour = !0;
});
Se("Hmm", function(n, e, t) {
  var i = n.length - 2;
  e[Ze] = de(n.substr(0, i)), e[en] = de(n.substr(i));
});
Se("Hmmss", function(n, e, t) {
  var i = n.length - 4, r = n.length - 2;
  e[Ze] = de(n.substr(0, i)), e[en] = de(n.substr(i, 2)), e[Hn] = de(n.substr(r));
});
function yR(n) {
  return (n + "").toLowerCase().charAt(0) === "p";
}
var xR = /[ap]\.?m?\.?/i, vR = ss("Hours", !0);
function ER(n, e, t) {
  return n > 11 ? t ? "pm" : "PM" : t ? "am" : "AM";
}
var k_ = {
  calendar: cb,
  longDateFormat: fb,
  invalidDate: mb,
  ordinal: pb,
  dayOfMonthOrdinalParse: yb,
  relativeTime: vb,
  months: kb,
  monthsShort: C_,
  week: Hb,
  weekdays: tR,
  weekdaysMin: nR,
  weekdaysShort: M_,
  meridiemParse: xR
}, Oe = {}, Ts = {}, no;
function TR(n, e) {
  var t, i = Math.min(n.length, e.length);
  for (t = 0; t < i; t += 1)
    if (n[t] !== e[t])
      return t;
  return i;
}
function Df(n) {
  return n && n.toLowerCase().replace("_", "-");
}
function wR(n) {
  for (var e = 0, t, i, r, s; e < n.length; ) {
    for (s = Df(n[e]).split("-"), t = s.length, i = Df(n[e + 1]), i = i ? i.split("-") : null; t > 0; ) {
      if (r = Sl(s.slice(0, t).join("-")), r)
        return r;
      if (i && i.length >= t && TR(s, i) >= t - 1)
        break;
      t--;
    }
    e++;
  }
  return no;
}
function SR(n) {
  return !!(n && n.match("^[^/\\\\]*$"));
}
function Sl(n) {
  var e = null, t;
  if (Oe[n] === void 0 && typeof module < "u" && module && module.exports && SR(n))
    try {
      e = no._abbr, t = require, t("./locale/" + n), bi(e);
    } catch {
      Oe[n] = null;
    }
  return Oe[n];
}
function bi(n, e) {
  var t;
  return n && (Ct(e) ? t = li(n) : t = Wu(n, e), t ? no = t : typeof console < "u" && console.warn && console.warn(
    "Locale " + n + " not found. Did you forget to load it?"
  )), no._abbr;
}
function Wu(n, e) {
  if (e !== null) {
    var t, i = k_;
    if (e.abbr = n, Oe[n] != null)
      x_(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), i = Oe[n]._config;
    else if (e.parentLocale != null)
      if (Oe[e.parentLocale] != null)
        i = Oe[e.parentLocale]._config;
      else if (t = Sl(e.parentLocale), t != null)
        i = t._config;
      else
        return Ts[e.parentLocale] || (Ts[e.parentLocale] = []), Ts[e.parentLocale].push({
          name: n,
          config: e
        }), null;
    return Oe[n] = new Ou(ch(i, e)), Ts[n] && Ts[n].forEach(function(r) {
      Wu(r.name, r.config);
    }), bi(n), Oe[n];
  } else
    return delete Oe[n], null;
}
function bR(n, e) {
  if (e != null) {
    var t, i, r = k_;
    Oe[n] != null && Oe[n].parentLocale != null ? Oe[n].set(ch(Oe[n]._config, e)) : (i = Sl(n), i != null && (r = i._config), e = ch(r, e), i == null && (e.abbr = n), t = new Ou(e), t.parentLocale = Oe[n], Oe[n] = t), bi(n);
  } else
    Oe[n] != null && (Oe[n].parentLocale != null ? (Oe[n] = Oe[n].parentLocale, n === bi() && bi(n)) : Oe[n] != null && delete Oe[n]);
  return Oe[n];
}
function li(n) {
  var e;
  if (n && n._locale && n._locale._abbr && (n = n._locale._abbr), !n)
    return no;
  if (!cn(n)) {
    if (e = Sl(n), e)
      return e;
    n = [n];
  }
  return wR(n);
}
function RR() {
  return hh(Oe);
}
function Yu(n) {
  var e, t = n._a;
  return t && ae(n).overflow === -2 && (e = t[Xn] < 0 || t[Xn] > 11 ? Xn : t[vn] < 1 || t[vn] > Gu(t[dt], t[Xn]) ? vn : t[Ze] < 0 || t[Ze] > 24 || t[Ze] === 24 && (t[en] !== 0 || t[Hn] !== 0 || t[$i] !== 0) ? Ze : t[en] < 0 || t[en] > 59 ? en : t[Hn] < 0 || t[Hn] > 59 ? Hn : t[$i] < 0 || t[$i] > 999 ? $i : -1, ae(n)._overflowDayOfYear && (e < dt || e > vn) && (e = vn), ae(n)._overflowWeeks && e === -1 && (e = Ab), ae(n)._overflowWeekday && e === -1 && (e = Lb), ae(n).overflow = e), n;
}
var CR = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, PR = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, IR = /Z|[+-]\d\d(?::?\d\d)?/, Jo = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], yc = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], AR = /^\/?Date\((-?\d+)/i, LR = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, OR = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function N_(n) {
  var e, t, i = n._i, r = CR.exec(i) || PR.exec(i), s, o, a, l, c = Jo.length, h = yc.length;
  if (r) {
    for (ae(n).iso = !0, e = 0, t = c; e < t; e++)
      if (Jo[e][1].exec(r[1])) {
        o = Jo[e][0], s = Jo[e][2] !== !1;
        break;
      }
    if (o == null) {
      n._isValid = !1;
      return;
    }
    if (r[3]) {
      for (e = 0, t = h; e < t; e++)
        if (yc[e][1].exec(r[3])) {
          a = (r[2] || " ") + yc[e][0];
          break;
        }
      if (a == null) {
        n._isValid = !1;
        return;
      }
    }
    if (!s && a != null) {
      n._isValid = !1;
      return;
    }
    if (r[4])
      if (IR.exec(r[4]))
        l = "Z";
      else {
        n._isValid = !1;
        return;
      }
    n._f = o + (a || "") + (l || ""), ju(n);
  } else
    n._isValid = !1;
}
function MR(n, e, t, i, r, s) {
  var o = [
    DR(n),
    C_.indexOf(e),
    parseInt(t, 10),
    parseInt(i, 10),
    parseInt(r, 10)
  ];
  return s && o.push(parseInt(s, 10)), o;
}
function DR(n) {
  var e = parseInt(n, 10);
  return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
}
function FR(n) {
  return n.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function kR(n, e, t) {
  if (n) {
    var i = M_.indexOf(n), r = new Date(
      e[0],
      e[1],
      e[2]
    ).getDay();
    if (i !== r)
      return ae(t).weekdayMismatch = !0, t._isValid = !1, !1;
  }
  return !0;
}
function NR(n, e, t) {
  if (n)
    return OR[n];
  if (e)
    return 0;
  var i = parseInt(t, 10), r = i % 100, s = (i - r) / 100;
  return s * 60 + r;
}
function G_(n) {
  var e = LR.exec(FR(n._i)), t;
  if (e) {
    if (t = MR(
      e[4],
      e[3],
      e[2],
      e[5],
      e[6],
      e[7]
    ), !kR(e[1], t, n))
      return;
    n._a = t, n._tzm = NR(e[8], e[9], e[10]), n._d = eo.apply(null, n._a), n._d.setUTCMinutes(n._d.getUTCMinutes() - n._tzm), ae(n).rfc2822 = !0;
  } else
    n._isValid = !1;
}
function GR(n) {
  var e = AR.exec(n._i);
  if (e !== null) {
    n._d = /* @__PURE__ */ new Date(+e[1]);
    return;
  }
  if (N_(n), n._isValid === !1)
    delete n._isValid;
  else
    return;
  if (G_(n), n._isValid === !1)
    delete n._isValid;
  else
    return;
  n._strict ? n._isValid = !1 : G.createFromInputFallback(n);
}
G.createFromInputFallback = Ht(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(n) {
    n._d = /* @__PURE__ */ new Date(n._i + (n._useUTC ? " UTC" : ""));
  }
);
function Or(n, e, t) {
  return n ?? e ?? t;
}
function UR(n) {
  var e = new Date(G.now());
  return n._useUTC ? [
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate()
  ] : [e.getFullYear(), e.getMonth(), e.getDate()];
}
function $u(n) {
  var e, t, i = [], r, s, o;
  if (!n._d) {
    for (r = UR(n), n._w && n._a[vn] == null && n._a[Xn] == null && BR(n), n._dayOfYear != null && (o = Or(n._a[dt], r[dt]), (n._dayOfYear > Ds(o) || n._dayOfYear === 0) && (ae(n)._overflowDayOfYear = !0), t = eo(o, 0, n._dayOfYear), n._a[Xn] = t.getUTCMonth(), n._a[vn] = t.getUTCDate()), e = 0; e < 3 && n._a[e] == null; ++e)
      n._a[e] = i[e] = r[e];
    for (; e < 7; e++)
      n._a[e] = i[e] = n._a[e] == null ? e === 2 ? 1 : 0 : n._a[e];
    n._a[Ze] === 24 && n._a[en] === 0 && n._a[Hn] === 0 && n._a[$i] === 0 && (n._nextDay = !0, n._a[Ze] = 0), n._d = (n._useUTC ? eo : Vb).apply(
      null,
      i
    ), s = n._useUTC ? n._d.getUTCDay() : n._d.getDay(), n._tzm != null && n._d.setUTCMinutes(n._d.getUTCMinutes() - n._tzm), n._nextDay && (n._a[Ze] = 24), n._w && typeof n._w.d < "u" && n._w.d !== s && (ae(n).weekdayMismatch = !0);
  }
}
function BR(n) {
  var e, t, i, r, s, o, a, l, c;
  e = n._w, e.GG != null || e.W != null || e.E != null ? (s = 1, o = 4, t = Or(
    e.GG,
    n._a[dt],
    to(Ae(), 1, 4).year
  ), i = Or(e.W, 1), r = Or(e.E, 1), (r < 1 || r > 7) && (l = !0)) : (s = n._locale._week.dow, o = n._locale._week.doy, c = to(Ae(), s, o), t = Or(e.gg, n._a[dt], c.year), i = Or(e.w, c.week), e.d != null ? (r = e.d, (r < 0 || r > 6) && (l = !0)) : e.e != null ? (r = e.e + s, (e.e < 0 || e.e > 6) && (l = !0)) : r = s), i < 1 || i > Qn(t, s, o) ? ae(n)._overflowWeeks = !0 : l != null ? ae(n)._overflowWeekday = !0 : (a = O_(t, i, r, s, o), n._a[dt] = a.year, n._dayOfYear = a.dayOfYear);
}
G.ISO_8601 = function() {
};
G.RFC_2822 = function() {
};
function ju(n) {
  if (n._f === G.ISO_8601) {
    N_(n);
    return;
  }
  if (n._f === G.RFC_2822) {
    G_(n);
    return;
  }
  n._a = [], ae(n).empty = !0;
  var e = "" + n._i, t, i, r, s, o, a = e.length, l = 0, c, h;
  for (r = v_(n._f, n._locale).match(Mu) || [], h = r.length, t = 0; t < h; t++)
    s = r[t], i = (e.match(Cb(s, n)) || [])[0], i && (o = e.substr(0, e.indexOf(i)), o.length > 0 && ae(n).unusedInput.push(o), e = e.slice(
      e.indexOf(i) + i.length
    ), l += i.length), zr[s] ? (i ? ae(n).empty = !1 : ae(n).unusedTokens.push(s), Ib(s, i, n)) : n._strict && !i && ae(n).unusedTokens.push(s);
  ae(n).charsLeftOver = a - l, e.length > 0 && ae(n).unusedInput.push(e), n._a[Ze] <= 12 && ae(n).bigHour === !0 && n._a[Ze] > 0 && (ae(n).bigHour = void 0), ae(n).parsedDateParts = n._a.slice(0), ae(n).meridiem = n._meridiem, n._a[Ze] = zR(
    n._locale,
    n._a[Ze],
    n._meridiem
  ), c = ae(n).era, c !== null && (n._a[dt] = n._locale.erasConvertYear(c, n._a[dt])), $u(n), Yu(n);
}
function zR(n, e, t) {
  var i;
  return t == null ? e : n.meridiemHour != null ? n.meridiemHour(e, t) : (n.isPM != null && (i = n.isPM(t), i && e < 12 && (e += 12), !i && e === 12 && (e = 0)), e);
}
function WR(n) {
  var e, t, i, r, s, o, a = !1, l = n._f.length;
  if (l === 0) {
    ae(n).invalidFormat = !0, n._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    s = 0, o = !1, e = Lu({}, n), n._useUTC != null && (e._useUTC = n._useUTC), e._f = n._f[r], ju(e), Au(e) && (o = !0), s += ae(e).charsLeftOver, s += ae(e).unusedTokens.length * 10, ae(e).score = s, a ? s < i && (i = s, t = e) : (i == null || s < i || o) && (i = s, t = e, o && (a = !0));
  Ei(n, t || e);
}
function YR(n) {
  if (!n._d) {
    var e = Du(n._i), t = e.day === void 0 ? e.date : e.day;
    n._a = p_(
      [e.year, e.month, t, e.hour, e.minute, e.second, e.millisecond],
      function(i) {
        return i && parseInt(i, 10);
      }
    ), $u(n);
  }
}
function $R(n) {
  var e = new bo(Yu(U_(n)));
  return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
}
function U_(n) {
  var e = n._i, t = n._f;
  return n._locale = n._locale || li(n._l), e === null || t === void 0 && e === "" ? pl({ nullInput: !0 }) : (typeof e == "string" && (n._i = e = n._locale.preparse(e)), hn(e) ? new bo(Yu(e)) : (So(e) ? n._d = e : cn(t) ? WR(n) : t ? ju(n) : jR(n), Au(n) || (n._d = null), n));
}
function jR(n) {
  var e = n._i;
  Ct(e) ? n._d = new Date(G.now()) : So(e) ? n._d = new Date(e.valueOf()) : typeof e == "string" ? GR(n) : cn(e) ? (n._a = p_(e.slice(0), function(t) {
    return parseInt(t, 10);
  }), $u(n)) : Ji(e) ? YR(n) : si(e) ? n._d = new Date(e) : G.createFromInputFallback(n);
}
function B_(n, e, t, i, r) {
  var s = {};
  return (e === !0 || e === !1) && (i = e, e = void 0), (t === !0 || t === !1) && (i = t, t = void 0), (Ji(n) && Iu(n) || cn(n) && n.length === 0) && (n = void 0), s._isAMomentObject = !0, s._useUTC = s._isUTC = r, s._l = t, s._i = n, s._f = e, s._strict = i, $R(s);
}
function Ae(n, e, t, i) {
  return B_(n, e, t, i, !1);
}
var VR = Ht(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var n = Ae.apply(null, arguments);
    return this.isValid() && n.isValid() ? n < this ? this : n : pl();
  }
), XR = Ht(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var n = Ae.apply(null, arguments);
    return this.isValid() && n.isValid() ? n > this ? this : n : pl();
  }
);
function z_(n, e) {
  var t, i;
  if (e.length === 1 && cn(e[0]) && (e = e[0]), !e.length)
    return Ae();
  for (t = e[0], i = 1; i < e.length; ++i)
    (!e[i].isValid() || e[i][n](t)) && (t = e[i]);
  return t;
}
function HR() {
  var n = [].slice.call(arguments, 0);
  return z_("isBefore", n);
}
function KR() {
  var n = [].slice.call(arguments, 0);
  return z_("isAfter", n);
}
var ZR = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, ws = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function qR(n) {
  var e, t = !1, i, r = ws.length;
  for (e in n)
    if (pe(n, e) && !(Ge.call(ws, e) !== -1 && (n[e] == null || !isNaN(n[e]))))
      return !1;
  for (i = 0; i < r; ++i)
    if (n[ws[i]]) {
      if (t)
        return !1;
      parseFloat(n[ws[i]]) !== de(n[ws[i]]) && (t = !0);
    }
  return !0;
}
function JR() {
  return this._isValid;
}
function QR() {
  return dn(NaN);
}
function bl(n) {
  var e = Du(n), t = e.year || 0, i = e.quarter || 0, r = e.month || 0, s = e.week || e.isoWeek || 0, o = e.day || 0, a = e.hour || 0, l = e.minute || 0, c = e.second || 0, h = e.millisecond || 0;
  this._isValid = qR(e), this._milliseconds = +h + c * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  a * 1e3 * 60 * 60, this._days = +o + s * 7, this._months = +r + i * 3 + t * 12, this._data = {}, this._locale = li(), this._bubble();
}
function sa(n) {
  return n instanceof bl;
}
function dh(n) {
  return n < 0 ? Math.round(-1 * n) * -1 : Math.round(n);
}
function eC(n, e, t) {
  var i = Math.min(n.length, e.length), r = Math.abs(n.length - e.length), s = 0, o;
  for (o = 0; o < i; o++)
    de(n[o]) !== de(e[o]) && s++;
  return s + r;
}
function W_(n, e) {
  V(n, 0, 0, function() {
    var t = this.utcOffset(), i = "+";
    return t < 0 && (t = -t, i = "-"), i + bn(~~(t / 60), 2) + e + bn(~~t % 60, 2);
  });
}
W_("Z", ":");
W_("ZZ", "");
W("Z", Tl);
W("ZZ", Tl);
Se(["Z", "ZZ"], function(n, e, t) {
  t._useUTC = !0, t._tzm = Vu(Tl, n);
});
var tC = /([\+\-]|\d\d)/gi;
function Vu(n, e) {
  var t = (e || "").match(n), i, r, s;
  return t === null ? null : (i = t[t.length - 1] || [], r = (i + "").match(tC) || ["-", 0, 0], s = +(r[1] * 60) + de(r[2]), s === 0 ? 0 : r[0] === "+" ? s : -s);
}
function Xu(n, e) {
  var t, i;
  return e._isUTC ? (t = e.clone(), i = (hn(n) || So(n) ? n.valueOf() : Ae(n).valueOf()) - t.valueOf(), t._d.setTime(t._d.valueOf() + i), G.updateOffset(t, !1), t) : Ae(n).local();
}
function fh(n) {
  return -Math.round(n._d.getTimezoneOffset());
}
G.updateOffset = function() {
};
function nC(n, e, t) {
  var i = this._offset || 0, r;
  if (!this.isValid())
    return n != null ? this : NaN;
  if (n != null) {
    if (typeof n == "string") {
      if (n = Vu(Tl, n), n === null)
        return this;
    } else Math.abs(n) < 16 && !t && (n = n * 60);
    return !this._isUTC && e && (r = fh(this)), this._offset = n, this._isUTC = !0, r != null && this.add(r, "m"), i !== n && (!e || this._changeInProgress ? j_(
      this,
      dn(n - i, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, G.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? i : fh(this);
}
function iC(n, e) {
  return n != null ? (typeof n != "string" && (n = -n), this.utcOffset(n, e), this) : -this.utcOffset();
}
function rC(n) {
  return this.utcOffset(0, n);
}
function sC(n) {
  return this._isUTC && (this.utcOffset(0, n), this._isUTC = !1, n && this.subtract(fh(this), "m")), this;
}
function oC() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var n = Vu(bb, this._i);
    n != null ? this.utcOffset(n) : this.utcOffset(0, !0);
  }
  return this;
}
function aC(n) {
  return this.isValid() ? (n = n ? Ae(n).utcOffset() : 0, (this.utcOffset() - n) % 60 === 0) : !1;
}
function lC() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function cC() {
  if (!Ct(this._isDSTShifted))
    return this._isDSTShifted;
  var n = {}, e;
  return Lu(n, this), n = U_(n), n._a ? (e = n._isUTC ? Cn(n._a) : Ae(n._a), this._isDSTShifted = this.isValid() && eC(n._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function hC() {
  return this.isValid() ? !this._isUTC : !1;
}
function uC() {
  return this.isValid() ? this._isUTC : !1;
}
function Y_() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var dC = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, fC = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function dn(n, e) {
  var t = n, i = null, r, s, o;
  return sa(n) ? t = {
    ms: n._milliseconds,
    d: n._days,
    M: n._months
  } : si(n) || !isNaN(+n) ? (t = {}, e ? t[e] = +n : t.milliseconds = +n) : (i = dC.exec(n)) ? (r = i[1] === "-" ? -1 : 1, t = {
    y: 0,
    d: de(i[vn]) * r,
    h: de(i[Ze]) * r,
    m: de(i[en]) * r,
    s: de(i[Hn]) * r,
    ms: de(dh(i[$i] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (i = fC.exec(n)) ? (r = i[1] === "-" ? -1 : 1, t = {
    y: ki(i[2], r),
    M: ki(i[3], r),
    w: ki(i[4], r),
    d: ki(i[5], r),
    h: ki(i[6], r),
    m: ki(i[7], r),
    s: ki(i[8], r)
  }) : t == null ? t = {} : typeof t == "object" && ("from" in t || "to" in t) && (o = gC(
    Ae(t.from),
    Ae(t.to)
  ), t = {}, t.ms = o.milliseconds, t.M = o.months), s = new bl(t), sa(n) && pe(n, "_locale") && (s._locale = n._locale), sa(n) && pe(n, "_isValid") && (s._isValid = n._isValid), s;
}
dn.fn = bl.prototype;
dn.invalid = QR;
function ki(n, e) {
  var t = n && parseFloat(n.replace(",", "."));
  return (isNaN(t) ? 0 : t) * e;
}
function Ff(n, e) {
  var t = {};
  return t.months = e.month() - n.month() + (e.year() - n.year()) * 12, n.clone().add(t.months, "M").isAfter(e) && --t.months, t.milliseconds = +e - +n.clone().add(t.months, "M"), t;
}
function gC(n, e) {
  var t;
  return n.isValid() && e.isValid() ? (e = Xu(e, n), n.isBefore(e) ? t = Ff(n, e) : (t = Ff(e, n), t.milliseconds = -t.milliseconds, t.months = -t.months), t) : { milliseconds: 0, months: 0 };
}
function $_(n, e) {
  return function(t, i) {
    var r, s;
    return i !== null && !isNaN(+i) && (x_(
      e,
      "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), s = t, t = i, i = s), r = dn(t, i), j_(this, r, n), this;
  };
}
function j_(n, e, t, i) {
  var r = e._milliseconds, s = dh(e._days), o = dh(e._months);
  n.isValid() && (i = i ?? !0, o && I_(n, Qs(n, "Month") + o * t), s && R_(n, "Date", Qs(n, "Date") + s * t), r && n._d.setTime(n._d.valueOf() + r * t), i && G.updateOffset(n, s || o));
}
var mC = $_(1, "add"), _C = $_(-1, "subtract");
function V_(n) {
  return typeof n == "string" || n instanceof String;
}
function pC(n) {
  return hn(n) || So(n) || V_(n) || si(n) || xC(n) || yC(n) || n === null || n === void 0;
}
function yC(n) {
  var e = Ji(n) && !Iu(n), t = !1, i = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, s, o = i.length;
  for (r = 0; r < o; r += 1)
    s = i[r], t = t || pe(n, s);
  return e && t;
}
function xC(n) {
  var e = cn(n), t = !1;
  return e && (t = n.filter(function(i) {
    return !si(i) && V_(n);
  }).length === 0), e && t;
}
function vC(n) {
  var e = Ji(n) && !Iu(n), t = !1, i = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, s;
  for (r = 0; r < i.length; r += 1)
    s = i[r], t = t || pe(n, s);
  return e && t;
}
function EC(n, e) {
  var t = n.diff(e, "days", !0);
  return t < -6 ? "sameElse" : t < -1 ? "lastWeek" : t < 0 ? "lastDay" : t < 1 ? "sameDay" : t < 2 ? "nextDay" : t < 7 ? "nextWeek" : "sameElse";
}
function TC(n, e) {
  arguments.length === 1 && (arguments[0] ? pC(arguments[0]) ? (n = arguments[0], e = void 0) : vC(arguments[0]) && (e = arguments[0], n = void 0) : (n = void 0, e = void 0));
  var t = n || Ae(), i = Xu(t, this).startOf("day"), r = G.calendarFormat(this, i) || "sameElse", s = e && (Pn(e[r]) ? e[r].call(this, t) : e[r]);
  return this.format(
    s || this.localeData().calendar(r, this, Ae(t))
  );
}
function wC() {
  return new bo(this);
}
function SC(n, e) {
  var t = hn(n) ? n : Ae(n);
  return this.isValid() && t.isValid() ? (e = Kt(e) || "millisecond", e === "millisecond" ? this.valueOf() > t.valueOf() : t.valueOf() < this.clone().startOf(e).valueOf()) : !1;
}
function bC(n, e) {
  var t = hn(n) ? n : Ae(n);
  return this.isValid() && t.isValid() ? (e = Kt(e) || "millisecond", e === "millisecond" ? this.valueOf() < t.valueOf() : this.clone().endOf(e).valueOf() < t.valueOf()) : !1;
}
function RC(n, e, t, i) {
  var r = hn(n) ? n : Ae(n), s = hn(e) ? e : Ae(e);
  return this.isValid() && r.isValid() && s.isValid() ? (i = i || "()", (i[0] === "(" ? this.isAfter(r, t) : !this.isBefore(r, t)) && (i[1] === ")" ? this.isBefore(s, t) : !this.isAfter(s, t))) : !1;
}
function CC(n, e) {
  var t = hn(n) ? n : Ae(n), i;
  return this.isValid() && t.isValid() ? (e = Kt(e) || "millisecond", e === "millisecond" ? this.valueOf() === t.valueOf() : (i = t.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf())) : !1;
}
function PC(n, e) {
  return this.isSame(n, e) || this.isAfter(n, e);
}
function IC(n, e) {
  return this.isSame(n, e) || this.isBefore(n, e);
}
function AC(n, e, t) {
  var i, r, s;
  if (!this.isValid())
    return NaN;
  if (i = Xu(n, this), !i.isValid())
    return NaN;
  switch (r = (i.utcOffset() - this.utcOffset()) * 6e4, e = Kt(e), e) {
    case "year":
      s = oa(this, i) / 12;
      break;
    case "month":
      s = oa(this, i);
      break;
    case "quarter":
      s = oa(this, i) / 3;
      break;
    case "second":
      s = (this - i) / 1e3;
      break;
    case "minute":
      s = (this - i) / 6e4;
      break;
    case "hour":
      s = (this - i) / 36e5;
      break;
    case "day":
      s = (this - i - r) / 864e5;
      break;
    case "week":
      s = (this - i - r) / 6048e5;
      break;
    default:
      s = this - i;
  }
  return t ? s : Yt(s);
}
function oa(n, e) {
  if (n.date() < e.date())
    return -oa(e, n);
  var t = (e.year() - n.year()) * 12 + (e.month() - n.month()), i = n.clone().add(t, "months"), r, s;
  return e - i < 0 ? (r = n.clone().add(t - 1, "months"), s = (e - i) / (i - r)) : (r = n.clone().add(t + 1, "months"), s = (e - i) / (r - i)), -(t + s) || 0;
}
G.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
G.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function LC() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function OC(n) {
  if (!this.isValid())
    return null;
  var e = n !== !0, t = e ? this.clone().utc() : this;
  return t.year() < 0 || t.year() > 9999 ? ra(
    t,
    e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : Pn(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", ra(t, "Z")) : ra(
    t,
    e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function MC() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var n = "moment", e = "", t, i, r, s;
  return this.isLocal() || (n = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), t = "[" + n + '("]', i = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", s = e + '[")]', this.format(t + i + r + s);
}
function DC(n) {
  n || (n = this.isUtc() ? G.defaultFormatUtc : G.defaultFormat);
  var e = ra(this, n);
  return this.localeData().postformat(e);
}
function FC(n, e) {
  return this.isValid() && (hn(n) && n.isValid() || Ae(n).isValid()) ? dn({ to: this, from: n }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function kC(n) {
  return this.from(Ae(), n);
}
function NC(n, e) {
  return this.isValid() && (hn(n) && n.isValid() || Ae(n).isValid()) ? dn({ from: this, to: n }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function GC(n) {
  return this.to(Ae(), n);
}
function X_(n) {
  var e;
  return n === void 0 ? this._locale._abbr : (e = li(n), e != null && (this._locale = e), this);
}
var H_ = Ht(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(n) {
    return n === void 0 ? this.localeData() : this.locale(n);
  }
);
function K_() {
  return this._locale;
}
var Da = 1e3, Wr = 60 * Da, Fa = 60 * Wr, Z_ = (365 * 400 + 97) * 24 * Fa;
function Yr(n, e) {
  return (n % e + e) % e;
}
function q_(n, e, t) {
  return n < 100 && n >= 0 ? new Date(n + 400, e, t) - Z_ : new Date(n, e, t).valueOf();
}
function J_(n, e, t) {
  return n < 100 && n >= 0 ? Date.UTC(n + 400, e, t) - Z_ : Date.UTC(n, e, t);
}
function UC(n) {
  var e, t;
  if (n = Kt(n), n === void 0 || n === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? J_ : q_, n) {
    case "year":
      e = t(this.year(), 0, 1);
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      e = t(this.year(), this.month(), 1);
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date());
      break;
    case "hour":
      e = this._d.valueOf(), e -= Yr(
        e + (this._isUTC ? 0 : this.utcOffset() * Wr),
        Fa
      );
      break;
    case "minute":
      e = this._d.valueOf(), e -= Yr(e, Wr);
      break;
    case "second":
      e = this._d.valueOf(), e -= Yr(e, Da);
      break;
  }
  return this._d.setTime(e), G.updateOffset(this, !0), this;
}
function BC(n) {
  var e, t;
  if (n = Kt(n), n === void 0 || n === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? J_ : q_, n) {
    case "year":
      e = t(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      e = t(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      e = this._d.valueOf(), e += Fa - Yr(
        e + (this._isUTC ? 0 : this.utcOffset() * Wr),
        Fa
      ) - 1;
      break;
    case "minute":
      e = this._d.valueOf(), e += Wr - Yr(e, Wr) - 1;
      break;
    case "second":
      e = this._d.valueOf(), e += Da - Yr(e, Da) - 1;
      break;
  }
  return this._d.setTime(e), G.updateOffset(this, !0), this;
}
function zC() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function WC() {
  return Math.floor(this.valueOf() / 1e3);
}
function YC() {
  return new Date(this.valueOf());
}
function $C() {
  var n = this;
  return [
    n.year(),
    n.month(),
    n.date(),
    n.hour(),
    n.minute(),
    n.second(),
    n.millisecond()
  ];
}
function jC() {
  var n = this;
  return {
    years: n.year(),
    months: n.month(),
    date: n.date(),
    hours: n.hours(),
    minutes: n.minutes(),
    seconds: n.seconds(),
    milliseconds: n.milliseconds()
  };
}
function VC() {
  return this.isValid() ? this.toISOString() : null;
}
function XC() {
  return Au(this);
}
function HC() {
  return Ei({}, ae(this));
}
function KC() {
  return ae(this).overflow;
}
function ZC() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
V("N", 0, 0, "eraAbbr");
V("NN", 0, 0, "eraAbbr");
V("NNN", 0, 0, "eraAbbr");
V("NNNN", 0, 0, "eraName");
V("NNNNN", 0, 0, "eraNarrow");
V("y", ["y", 1], "yo", "eraYear");
V("y", ["yy", 2], 0, "eraYear");
V("y", ["yyy", 3], 0, "eraYear");
V("y", ["yyyy", 4], 0, "eraYear");
W("N", Hu);
W("NN", Hu);
W("NNN", Hu);
W("NNNN", aP);
W("NNNNN", lP);
Se(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(n, e, t, i) {
    var r = t._locale.erasParse(n, i, t._strict);
    r ? ae(t).era = r : ae(t).invalidEra = n;
  }
);
W("y", is);
W("yy", is);
W("yyy", is);
W("yyyy", is);
W("yo", cP);
Se(["y", "yy", "yyy", "yyyy"], dt);
Se(["yo"], function(n, e, t, i) {
  var r;
  t._locale._eraYearOrdinalRegex && (r = n.match(t._locale._eraYearOrdinalRegex)), t._locale.eraYearOrdinalParse ? e[dt] = t._locale.eraYearOrdinalParse(n, r) : e[dt] = parseInt(n, 10);
});
function qC(n, e) {
  var t, i, r, s = this._eras || li("en")._eras;
  for (t = 0, i = s.length; t < i; ++t) {
    switch (typeof s[t].since) {
      case "string":
        r = G(s[t].since).startOf("day"), s[t].since = r.valueOf();
        break;
    }
    switch (typeof s[t].until) {
      case "undefined":
        s[t].until = 1 / 0;
        break;
      case "string":
        r = G(s[t].until).startOf("day").valueOf(), s[t].until = r.valueOf();
        break;
    }
  }
  return s;
}
function JC(n, e, t) {
  var i, r, s = this.eras(), o, a, l;
  for (n = n.toUpperCase(), i = 0, r = s.length; i < r; ++i)
    if (o = s[i].name.toUpperCase(), a = s[i].abbr.toUpperCase(), l = s[i].narrow.toUpperCase(), t)
      switch (e) {
        case "N":
        case "NN":
        case "NNN":
          if (a === n)
            return s[i];
          break;
        case "NNNN":
          if (o === n)
            return s[i];
          break;
        case "NNNNN":
          if (l === n)
            return s[i];
          break;
      }
    else if ([o, a, l].indexOf(n) >= 0)
      return s[i];
}
function QC(n, e) {
  var t = n.since <= n.until ? 1 : -1;
  return e === void 0 ? G(n.since).year() : G(n.since).year() + (e - n.offset) * t;
}
function eP() {
  var n, e, t, i = this.localeData().eras();
  for (n = 0, e = i.length; n < e; ++n)
    if (t = this.clone().startOf("day").valueOf(), i[n].since <= t && t <= i[n].until || i[n].until <= t && t <= i[n].since)
      return i[n].name;
  return "";
}
function tP() {
  var n, e, t, i = this.localeData().eras();
  for (n = 0, e = i.length; n < e; ++n)
    if (t = this.clone().startOf("day").valueOf(), i[n].since <= t && t <= i[n].until || i[n].until <= t && t <= i[n].since)
      return i[n].narrow;
  return "";
}
function nP() {
  var n, e, t, i = this.localeData().eras();
  for (n = 0, e = i.length; n < e; ++n)
    if (t = this.clone().startOf("day").valueOf(), i[n].since <= t && t <= i[n].until || i[n].until <= t && t <= i[n].since)
      return i[n].abbr;
  return "";
}
function iP() {
  var n, e, t, i, r = this.localeData().eras();
  for (n = 0, e = r.length; n < e; ++n)
    if (t = r[n].since <= r[n].until ? 1 : -1, i = this.clone().startOf("day").valueOf(), r[n].since <= i && i <= r[n].until || r[n].until <= i && i <= r[n].since)
      return (this.year() - G(r[n].since).year()) * t + r[n].offset;
  return this.year();
}
function rP(n) {
  return pe(this, "_erasNameRegex") || Ku.call(this), n ? this._erasNameRegex : this._erasRegex;
}
function sP(n) {
  return pe(this, "_erasAbbrRegex") || Ku.call(this), n ? this._erasAbbrRegex : this._erasRegex;
}
function oP(n) {
  return pe(this, "_erasNarrowRegex") || Ku.call(this), n ? this._erasNarrowRegex : this._erasRegex;
}
function Hu(n, e) {
  return e.erasAbbrRegex(n);
}
function aP(n, e) {
  return e.erasNameRegex(n);
}
function lP(n, e) {
  return e.erasNarrowRegex(n);
}
function cP(n, e) {
  return e._eraYearOrdinalRegex || is;
}
function Ku() {
  var n = [], e = [], t = [], i = [], r, s, o, a, l, c = this.eras();
  for (r = 0, s = c.length; r < s; ++r)
    o = Jn(c[r].name), a = Jn(c[r].abbr), l = Jn(c[r].narrow), e.push(o), n.push(a), t.push(l), i.push(o), i.push(a), i.push(l);
  this._erasRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
V(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
V(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function Rl(n, e) {
  V(0, [n, n.length], 0, e);
}
Rl("gggg", "weekYear");
Rl("ggggg", "weekYear");
Rl("GGGG", "isoWeekYear");
Rl("GGGGG", "isoWeekYear");
W("G", El);
W("g", El);
W("GG", Le, Ut);
W("gg", Le, Ut);
W("GGGG", ku, Fu);
W("gggg", ku, Fu);
W("GGGGG", vl, yl);
W("ggggg", vl, yl);
Co(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(n, e, t, i) {
    e[i.substr(0, 2)] = de(n);
  }
);
Co(["gg", "GG"], function(n, e, t, i) {
  e[i] = G.parseTwoDigitYear(n);
});
function hP(n) {
  return Q_.call(
    this,
    n,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function uP(n) {
  return Q_.call(
    this,
    n,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function dP() {
  return Qn(this.year(), 1, 4);
}
function fP() {
  return Qn(this.isoWeekYear(), 1, 4);
}
function gP() {
  var n = this.localeData()._week;
  return Qn(this.year(), n.dow, n.doy);
}
function mP() {
  var n = this.localeData()._week;
  return Qn(this.weekYear(), n.dow, n.doy);
}
function Q_(n, e, t, i, r) {
  var s;
  return n == null ? to(this, i, r).year : (s = Qn(n, i, r), e > s && (e = s), _P.call(this, n, e, t, i, r));
}
function _P(n, e, t, i, r) {
  var s = O_(n, e, t, i, r), o = eo(s.year, 0, s.dayOfYear);
  return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this;
}
V("Q", 0, "Qo", "quarter");
W("Q", E_);
Se("Q", function(n, e) {
  e[Xn] = (de(n) - 1) * 3;
});
function pP(n) {
  return n == null ? Math.ceil((this.month() + 1) / 3) : this.month((n - 1) * 3 + this.month() % 3);
}
V("D", ["DD", 2], "Do", "date");
W("D", Le, rs);
W("DD", Le, Ut);
W("Do", function(n, e) {
  return n ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
});
Se(["D", "DD"], vn);
Se("Do", function(n, e) {
  e[vn] = de(n.match(Le)[0]);
});
var ep = ss("Date", !0);
V("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
W("DDD", xl);
W("DDDD", T_);
Se(["DDD", "DDDD"], function(n, e, t) {
  t._dayOfYear = de(n);
});
function yP(n) {
  var e = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return n == null ? e : this.add(n - e, "d");
}
V("m", ["mm", 2], 0, "minute");
W("m", Le, Nu);
W("mm", Le, Ut);
Se(["m", "mm"], en);
var xP = ss("Minutes", !1);
V("s", ["ss", 2], 0, "second");
W("s", Le, Nu);
W("ss", Le, Ut);
Se(["s", "ss"], Hn);
var vP = ss("Seconds", !1);
V("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
V(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
V(0, ["SSS", 3], 0, "millisecond");
V(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
V(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
V(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
V(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
V(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
V(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
W("S", xl, E_);
W("SS", xl, Ut);
W("SSS", xl, T_);
var Ti, tp;
for (Ti = "SSSS"; Ti.length <= 9; Ti += "S")
  W(Ti, is);
function EP(n, e) {
  e[$i] = de(("0." + n) * 1e3);
}
for (Ti = "S"; Ti.length <= 9; Ti += "S")
  Se(Ti, EP);
tp = ss("Milliseconds", !1);
V("z", 0, 0, "zoneAbbr");
V("zz", 0, 0, "zoneName");
function TP() {
  return this._isUTC ? "UTC" : "";
}
function wP() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var M = bo.prototype;
M.add = mC;
M.calendar = TC;
M.clone = wC;
M.diff = AC;
M.endOf = BC;
M.format = DC;
M.from = FC;
M.fromNow = kC;
M.to = NC;
M.toNow = GC;
M.get = Mb;
M.invalidAt = KC;
M.isAfter = SC;
M.isBefore = bC;
M.isBetween = RC;
M.isSame = CC;
M.isSameOrAfter = PC;
M.isSameOrBefore = IC;
M.isValid = XC;
M.lang = H_;
M.locale = X_;
M.localeData = K_;
M.max = XR;
M.min = VR;
M.parsingFlags = HC;
M.set = Db;
M.startOf = UC;
M.subtract = _C;
M.toArray = $C;
M.toObject = jC;
M.toDate = YC;
M.toISOString = OC;
M.inspect = MC;
typeof Symbol < "u" && Symbol.for != null && (M[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
M.toJSON = VC;
M.toString = LC;
M.unix = WC;
M.valueOf = zC;
M.creationData = ZC;
M.eraName = eP;
M.eraNarrow = tP;
M.eraAbbr = nP;
M.eraYear = iP;
M.year = b_;
M.isLeapYear = Ob;
M.weekYear = hP;
M.isoWeekYear = uP;
M.quarter = M.quarters = pP;
M.month = A_;
M.daysInMonth = Yb;
M.week = M.weeks = qb;
M.isoWeek = M.isoWeeks = Jb;
M.weeksInYear = gP;
M.weeksInWeekYear = mP;
M.isoWeeksInYear = dP;
M.isoWeeksInISOWeekYear = fP;
M.date = ep;
M.day = M.days = uR;
M.weekday = dR;
M.isoWeekday = fR;
M.dayOfYear = yP;
M.hour = M.hours = vR;
M.minute = M.minutes = xP;
M.second = M.seconds = vP;
M.millisecond = M.milliseconds = tp;
M.utcOffset = nC;
M.utc = rC;
M.local = sC;
M.parseZone = oC;
M.hasAlignedHourOffset = aC;
M.isDST = lC;
M.isLocal = hC;
M.isUtcOffset = uC;
M.isUtc = Y_;
M.isUTC = Y_;
M.zoneAbbr = TP;
M.zoneName = wP;
M.dates = Ht(
  "dates accessor is deprecated. Use date instead.",
  ep
);
M.months = Ht(
  "months accessor is deprecated. Use month instead",
  A_
);
M.years = Ht(
  "years accessor is deprecated. Use year instead",
  b_
);
M.zone = Ht(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  iC
);
M.isDSTShifted = Ht(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  cC
);
function SP(n) {
  return Ae(n * 1e3);
}
function bP() {
  return Ae.apply(null, arguments).parseZone();
}
function np(n) {
  return n;
}
var ye = Ou.prototype;
ye.calendar = hb;
ye.longDateFormat = gb;
ye.invalidDate = _b;
ye.ordinal = xb;
ye.preparse = np;
ye.postformat = np;
ye.relativeTime = Eb;
ye.pastFuture = Tb;
ye.set = lb;
ye.eras = qC;
ye.erasParse = JC;
ye.erasConvertYear = QC;
ye.erasAbbrRegex = sP;
ye.erasNameRegex = rP;
ye.erasNarrowRegex = oP;
ye.months = Ub;
ye.monthsShort = Bb;
ye.monthsParse = Wb;
ye.monthsRegex = jb;
ye.monthsShortRegex = $b;
ye.week = Xb;
ye.firstDayOfYear = Zb;
ye.firstDayOfWeek = Kb;
ye.weekdays = oR;
ye.weekdaysMin = lR;
ye.weekdaysShort = aR;
ye.weekdaysParse = hR;
ye.weekdaysRegex = gR;
ye.weekdaysShortRegex = mR;
ye.weekdaysMinRegex = _R;
ye.isPM = yR;
ye.meridiem = ER;
function ka(n, e, t, i) {
  var r = li(), s = Cn().set(i, e);
  return r[t](s, n);
}
function ip(n, e, t) {
  if (si(n) && (e = n, n = void 0), n = n || "", e != null)
    return ka(n, e, t, "month");
  var i, r = [];
  for (i = 0; i < 12; i++)
    r[i] = ka(n, i, t, "month");
  return r;
}
function Zu(n, e, t, i) {
  typeof n == "boolean" ? (si(e) && (t = e, e = void 0), e = e || "") : (e = n, t = e, n = !1, si(e) && (t = e, e = void 0), e = e || "");
  var r = li(), s = n ? r._week.dow : 0, o, a = [];
  if (t != null)
    return ka(e, (t + s) % 7, i, "day");
  for (o = 0; o < 7; o++)
    a[o] = ka(e, (o + s) % 7, i, "day");
  return a;
}
function RP(n, e) {
  return ip(n, e, "months");
}
function CP(n, e) {
  return ip(n, e, "monthsShort");
}
function PP(n, e, t) {
  return Zu(n, e, t, "weekdays");
}
function IP(n, e, t) {
  return Zu(n, e, t, "weekdaysShort");
}
function AP(n, e, t) {
  return Zu(n, e, t, "weekdaysMin");
}
bi("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(n) {
    var e = n % 10, t = de(n % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
    return n + t;
  }
});
G.lang = Ht(
  "moment.lang is deprecated. Use moment.locale instead.",
  bi
);
G.langData = Ht(
  "moment.langData is deprecated. Use moment.localeData instead.",
  li
);
var Un = Math.abs;
function LP() {
  var n = this._data;
  return this._milliseconds = Un(this._milliseconds), this._days = Un(this._days), this._months = Un(this._months), n.milliseconds = Un(n.milliseconds), n.seconds = Un(n.seconds), n.minutes = Un(n.minutes), n.hours = Un(n.hours), n.months = Un(n.months), n.years = Un(n.years), this;
}
function rp(n, e, t, i) {
  var r = dn(e, t);
  return n._milliseconds += i * r._milliseconds, n._days += i * r._days, n._months += i * r._months, n._bubble();
}
function OP(n, e) {
  return rp(this, n, e, 1);
}
function MP(n, e) {
  return rp(this, n, e, -1);
}
function kf(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
}
function DP() {
  var n = this._milliseconds, e = this._days, t = this._months, i = this._data, r, s, o, a, l;
  return n >= 0 && e >= 0 && t >= 0 || n <= 0 && e <= 0 && t <= 0 || (n += kf(gh(t) + e) * 864e5, e = 0, t = 0), i.milliseconds = n % 1e3, r = Yt(n / 1e3), i.seconds = r % 60, s = Yt(r / 60), i.minutes = s % 60, o = Yt(s / 60), i.hours = o % 24, e += Yt(o / 24), l = Yt(sp(e)), t += l, e -= kf(gh(l)), a = Yt(t / 12), t %= 12, i.days = e, i.months = t, i.years = a, this;
}
function sp(n) {
  return n * 4800 / 146097;
}
function gh(n) {
  return n * 146097 / 4800;
}
function FP(n) {
  if (!this.isValid())
    return NaN;
  var e, t, i = this._milliseconds;
  if (n = Kt(n), n === "month" || n === "quarter" || n === "year")
    switch (e = this._days + i / 864e5, t = this._months + sp(e), n) {
      case "month":
        return t;
      case "quarter":
        return t / 3;
      case "year":
        return t / 12;
    }
  else
    switch (e = this._days + Math.round(gh(this._months)), n) {
      case "week":
        return e / 7 + i / 6048e5;
      case "day":
        return e + i / 864e5;
      case "hour":
        return e * 24 + i / 36e5;
      case "minute":
        return e * 1440 + i / 6e4;
      case "second":
        return e * 86400 + i / 1e3;
      case "millisecond":
        return Math.floor(e * 864e5) + i;
      default:
        throw new Error("Unknown unit " + n);
    }
}
function ci(n) {
  return function() {
    return this.as(n);
  };
}
var op = ci("ms"), kP = ci("s"), NP = ci("m"), GP = ci("h"), UP = ci("d"), BP = ci("w"), zP = ci("M"), WP = ci("Q"), YP = ci("y"), $P = op;
function jP() {
  return dn(this);
}
function VP(n) {
  return n = Kt(n), this.isValid() ? this[n + "s"]() : NaN;
}
function ur(n) {
  return function() {
    return this.isValid() ? this._data[n] : NaN;
  };
}
var XP = ur("milliseconds"), HP = ur("seconds"), KP = ur("minutes"), ZP = ur("hours"), qP = ur("days"), JP = ur("months"), QP = ur("years");
function eI() {
  return Yt(this.days() / 7);
}
var Yn = Math.round, kr = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function tI(n, e, t, i, r) {
  return r.relativeTime(e || 1, !!t, n, i);
}
function nI(n, e, t, i) {
  var r = dn(n).abs(), s = Yn(r.as("s")), o = Yn(r.as("m")), a = Yn(r.as("h")), l = Yn(r.as("d")), c = Yn(r.as("M")), h = Yn(r.as("w")), u = Yn(r.as("y")), d = s <= t.ss && ["s", s] || s < t.s && ["ss", s] || o <= 1 && ["m"] || o < t.m && ["mm", o] || a <= 1 && ["h"] || a < t.h && ["hh", a] || l <= 1 && ["d"] || l < t.d && ["dd", l];
  return t.w != null && (d = d || h <= 1 && ["w"] || h < t.w && ["ww", h]), d = d || c <= 1 && ["M"] || c < t.M && ["MM", c] || u <= 1 && ["y"] || ["yy", u], d[2] = e, d[3] = +n > 0, d[4] = i, tI.apply(null, d);
}
function iI(n) {
  return n === void 0 ? Yn : typeof n == "function" ? (Yn = n, !0) : !1;
}
function rI(n, e) {
  return kr[n] === void 0 ? !1 : e === void 0 ? kr[n] : (kr[n] = e, n === "s" && (kr.ss = e - 1), !0);
}
function sI(n, e) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var t = !1, i = kr, r, s;
  return typeof n == "object" && (e = n, n = !1), typeof n == "boolean" && (t = n), typeof e == "object" && (i = Object.assign({}, kr, e), e.s != null && e.ss == null && (i.ss = e.s - 1)), r = this.localeData(), s = nI(this, !t, i, r), t && (s = r.pastFuture(+this, s)), r.postformat(s);
}
var xc = Math.abs;
function Cr(n) {
  return (n > 0) - (n < 0) || +n;
}
function Cl() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var n = xc(this._milliseconds) / 1e3, e = xc(this._days), t = xc(this._months), i, r, s, o, a = this.asSeconds(), l, c, h, u;
  return a ? (i = Yt(n / 60), r = Yt(i / 60), n %= 60, i %= 60, s = Yt(t / 12), t %= 12, o = n ? n.toFixed(3).replace(/\.?0+$/, "") : "", l = a < 0 ? "-" : "", c = Cr(this._months) !== Cr(a) ? "-" : "", h = Cr(this._days) !== Cr(a) ? "-" : "", u = Cr(this._milliseconds) !== Cr(a) ? "-" : "", l + "P" + (s ? c + s + "Y" : "") + (t ? c + t + "M" : "") + (e ? h + e + "D" : "") + (r || i || n ? "T" : "") + (r ? u + r + "H" : "") + (i ? u + i + "M" : "") + (n ? u + o + "S" : "")) : "P0D";
}
var me = bl.prototype;
me.isValid = JR;
me.abs = LP;
me.add = OP;
me.subtract = MP;
me.as = FP;
me.asMilliseconds = op;
me.asSeconds = kP;
me.asMinutes = NP;
me.asHours = GP;
me.asDays = UP;
me.asWeeks = BP;
me.asMonths = zP;
me.asQuarters = WP;
me.asYears = YP;
me.valueOf = $P;
me._bubble = DP;
me.clone = jP;
me.get = VP;
me.milliseconds = XP;
me.seconds = HP;
me.minutes = KP;
me.hours = ZP;
me.days = qP;
me.weeks = eI;
me.months = JP;
me.years = QP;
me.humanize = sI;
me.toISOString = Cl;
me.toString = Cl;
me.toJSON = Cl;
me.locale = X_;
me.localeData = K_;
me.toIsoString = Ht(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Cl
);
me.lang = H_;
V("X", 0, 0, "unix");
V("x", 0, 0, "valueOf");
W("x", El);
W("X", Rb);
Se("X", function(n, e, t) {
  t._d = new Date(parseFloat(n) * 1e3);
});
Se("x", function(n, e, t) {
  t._d = new Date(de(n));
});
//! moment.js
G.version = "2.30.1";
ob(Ae);
G.fn = M;
G.min = HR;
G.max = KR;
G.now = ZR;
G.utc = Cn;
G.unix = SP;
G.months = RP;
G.isDate = So;
G.locale = bi;
G.invalid = pl;
G.duration = dn;
G.isMoment = hn;
G.weekdays = PP;
G.parseZone = bP;
G.localeData = li;
G.isDuration = sa;
G.monthsShort = CP;
G.weekdaysMin = AP;
G.defineLocale = Wu;
G.updateLocale = bR;
G.locales = RR;
G.weekdaysShort = IP;
G.normalizeUnits = Kt;
G.relativeTimeRounding = iI;
G.relativeTimeThreshold = rI;
G.calendarFormat = EC;
G.prototype = M;
G.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const Fs = (...n) => n.filter((e) => !!e).join(" ");
function oI(n) {
  return xo({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }, child: [] }, { tag: "path", attr: { d: "M4.6 7l14.8 0" }, child: [] }, { tag: "path", attr: { d: "M3 12l18 0" }, child: [] }, { tag: "path", attr: { d: "M4.6 17l14.8 0" }, child: [] }] })(n);
}
function aI(n) {
  return xo({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }, child: [] }, { tag: "path", attr: { d: "M11.5 3a11.2 11.2 0 0 0 0 18" }, child: [] }, { tag: "path", attr: { d: "M12.5 3a11.2 11.2 0 0 1 0 18" }, child: [] }, { tag: "path", attr: { d: "M12 3l0 18" }, child: [] }] })(n);
}
const lI = () => {
  const n = tn.use.map(), [e, t] = st([0, 0]);
  return xt(() => {
    const i = (r) => {
      const s = rn(r.coordinate, "EPSG:3857", "EPSG:4326");
      t(s);
    };
    n.on("pointermove", i);
  }, [n]), /* @__PURE__ */ j.jsxs("div", { className: au.latLon, children: [
    /* @__PURE__ */ j.jsx(
      aI,
      {
        size: 24,
        display: "inline",
        strokeWidth: "1.5",
        preserveAspectRatio: "xMinYMin meet"
      }
    ),
    /* @__PURE__ */ j.jsx("span", { children: e[0].toFixed(4) }),
    "     ",
    /* @__PURE__ */ j.jsx(
      oI,
      {
        size: 24,
        display: "inline",
        strokeWidth: "1.5",
        preserveAspectRatio: "xMinYMin meet"
      }
    ),
    /* @__PURE__ */ j.jsx("span", { children: e[1].toFixed(4) })
  ] });
};
function cI(n) {
  return xo({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M80 368H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm0-320H16A16 16 0 0 0 0 64v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16zm0 160H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm416 176H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z" }, child: [] }] })(n);
}
const hI = () => {
  const n = tn.use.map(), [e, t] = st([]), i = tn.use.setSelectedLayers();
  xt(() => {
    i(n.getAllLayers().filter((s) => s.getVisible()));
  }, [n]);
  const r = tn.use.selectedLayers();
  return xt(() => {
    Promise.all(
      r.filter((s) => s.getSource() instanceof xm).map(async (s) => {
        var u;
        const o = s.getSource(), a = (u = o.getUrls()) == null ? void 0 : u[0], l = o.getParams().LAYERS, h = await (await Cu(
          await Pu(uI(a, l))
        )).blob();
        return URL.createObjectURL(h);
      })
    ).then((s) => t(s));
  }, [r]), !r || r.length === 0 ? null : /* @__PURE__ */ j.jsxs(
    "ul",
    {
      className: Fs(
        au.layersLegend,
        "list-unstyled mb-0 rounded p-2 bg-white"
      ),
      style: { backgroundColor: "rgb(255, 255, 255)", marginBottom: "80px" },
      children: [
        /* @__PURE__ */ j.jsxs("small", { className: "d-flex align-items-center mb-1", children: [
          /* @__PURE__ */ j.jsx(cI, { size: 5 }),
          " ",
          /* @__PURE__ */ j.jsx("span", { className: "ms-1", children: "Layers Legend" })
        ] }),
        e && e.length > 0 && e.filter((s, o) => !!r[o]).map((s, o) => /* @__PURE__ */ j.jsx("li", { children: /* @__PURE__ */ j.jsx("img", { src: s }) }, r[o].get("id")))
      ]
    }
  );
}, uI = (n, e) => `${n}?REQUEST=GetLegendGraphic&sld_version=1.0.0&layer=${e}&format=image/png&transparent=true&legend_options=fontSize:11;fontName:sans-serif;fontAntiAliasing:true;forceLabels:on;dpi:116&WIDTH=12&HEIGHT=12&Scale=1`, dI = ({
  showLatLon: n = !0,
  freezeMap: e = !1,
  INDIA_CENTER_COORDS: t,
  INITIAL_ZOOM: i,
  KEY: r,
  URL: s,
  callbackify: o,
  layersJson: a,
  API_URL: l,
  MAP_DATA: c,
  isProduction: h
}) => {
  const u = new Xt({
    layers: [
      new jo({
        visible: !1,
        preload: 1 / 0,
        opacity: 1,
        source: new VE({
          key: r,
          imagerySet: "Aerial"
        }),
        properties: { name: "Aerial" }
      }),
      new jo({
        visible: !1,
        source: new Qd({
          url: "http://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}"
        }),
        properties: { name: "High Resolution" }
      }),
      new jo({
        source: new Qd({
          url: s
        }),
        visible: !1,
        properties: { name: "India Tiles" }
      })
    ],
    properties: { name: "High Resolution Image" }
  }), d = new Xt({
    properties: { name: "High-Res Images" },
    layers: [u]
  }), f = ei(null), g = ei(!1), _ = tn.use.setMap(), m = tn.use.map(), [y, p] = st([d]), E = tn.use.selectedLayers(), [x, v] = st(), [S, w] = st([]), b = (I) => {
    const F = new Ri(new on(I));
    return F.setStyle(
      new wt({
        image: new nr({
          radius: 30,
          stroke: new Gt({ color: "green", width: 2 })
        })
      })
    ), F;
  }, P = Oo(
    (I, F) => {
      const B = b(I.coordinate);
      F.animateFeature(
        B,
        new yE({
          fade: Ii,
          duration: 2800,
          easing: gv
        })
      );
    },
    []
  ), O = Oo(
    (I) => {
      const [F, B] = rn(
        I.coordinate,
        "EPSG:3857",
        "EPSG:4326"
      ), $ = `POINT (${F} ${B})`;
      NS(l, { id: $ }).then((H) => {
        H != null && H[0] ? (console.log("hi"), o(H)) : we.warn("No data found for the selected point.");
      }).catch((H) => {
        we.error(H);
      }).finally(() => {
        m && m.un("singleclick", O);
      });
    },
    [m]
  ), N = (I) => {
    if (I.type === "layer")
      return new jo({
        source: new xm({
          crossOrigin: "anonymous",
          url: c,
          tileLoadFunction: nb,
          params: {
            version: "1.3.0",
            TILED: !0,
            LAYERS: I.paramLayers,
            STYLES: I.styles || "",
            CQL_FILTER: I.cql
          }
        }),
        properties: { id: I.id, name: I.label },
        visible: I.visible,
        maxResolution: I.maxResolution
      });
    const F = I.children.map(N);
    return new Xt({
      properties: { id: I.id, name: I.label },
      layers: F
    });
  };
  xt(() => {
    g.current || (g.current = !0, p((I) => [
      ...I,
      ...a.children.map(N)
    ]));
  }, []);
  const k = Oo(() => {
    GS(l, {}).then((I) => {
      w(I);
    }).catch((I) => {
      we.error(I);
    });
  }, []), D = Oo(() => {
    if (!m) return !1;
    const I = m.getAllLayers().find((F) => F.get("name") === "Hospital Birth");
    return (I == null ? void 0 : I.isVisible()) || !1;
  }, [m]);
  xt(() => {
    if (!m) return;
    D() ? k() : w([]);
  }, [
    m,
    k,
    E,
    D
  ]), xt(() => {
    if (!f.current) return;
    const I = [
      new pE(),
      new dE(),
      new fE({
        className: "bottom",
        src: "compact",
        style: new Gt({ color: "#75869d", width: 0 })
      })
    ], F = new Zi({
      target: f.current,
      layers: y,
      view: new xn({
        center: zy(t),
        zoom: i
      }),
      controls: e ? [] : [...nm().getArray(), ...I],
      interactions: e ? [] : am()
    }), B = new gE({ layers: F.getAllLayers() });
    F.addControl(B);
    const $ = (H) => P(H, F);
    return F.on("singleclick", $), _(F), () => {
      I.forEach((H) => F.removeControl(H)), F.un("singleclick", $), F.dispose(), F.setTarget(void 0);
    };
  }, [y, e, P, _]), xt(() => {
    if (!m) return;
    const I = m.getAllLayers().find((F) => F.get("name") === "cluster-layer");
    I && m.removeLayer(I), x && D() && m.addLayer(x);
  }, [x, m, D]), xt(() => {
    if (!Array.isArray(S) || S.length < 1) {
      v(void 0);
      return;
    }
    if ((S == null ? void 0 : S.length) > 0) {
      const I = S.length, F = new Array(I);
      for (let re = 0; re < I; ++re) {
        const A = [
          parseFloat(S[re].lon),
          parseFloat(S[re].lat)
        ];
        F[re] = new Ri(
          new on(rn(A, "EPSG:4326", "EPSG:3857"))
        ), F[re].set("count", S[re].count);
      }
      const B = new fo({ features: F }), $ = new XE({
        distance: 40,
        source: B
      }), H = new xE({
        source: $,
        animationDuration: 700,
        style: X,
        properties: { name: "cluster-layer" }
      });
      v(H);
    }
  }, [S]);
  let U = {};
  function X(I, F) {
    var re, A;
    const $ = (A = (re = I.get("features")) == null ? void 0 : re[0]) == null ? void 0 : A.get("count");
    let H = U[$];
    if ($) {
      const Fe = $ > 25 ? "192,0,0" : $ > 8 ? "255,128,0" : "0,128,0", ze = Math.max(8, Math.min($ * 0.75, 20)), Ce = new Array(7).fill(2 * Math.PI * ze / 6);
      Ce[0] = 0, H = U[$] = new wt({
        image: new nr({
          radius: ze,
          stroke: new Gt({
            color: "rgba(" + Fe + ",0.5)",
            width: 15,
            lineDash: Ce,
            lineCap: "butt"
          }),
          fill: new ri({ color: "rgba(" + Fe + ",1)" })
        }),
        text: new Ki({
          text: $.toString(),
          fill: new ri({ color: "#fff" })
        })
      });
    }
    return H;
  }
  return /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
    /* @__PURE__ */ j.jsx(
      "div",
      {
        id: "map",
        ref: f,
        className: Fs(au.map, s1.map)
      }
    ),
    /* @__PURE__ */ j.jsx(hI, {}),
    n && /* @__PURE__ */ j.jsx(lI, {}),
    !1,
    /* @__PURE__ */ j.jsx(rb, {})
  ] });
};
var fI = function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? s(h.value) : r(h.value).then(a, l);
    }
    c((i = i.apply(n, e || [])).next());
  });
}, gI = function(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, r, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(h) {
      return l([c, h]);
    };
  }
  function l(c) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (i = 1, r && (s = c[0] & 2 ? r.return : c[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, c[1])).done) return s;
      switch (r = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
        case 0:
        case 1:
          s = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: !1 };
        case 5:
          t.label++, r = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = c;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(c);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(n, t);
    } catch (h) {
      c = [6, h], r = 0;
    } finally {
      i = s = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, mI = (
  /** @class */
  function() {
    function n(e) {
      this.handlerCount = 0, this.handlers = [], this.options = e;
    }
    return Object.defineProperty(n.prototype, "numberOfHandlers", {
      get: function() {
        return this.handlers.filter(function(e) {
          return !!e;
        }).length;
      },
      enumerable: !1,
      configurable: !0
    }), n.prototype.emit = function(e) {
      var t, i;
      return fI(this, void 0, void 0, function() {
        var r, s, o, a, l;
        return gI(this, function(c) {
          switch (c.label) {
            case 0:
              for (r = [], (i = (t = this.options) === null || t === void 0 ? void 0 : t.logger) === null || i === void 0 || i.call(t, "emit", e), s = 0, o = this.handlers; s < o.length; s++)
                a = o[s], a && (l = a(e), typeof (l == null ? void 0 : l.then) == "function" && r.push(l));
              return [4, Promise.all(r)];
            case 1:
              return c.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.on = function(e) {
      var t, i;
      return (i = (t = this.options) === null || t === void 0 ? void 0 : t.logger) === null || i === void 0 || i.call(t, "on"), this.handlers.push(e), this.handlerCount++;
    }, n.prototype.off = function(e) {
      this.delete(e);
    }, n.prototype.delete = function(e) {
      var t, i;
      (i = (t = this.options) === null || t === void 0 ? void 0 : t.logger) === null || i === void 0 || i.call(t, "off"), this.handlers[e] = null;
    }, n;
  }()
), vc = function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? s(h.value) : r(h.value).then(a, l);
    }
    c((i = i.apply(n, e || [])).next());
  });
}, Ec = function(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, r, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(h) {
      return l([c, h]);
    };
  }
  function l(c) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (i = 1, r && (s = c[0] & 2 ? r.return : c[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, c[1])).done) return s;
      switch (r = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
        case 0:
        case 1:
          s = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: !1 };
        case 5:
          t.label++, r = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = c;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(c);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(n, t);
    } catch (h) {
      c = [6, h], r = 0;
    } finally {
      i = s = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, _I = (
  /** @class */
  function() {
    function n(e, t) {
      this.onDidChangeTreeDataEmitter = new mI(), this.data = { items: e }, this.setItemName = t;
    }
    return n.prototype.getTreeItem = function(e) {
      return vc(this, void 0, void 0, function() {
        return Ec(this, function(t) {
          return [2, this.data.items[e]];
        });
      });
    }, n.prototype.onChangeItemChildren = function(e, t) {
      return vc(this, void 0, void 0, function() {
        return Ec(this, function(i) {
          return this.data.items[e].children = t, this.onDidChangeTreeDataEmitter.emit([e]), [
            2
            /*return*/
          ];
        });
      });
    }, n.prototype.onDidChangeTreeData = function(e) {
      var t = this, i = this.onDidChangeTreeDataEmitter.on(function(r) {
        return e(r);
      });
      return { dispose: function() {
        return t.onDidChangeTreeDataEmitter.off(i);
      } };
    }, n.prototype.onRenameItem = function(e, t) {
      return vc(this, void 0, void 0, function() {
        return Ec(this, function(i) {
          return this.setItemName && (this.data.items[e.index] = this.setItemName(e, t)), [
            2
            /*return*/
          ];
        });
      });
    }, n;
  }()
);
const pI = [68.11, 6.4, 96.41, 37.5];
Wy(
  pI,
  "EPSG:4326",
  "EPSG:3857"
);
const Nf = (n) => n instanceof Xt, yI = "_container_1j5vm_1", xI = "_btnRootGroup_1j5vm_7", vI = "_drawer_1j5vm_21", EI = "_drawerclosebutton_1j5vm_30", TI = "_drawerbody_1j5vm_76", Ss = {
  container: yI,
  btnRootGroup: xI,
  drawer: vI,
  drawerclosebutton: EI,
  drawerbody: TI
}, wI = () => {
  const n = tn.use.map(), e = tn.use.selectedLayers(), t = tn.use.setSelectedLayers(), [i, r] = st(!1), [s, o] = st(), [a, l] = st(), [c, h] = st(
    {}
  ), [u, d] = st({}), f = (x, v) => {
    if (v.setVisible(x.target.checked), v.changed(), x.target.checked)
      t(e.concat(v));
    else {
      const S = e.filter(
        (w) => v.get("name") !== w.get("name")
      );
      t(S);
    }
    h({
      ...c,
      [v.get("name")]: x.target.checked
    });
  }, g = n.getAllLayers().length;
  xt(() => {
    const x = {};
    n.getAllLayers().filter((v) => v.getVisible()).forEach((v) => {
      x[v.get("name")] = v.getVisible();
    }), h(x);
  }, [g]);
  const _ = (x, v) => {
    const S = document.createElement("div");
    S.className = "custom-tooltip", S.textContent = v, S.style.cssText = `
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
      pointer-events: none;
    `, document.body.appendChild(S);
    const w = x.currentTarget.getBoundingClientRect();
    S.style.left = `${w.left - S.offsetWidth - 10}px`, S.style.top = `${w.top + w.height / 2 - S.offsetHeight / 2}px`, x.currentTarget.setAttribute(
      "data-tooltip",
      S.id = Date.now().toString()
    );
  }, m = (x) => {
    const v = x.currentTarget.getAttribute("data-tooltip");
    if (v) {
      const S = document.getElementById(v);
      S && S.remove(), x.currentTarget.removeAttribute("data-tooltip");
    }
  }, y = (x) => {
    const v = {
      root: mh("root", !0, void 0)
    };
    ap(x, "root", v), l(new _I(v)), o(x), r(!0);
  }, p = () => {
    r(!1), o(void 0);
  }, E = (x) => {
    d((v) => ({
      ...v,
      [x]: !v[x]
    }));
  };
  return n.getLayers().getLength() === 0 ? null : /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
    /* @__PURE__ */ j.jsx(
      "div",
      {
        className: Fs(
          Ss.container,
          "d-flex justify-content-end align-items-center"
        ),
        children: /* @__PURE__ */ j.jsx("ul", { className: "list-unstyled", children: n.getLayers().getArray().filter(Nf).map((x, v) => /* @__PURE__ */ j.jsx(
          "li",
          {
            className: "mb-2",
            onClick: () => y(x),
            children: /* @__PURE__ */ j.jsx(
              "button",
              {
                className: Fs(Ss.btnRootGroup, "rounded"),
                onMouseEnter: (S) => _(S, x.get("name")),
                onMouseLeave: m,
                title: x.get("name")
              }
            )
          },
          v
        )) })
      }
    ),
    i && /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
      /* @__PURE__ */ j.jsx(
        "div",
        {
          className: "drawer-overlay",
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: "transparent",
            pointerEvents: "none",
            zIndex: 1e3
          }
        }
      ),
      /* @__PURE__ */ j.jsxs(
        "div",
        {
          className: Fs(Ss.drawer, "custom-drawer"),
          style: {
            position: "fixed",
            top: 0,
            right: 0,
            height: "100vh",
            width: "384px",
            backgroundColor: "white",
            boxShadow: "-4px 0 15px rgba(0, 0, 0, 0.1)",
            zIndex: 1001,
            pointerEvents: "all",
            display: "flex",
            flexDirection: "column"
          },
          children: [
            /* @__PURE__ */ j.jsx(
              "button",
              {
                className: Ss.drawerclosebutton,
                onClick: p,
                style: {
                  position: "absolute",
                  top: "12px",
                  right: "12px",
                  background: "none",
                  border: "none",
                  fontSize: "24px",
                  cursor: "pointer",
                  color: "black",
                  zIndex: 1002
                },
                children: "✕"
              }
            ),
            /* @__PURE__ */ j.jsx(
              "div",
              {
                className: "drawer-header",
                style: {
                  padding: "16px 24px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.28)",
                  backgroundColor: "transparent"
                },
                children: /* @__PURE__ */ j.jsx("h4", { style: { margin: 0, fontSize: "18px", fontWeight: "600" }, children: s == null ? void 0 : s.get("name") })
              }
            ),
            /* @__PURE__ */ j.jsx(
              "div",
              {
                className: Ss.drawerbody,
                style: {
                  flex: 1,
                  padding: "16px 24px",
                  overflow: "auto"
                },
                children: /* @__PURE__ */ j.jsx("div", { className: "custom-accordion", children: !!s && s.getLayers().getArray().filter(Nf).map((x, v) => {
                  const S = x.get("name"), w = u[S];
                  return /* @__PURE__ */ j.jsxs(
                    "div",
                    {
                      className: "accordion-item",
                      style: { marginBottom: "8px" },
                      children: [
                        /* @__PURE__ */ j.jsxs(
                          "button",
                          {
                            className: "accordion-button",
                            onClick: () => E(S),
                            style: {
                              width: "100%",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "space-between",
                              padding: "12px 16px",
                              background: "transparent",
                              border: "1px solid #e2e8f0",
                              borderRadius: "6px",
                              cursor: "pointer",
                              fontSize: "14px",
                              textAlign: "left"
                            },
                            children: [
                              /* @__PURE__ */ j.jsx("span", { children: S }),
                              /* @__PURE__ */ j.jsx(
                                "span",
                                {
                                  style: {
                                    transform: w ? "rotate(180deg)" : "rotate(0deg)",
                                    transition: "transform 0.2s ease"
                                  },
                                  children: "▼"
                                }
                              )
                            ]
                          }
                        ),
                        w && /* @__PURE__ */ j.jsx(
                          "div",
                          {
                            className: "accordion-panel",
                            style: {
                              padding: "16px",
                              borderLeft: "1px solid #e2e8f0",
                              borderRight: "1px solid #e2e8f0",
                              borderBottom: "1px solid #e2e8f0",
                              borderTop: "none",
                              borderRadius: "0 0 6px 6px",
                              marginTop: "-1px"
                            },
                            children: x.getLayers().getArray().map((b, P) => /* @__PURE__ */ j.jsxs(
                              "div",
                              {
                                className: "d-flex align-items-center",
                                style: {
                                  display: "flex",
                                  alignItems: "center",
                                  marginBottom: "8px"
                                },
                                children: [
                                  /* @__PURE__ */ j.jsx(
                                    "input",
                                    {
                                      style: {
                                        accentColor: "#007780",
                                        marginRight: "8px"
                                      },
                                      type: "checkbox",
                                      autoComplete: "off",
                                      autoCorrect: "off",
                                      checked: !!c[b.get("name")],
                                      onChange: (O) => f(O, b)
                                    }
                                  ),
                                  /* @__PURE__ */ j.jsx("span", { style: { fontSize: "14px" }, children: b.get("name") })
                                ]
                              },
                              P
                            ))
                          }
                        )
                      ]
                    },
                    v
                  );
                }) })
              }
            )
          ]
        }
      )
    ] })
  ] });
}, mh = (n, e, t) => ({
  index: n,
  isFolder: e,
  data: t,
  children: [],
  canMove: !1,
  canRename: !1
}), ap = (n, e, t) => {
  if (n instanceof Xt)
    n.getLayers().getArray().forEach((r) => {
      var o;
      const s = r.get("name");
      (o = t[e].children) == null || o.push(s), t[s] = mh(
        s,
        r instanceof Xt,
        s
      ), ap(r, s, t);
    });
  else {
    const i = n.get("name");
    t[i] = mh(i, !1, n);
  }
}, aA = ({ obj: n }) => (xt(() => {
  localStorage.setItem(
    "isProduction",
    n == null ? void 0 : n.isProduction
  );
}, [n == null ? void 0 : n.isProduction]), /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
  /* @__PURE__ */ j.jsx(
    dI,
    {
      showLatLon: n == null ? void 0 : n.showLatLon,
      freezeMap: n == null ? void 0 : n.freezeMap,
      INDIA_CENTER_COORDS: n == null ? void 0 : n.INDIA_CENTER_COORDS,
      INITIAL_ZOOM: n == null ? void 0 : n.INITIAL_ZOOM,
      KEY: n == null ? void 0 : n.KEY,
      URL: n == null ? void 0 : n.URL,
      callbackify: n == null ? void 0 : n.handleChildCallback,
      layersJson: n.layersJsonDefault,
      API_URL: n == null ? void 0 : n.API_URL,
      MAP_DATA: n == null ? void 0 : n.MAP_DATA,
      isProduction: n == null ? void 0 : n.isProduction
    }
  ),
  /* @__PURE__ */ j.jsx(wI, {}),
  /* @__PURE__ */ j.jsx(Zp, {})
] }));
export {
  aA as MAP
};
